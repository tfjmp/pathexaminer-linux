
;; Function trace_task_newtask (trace_task_newtask, funcdef_no=3171, decl_uid=45401, cgraph_uid=3171) (unlikely executed)

trace_task_newtask (struct task_struct * task, long unsigned int clone_flags)
{
  void * __data;
  void * it_func;
  struct tracepoint_func * it_func_ptr;
  void (*<T6d1f>) (void *, struct task_struct *, long unsigned int) it_func.71;
  void * _18;
  long long unsigned int _22;

  <bb 2>:
  __asm__ __volatile__ goto("1:.byte 0x0f,0x1f,0x44,0x00,0
	.pushsection __jump_table,  "aw" 
	 .balign 8 
	 .quad 1b, %l2, %c0 + %c1 
	.popsection 
	" :  : "i" &__tracepoint_task_newtask.key, "i" 0 :  : "l_yes" <L24>);

  <bb 3>:
  __asm__ __volatile__("");
  goto <bb 7>;

  <bb 4>:

  <bb 5>:
  # it_func_ptr_1 = PHI <it_func_ptr_9(9), it_func_ptr_17(4)>
  it_func_11 = MEM[base: it_func_ptr_1, offset: 0B];
  __data_12 = MEM[base: it_func_ptr_1, offset: 8B];
  it_func.71_13 = (void (*<T6d1f>) (void *, struct task_struct *, long unsigned int)) it_func_11;
  it_func.71_13 (__data_12, task_14(D), clone_flags_15(D));
  it_func_ptr_17 = it_func_ptr_1 + 16;
  _18 = MEM[base: it_func_ptr_17, offset: 0B];
  if (_18 != 0B)
    goto <bb 4>;
  else
    goto <bb 6>;

  <bb 6>:
  __asm__ __volatile__("" :  :  : "memory");

  <bb 7>:
  return;

<L24>:
  __asm__ __volatile__("" :  :  : "memory");
  _22 ={v} MEM[(volatile __u64 *)&__tracepoint_task_newtask + 48B];
  it_func_ptr_9 = (struct tracepoint_func *) _22;
  if (it_func_ptr_9 != 0B)
    goto <bb 9>;
  else
    goto <bb 6>;

  <bb 9>:
  goto <bb 5>;

}



;; Function set_max_threads (set_max_threads, funcdef_no=3210, decl_uid=45806, cgraph_uid=3210)

set_max_threads (unsigned int max_threads_suggested)
{
  int bitpos;
  int bitpos;
  u64 __max1;
  u64 __min1;
  int max_threads.28;
  long unsigned int totalram_pages.26;
  int _5;
  long long unsigned int _6;
  u64 _10;
  int _14;
  int _16;

  <bb 2>:
  totalram_pages.26_4 = totalram_pages;
  __asm__("bsrq %1,%q0" : "=r" bitpos_13 : "rm" totalram_pages.26_4, "0" -1);
  _14 = bitpos_13 + 1;
  __asm__("bsrq %1,%q0" : "=r" bitpos_15 : "rm" 4096, "0" -1);
  _16 = bitpos_15 + 1;
  _5 = _14 + _16;
  if (_5 > 64)
    goto <bb 4>;
  else
    goto <bb 3>;

  <bb 3>:
  _6 = totalram_pages.26_4 * 4096;
  __max1_17 = _6 >> 17;

  <bb 4>:
  # __max1_1 = PHI <1073741823(2), __max1_17(3)>
  __max1_8 = (u64) max_threads_suggested_7(D);
  __max1_20 = MIN_EXPR <__max1_1, __max1_8>;
  __min1_9 = MAX_EXPR <__max1_20, 20>;
  _10 = MIN_EXPR <__min1_9, 1073741823>;
  max_threads.28_11 = (int) _10;
  max_threads = max_threads.28_11;
  return;

}



;; Function posix_cpu_timers_init (posix_cpu_timers_init, funcdef_no=3654, decl_uid=50954, cgraph_uid=3655)

posix_cpu_timers_init (struct task_struct * tsk)
{
  struct list_head * _6;
  struct list_head * _8;
  struct list_head * _10;

  <bb 2>:
  tsk_2(D)->cputime_expires.stime = 0;
  tsk_2(D)->cputime_expires.utime = 0;
  tsk_2(D)->cputime_expires.sum_exec_runtime = 0;
  _6 = &tsk_2(D)->cpu_timers[0];
  MEM[(struct list_head *)tsk_2(D) + 1392B].next = _6;
  MEM[(struct list_head *)tsk_2(D) + 1392B].prev = _6;
  _8 = &tsk_2(D)->cpu_timers[1];
  MEM[(struct list_head *)tsk_2(D) + 1408B].next = _8;
  MEM[(struct list_head *)tsk_2(D) + 1408B].prev = _8;
  _10 = &tsk_2(D)->cpu_timers[2];
  MEM[(struct list_head *)tsk_2(D) + 1424B].next = _10;
  MEM[(struct list_head *)tsk_2(D) + 1424B].prev = _10;
  return;

}



;; Function set_ti_thread_flag (set_ti_thread_flag, funcdef_no=444, decl_uid=5240, cgraph_uid=444) (unlikely executed)

set_ti_thread_flag (struct thread_info * ti, int flag)
{
  __u32 * _2;
  long int _4;

  <bb 2>:
  _2 = &ti_1(D)->flags;
  _4 = (long int) flag_3(D);
  __asm__ __volatile__(".pushsection .smp_locks,"a"
.balign 4
.long 671f - .
.popsection
671:
	lock; bts %1,%0" : "=m" MEM[(volatile long int *)_2] : "Ir" _4, "m" MEM[(volatile long int *)_2] : "memory");
  return;

}



;; Function clear_ti_thread_flag (clear_ti_thread_flag, funcdef_no=445, decl_uid=5244, cgraph_uid=445)

clear_ti_thread_flag (struct thread_info * ti, int flag)
{
  __u32 * _2;
  long int _4;

  <bb 2>:
  _2 = &ti_1(D)->flags;
  _4 = (long int) flag_3(D);
  __asm__ __volatile__(".pushsection .smp_locks,"a"
.balign 4
.long 671f - .
.popsection
671:
	lock; btr %1,%0" : "=m" MEM[(volatile long int *)_2] : "Ir" _4, "m" MEM[(volatile long int *)_2]);
  return;

}



;; Function clear_tsk_thread_flag (clear_tsk_thread_flag, funcdef_no=1937, decl_uid=25019, cgraph_uid=1937) (unlikely executed)

clear_tsk_thread_flag (struct task_struct * tsk, int flag)
{
  void * _3;

  <bb 2>:
  _3 = tsk_2(D)->stack;
  clear_ti_thread_flag (_3, flag_4(D));
  return;

}



;; Function syscall_tracepoint_update (syscall_tracepoint_update, funcdef_no=2540, decl_uid=34345, cgraph_uid=2540) (unlikely executed)

syscall_tracepoint_update (struct task_struct * p)
{
  u64 pfo_ret__;
  long unsigned int _8;
  struct thread_info * _9;
  long unsigned int _10;
  long unsigned int _11;
  long unsigned int _12;
  void * _13;
  void * _14;

  <bb 2>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___7 : "p" &cpu_tss.x86_tss.sp0);
  _8 = pfo_ret___7 + 18446744073709535232;
  _9 = (struct thread_info *) _8;
  _10 ={v} MEM[(const long unsigned int *)_9 + 8B];
  _11 = _10 >> 28;
  _12 = _11 & 1;
  if (_12 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _13 = p_4(D)->stack;
  set_ti_thread_flag (_13, 28);
  goto <bb 5>;

  <bb 4>:
  _14 = p_4(D)->stack;
  clear_ti_thread_flag (_14, 28);

  <bb 5>:
  return;

}



;; Function trace_raw_output_task_newtask (trace_raw_output_task_newtask, funcdef_no=3183, decl_uid=45578, cgraph_uid=3183)

trace_raw_output_task_newtask (struct trace_iterator * iter, int flags, struct trace_event * trace_event)
{
  int ret;
  struct trace_event_raw_task_newtask * field;
  struct trace_seq * s;
  print_line_t _1;
  print_line_t _10;
  short int _11;
  int _12;
  long unsigned int _13;
  char[16] * _14;
  int _15;
  int _17;
  long unsigned int _18;
  long unsigned int _19;
  print_line_t _22;
  _Bool _24;

  <bb 2>:
  field_6 = iter_3(D)->ent;
  ret_9 = trace_raw_output_prep (iter_3(D), trace_event_7(D));
  if (ret_9 != 1)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _10 = (print_line_t) ret_9;
  goto <bb 6>;

  <bb 4>:
  _11 = field_6->oom_score_adj;
  _12 = (int) _11;
  _13 = field_6->clone_flags;
  _14 = &field_6->comm;
  _15 = field_6->pid;
  s_4 = &iter_3(D)->seq;
  trace_seq_printf (s_4, "pid=%d comm=%s clone_flags=%lx oom_score_adj=%hd\n", _15, _14, _13, _12);
  _17 = MEM[(struct trace_seq *)iter_3(D) + 4248B].full;
  if (_17 != 0)
    goto <bb 6>;
  else
    goto <bb 5>;

  <bb 5>:
  _18 = MEM[(struct seq_buf *)iter_3(D) + 8352B];
  _19 = MEM[(struct seq_buf *)iter_3(D) + 8360B];
  _24 = _18 >= _19;
  _22 = (print_line_t) _24;

  <bb 6>:
  # _1 = PHI <_10(3), _22(5), 0(4)>
  return _1;

}



;; Function trace_raw_output_task_rename (trace_raw_output_task_rename, funcdef_no=3184, decl_uid=45588, cgraph_uid=3184)

trace_raw_output_task_rename (struct trace_iterator * iter, int flags, struct trace_event * trace_event)
{
  int ret;
  struct trace_event_raw_task_rename * field;
  struct trace_seq * s;
  print_line_t _1;
  print_line_t _10;
  short int _11;
  int _12;
  char[16] * _13;
  char[16] * _14;
  int _15;
  int _17;
  long unsigned int _18;
  long unsigned int _19;
  print_line_t _22;
  _Bool _24;

  <bb 2>:
  field_6 = iter_3(D)->ent;
  ret_9 = trace_raw_output_prep (iter_3(D), trace_event_7(D));
  if (ret_9 != 1)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _10 = (print_line_t) ret_9;
  goto <bb 6>;

  <bb 4>:
  _11 = field_6->oom_score_adj;
  _12 = (int) _11;
  _13 = &field_6->newcomm;
  _14 = &field_6->oldcomm;
  _15 = field_6->pid;
  s_4 = &iter_3(D)->seq;
  trace_seq_printf (s_4, "pid=%d oldcomm=%s newcomm=%s oom_score_adj=%hd\n", _15, _14, _13, _12);
  _17 = MEM[(struct trace_seq *)iter_3(D) + 4248B].full;
  if (_17 != 0)
    goto <bb 6>;
  else
    goto <bb 5>;

  <bb 5>:
  _18 = MEM[(struct seq_buf *)iter_3(D) + 8352B];
  _19 = MEM[(struct seq_buf *)iter_3(D) + 8360B];
  _24 = _18 >= _19;
  _22 = (print_line_t) _24;

  <bb 6>:
  # _1 = PHI <_10(3), _22(5), 0(4)>
  return _1;

}



;; Function perf_trace_task_rename (perf_trace_task_rename, funcdef_no=3195, decl_uid=45673, cgraph_uid=3195)

perf_trace_task_rename (void * __data, struct task_struct * task, const char * comm)
{
  struct stack_frame * frame;
  long unsigned int tcp_ptr__;
  int rctx;
  struct pt_regs * __regs;
  struct trace_event_raw_task_rename * entry;
  int rctx.11;
  struct pt_regs * __regs.10;
  struct hlist_head * _5;
  struct hlist_head * _7;
  int _8;
  int _9;
  int _15;
  char[16] * _17;
  char[16] * _18;
  char[16] * _20;
  struct signal_struct * _23;
  short int _24;
  struct hlist_node * _31;
  void * _35;
  long unsigned int _36;
  long unsigned int _39;

  <bb 2>:
  _5 = MEM[(struct trace_event_call *)__data_3(D)].perf_events;
  __asm__ __volatile__("add %%gs:%1, %0" : "=r" tcp_ptr___6 : "m" this_cpu_off, "0" _5);
  _7 = (struct hlist_head *) tcp_ptr___6;
  _31 = MEM[(const struct hlist_head *)_7].first;
  if (_31 == 0B)
    goto <bb 5>;
  else
    goto <bb 3>;

  <bb 3>:
  _8 = MEM[(struct trace_event_call *)__data_3(D)].event.type;
  _9 = _8 & 65535;
  entry_11 = perf_trace_buf_prepare (52, _9, &__regs, &rctx);
  if (entry_11 == 0B)
    goto <bb 5>;
  else
    goto <bb 4>;

  <bb 4>:
  __regs.10_12 = __regs;
  memset (__regs.10_12, 0, 168);
  _35 = __builtin_return_address (0);
  _36 = (long unsigned int) _35;
  __regs.10_12->ip = _36;
  __asm__("movq %%rbp, %0" : "=r" frame_37);
  frame_38 = frame_37->next_frame;
  _39 = (long unsigned int) frame_38;
  __regs.10_12->bp = _39;
  __regs.10_12->cs = 16;
  __regs.10_12->flags = 0;
  __asm__ __volatile__(" movq %%rsp, %0
" : "=m" __regs.10_12->sp :  : "memory");
  _15 = task_14(D)->pid;
  entry_11->pid = _15;
  _17 = &task_14(D)->comm;
  _18 = &entry_11->oldcomm;
  memcpy (_18, _17, 16);
  _20 = &entry_11->newcomm;
  strlcpy (_20, comm_21(D), 16);
  _23 = task_14(D)->signal;
  _24 = _23->oom_score_adj;
  entry_11->oom_score_adj = _24;
  __regs.10_26 = __regs;
  rctx.11_27 = rctx;
  perf_tp_event (0, 1, entry_11, 52, __regs.10_26, _7, rctx.11_27, 0B);
  __regs ={v} {CLOBBER};
  rctx ={v} {CLOBBER};
  goto <bb 6>;

  <bb 5>:
  __regs ={v} {CLOBBER};
  rctx ={v} {CLOBBER};

  <bb 6>:
  return;

}



;; Function trace_event_raw_event_task_rename (trace_event_raw_event_task_rename, funcdef_no=3191, decl_uid=45652, cgraph_uid=3191)

trace_event_raw_event_task_rename (void * __data, struct task_struct * task, const char * comm)
{
  long unsigned int eflags;
  struct trace_event_raw_task_rename * entry;
  struct trace_event_buffer fbuffer;
  int _10;
  char[16] * _12;
  char[16] * _13;
  char[16] * _15;
  struct signal_struct * _18;
  short int _19;
  long unsigned int _25;
  long unsigned int _26;
  long unsigned int _27;

  <bb 2>:
  eflags_24 = MEM[(struct trace_event_file *)__data_3(D)].flags;
  _25 = eflags_24 & 128;
  if (_25 == 0)
    goto <bb 3>;
  else
    goto <bb 9>;

  <bb 3>:
  _26 = eflags_24 & 64;
  if (_26 != 0)
    goto <bb 4>;
  else
    goto <bb 5>;

  <bb 4>:
  event_triggers_call (__data_3(D), 0B);

  <bb 5>:
  _27 = eflags_24 & 32;
  if (_27 != 0)
    goto <bb 7>;
  else
    goto <bb 9>;

  <bb 6>:
  _10 = task_9(D)->pid;
  entry_8->pid = _10;
  _12 = &task_9(D)->comm;
  _13 = &entry_8->oldcomm;
  memcpy (_13, _12, 16);
  _15 = &entry_8->newcomm;
  strlcpy (_15, comm_16(D), 16);
  _18 = task_9(D)->signal;
  _19 = _18->oom_score_adj;
  entry_8->oom_score_adj = _19;
  trace_event_buffer_commit (&fbuffer);
  fbuffer ={v} {CLOBBER};
  goto <bb 8>;

  <bb 7>:
  fbuffer ={v} {CLOBBER};

  <bb 8>:
  return;

  <bb 9>:
  entry_8 = trace_event_buffer_reserve (&fbuffer, __data_3(D), 48);
  if (entry_8 == 0B)
    goto <bb 7>;
  else
    goto <bb 6>;

}



;; Function account_kernel_stack (account_kernel_stack, funcdef_no=3204, decl_uid=45771, cgraph_uid=3204)

account_kernel_stack (struct thread_info * ti, int account)
{
  long unsigned int iftmp.17;
  long unsigned int y;
  long unsigned int x;
  struct zone * zone;
  long unsigned int ti.16;
  long unsigned int _4;
  long unsigned int _5;
  const struct page * _6;
  long unsigned int _14;
  long unsigned int _15;
  int _16;
  struct pglist_data * _17;
  long unsigned int _18;
  unsigned int _19;
  zone_type _20;

  <bb 2>:
  ti.16_2 = (long unsigned int) ti_1(D);
  y_10 = ti.16_2 + 2147483648;
  if (ti.16_2 > y_10)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  iftmp.17_11 = phys_base;

  <bb 4>:
  # iftmp.17_12 = PHI <131939247849472(2), iftmp.17_11(3)>
  x_13 = iftmp.17_12 + y_10;
  _4 = x_13 >> 12;
  _5 = _4 * 64;
  _6 = -24189255811072B + _5;
  _14 = MEM[(const struct page *)_6];
  _15 = _14 >> 58;
  _16 = (int) _15;
  _17 = node_data[_16];
  _18 = _14 >> 56;
  _19 = (unsigned int) _18;
  _20 = _19 & 3;
  zone_7 = &_17->node_zones[_20];
  mod_zone_page_state (zone_7, 16, account_8(D));
  return;

}



;; Function free_signal_struct (free_signal_struct, funcdef_no=3206, decl_uid=45783, cgraph_uid=3206)

free_signal_struct (struct signal_struct * sig)
{
  struct kmem_cache * taskstats_cache.22;
  struct kmem_cache * signal_cachep.21;
  struct taskstats * _3;

  <bb 2>:
  _3 = MEM[(struct signal_struct *)sig_2(D) + 992B];
  if (_3 != 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  taskstats_cache.22_7 = taskstats_cache;
  kmem_cache_free (taskstats_cache.22_7, _3);

  <bb 4>:
  signal_cachep.21_5 = signal_cachep;
  kmem_cache_free (signal_cachep.21_5, sig_2(D));
  return;

}



;; Function get_mm_exe_file (get_mm_exe_file, funcdef_no=3635, decl_uid=17460, cgraph_uid=3635)

get_mm_exe_file (struct mm_struct * mm)
{
  long int c;
  volatile u64 * __ptr;
  struct file * exe_file;
  long long unsigned int _13;
  long int _16;
  long int _19;

  <bb 2>:
  __asm__ __volatile__("" :  :  : "memory");
  _13 ={v} MEM[(volatile __u64 *)mm_5(D) + 832B];
  exe_file_7 = (struct file *) _13;
  if (exe_file_7 != 0B)
    goto <bb 4>;
  else
    goto <bb 3>;

  <bb 3>:
  goto <bb 10>;

  <bb 4>:
  c_14 ={v} MEM[(const long int *)exe_file_7 + 56B];
  if (c_14 == 0)
    goto <bb 3>;
  else
    goto <bb 5>;

  <bb 5>:
  _16 = c_14 + 1;
  __ptr_17 = &MEM[(struct atomic64_t *)exe_file_7 + 56B].counter;
  __asm__ __volatile__(".pushsection .smp_locks,"a"
.balign 4
.long 671f - .
.popsection
671:
	lock; cmpxchgq %2,%1" : "=a" c_12, "=m" *__ptr_17 : "r" _16, "0" c_14, "m" *__ptr_17 : "memory");
  if (c_12 == c_14)
    goto <bb 10>;
  else
    goto <bb 6>;

  <bb 6>:
  goto <bb 9>;

  <bb 7>:
  _19 = c_24 + 1;
  __asm__ __volatile__(".pushsection .smp_locks,"a"
.balign 4
.long 671f - .
.popsection
671:
	lock; cmpxchgq %2,%1" : "=a" c_21, "=m" *__ptr_17 : "r" _19, "0" c_24, "m" *__ptr_17 : "memory");
  if (c_21 == c_24)
    goto <bb 10>;
  else
    goto <bb 8>;

  <bb 8>:

  <bb 9>:
  # c_24 = PHI <c_21(8), c_12(6)>
  if (c_24 == 0)
    goto <bb 3>;
  else
    goto <bb 7>;

  <bb 10>:
  # exe_file_1 = PHI <0B(3), exe_file_7(7), exe_file_7(5)>
  __asm__ __volatile__("" :  :  : "memory");
  return exe_file_1;

}



;; Function signal_pending (signal_pending, funcdef_no=1945, decl_uid=25046, cgraph_uid=1945) (unlikely executed)

signal_pending (struct task_struct * p)
{
  int _6;
  void * _7;
  long unsigned int _8;
  long unsigned int _9;
  long unsigned int _10;

  <bb 2>:
  _7 = p_2(D)->stack;
  _8 ={v} MEM[(const long unsigned int *)_7 + 8B];
  _9 = _8 >> 2;
  _10 = _9 & 1;
  _6 = (int) _10;
  return _6;

}



;; Function tty_kref_get (tty_kref_get, funcdef_no=2674, decl_uid=38898, cgraph_uid=2674) (unlikely executed)

tty_kref_get (struct tty_struct * tty)
{
  _Bool __warned.67;
  int __ret;
  static bool __warned;
  struct atomic_t * _6;
  int _8;

  <bb 2>:
  if (tty_2(D) != 0B)
    goto <bb 4>;
  else
    goto <bb 3>;

  <bb 3>:
  goto <bb 7>;

  <bb 4>:
  _6 = &MEM[(struct kref *)tty_2(D) + 4B].refcount;
  __asm__ __volatile__(".pushsection .smp_locks,"a"
.balign 4
.long 671f - .
.popsection
671:
	lock; xaddl %0, %1
" : "=r" __ret_7, "=m" _6->counter : "0" 1, "m" _6->counter : "cc", "memory", "memory");
  _8 = __ret_7 + 1;
  if (_8 <= 1)
    goto <bb 5>;
  else
    goto <bb 3>;

  <bb 5>:
  __warned.67_12 = __warned;
  if (__warned.67_12 != 0)
    goto <bb 3>;
  else
    goto <bb 6>;

  <bb 6>:
  warn_slowpath_null ("include/linux/kref.h", 47);
  __warned = 1;

  <bb 7>:
  return tty_2(D);

}



;; Function coredump_filter_setup (coredump_filter_setup, funcdef_no=3218, decl_uid=45876, cgraph_uid=3218) (unlikely executed)

coredump_filter_setup (char * s)
{
  long unsigned int default_dump_filter.29;
  long unsigned int _4;
  long unsigned int _5;

  <bb 2>:
  _4 = simple_strtoul (s_2(D), 0B, 0);
  _5 = _4 << 2;
  default_dump_filter.29_6 = _5 & 508;
  default_dump_filter = default_dump_filter.29_6;
  return 1;

}



;; Function copy_sighand (copy_sighand, funcdef_no=3646, decl_uid=50894, cgraph_uid=3646) (unlikely executed)

copy_sighand (long unsigned int clone_flags, struct task_struct * tsk)
{
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct sighand_struct * sig;
  struct kmem_cache * sighand_cachep.54;
  int _1;
  long unsigned int _4;
  struct sighand_struct * _6;
  struct atomic_t * _7;
  long long unsigned int _15;
  struct sighand_struct * _17;
  struct k_sigaction[64] * _18;
  struct k_sigaction[64] * _19;

  <bb 2>:
  _4 = clone_flags_3(D) & 2048;
  if (_4 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___21 : "p" &current_task);
  _6 = pfo_ret___21->sighand;
  _7 = &_6->count;
  __asm__ __volatile__(".pushsection .smp_locks,"a"
.balign 4
.long 671f - .
.popsection
671:
	lock; incl %0" : "=m" _7->counter : "m" _7->counter);
  goto <bb 6>;

  <bb 4>:
  sighand_cachep.54_9 = sighand_cachep;
  sig_11 = kmem_cache_alloc (sighand_cachep.54_9, 208);
  __asm__ __volatile__("" :  :  : "memory");
  _15 = (long long unsigned int) sig_11;
  MEM[(volatile __u64 *)tsk_13(D) + 1536B] ={v} _15;
  if (sig_11 == 0B)
    goto <bb 6>;
  else
    goto <bb 5>;

  <bb 5>:
  MEM[(struct atomic_t *)sig_11].counter = 1;
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___24 : "p" &current_task);
  _17 = pfo_ret___24->sighand;
  _18 = &_17->action;
  _19 = &sig_11->action;
  memcpy (_19, _18, 2048);

  <bb 6>:
  # _1 = PHI <0(3), -12(4), 0(5)>
  return _1;

}



;; Function copy_files (copy_files, funcdef_no=3644, decl_uid=50880, cgraph_uid=3644)

copy_files (long unsigned int clone_flags, struct task_struct * tsk)
{
  struct task_struct * pfo_ret__;
  int error;
  struct files_struct * newf;
  struct files_struct * oldf;
  long unsigned int _6;
  struct atomic_t * _7;
  int pretmp_18;
  int pretmp_19;
  int prephitmp_20;

  <bb 2>:
  error = 0;
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___16 : "p" &current_task);
  oldf_4 = pfo_ret___16->files;
  if (oldf_4 == 0B)
    goto <bb 8> (out);
  else
    goto <bb 3>;

  <bb 3>:
  _6 = clone_flags_5(D) & 1024;
  if (_6 != 0)
    goto <bb 4>;
  else
    goto <bb 5>;

  <bb 4>:
  _7 = &oldf_4->count;
  __asm__ __volatile__(".pushsection .smp_locks,"a"
.balign 4
.long 671f - .
.popsection
671:
	lock; incl %0" : "=m" _7->counter : "m" _7->counter);
  pretmp_19 = error;
  goto <bb 8> (out);

  <bb 5>:
  newf_10 = dup_fd (oldf_4, &error);
  if (newf_10 == 0B)
    goto <bb 6>;
  else
    goto <bb 7>;

  <bb 6>:
  pretmp_18 = error;
  goto <bb 8> (out);

  <bb 7>:
  tsk_11(D)->files = newf_10;

  # prephitmp_20 = PHI <0(2), pretmp_19(4), pretmp_18(6), 0(7)>
out:
  error ={v} {CLOBBER};
  return prephitmp_20;

}



;; Function unshare_fd (unshare_fd, funcdef_no=3669, decl_uid=51146, cgraph_uid=3671)

unshare_fd (long unsigned int unshare_flags, struct files_struct * * new_fdp)
{
  struct task_struct * pfo_ret__;
  int error;
  struct files_struct * fd;
  int _1;
  long unsigned int _7;
  struct files_struct * _10;
  int _13;
  int _16;

  <bb 2>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___15 : "p" &current_task);
  fd_4 = pfo_ret___15->files;
  error = 0;
  _7 = unshare_flags_6(D) & 1024;
  if (_7 != 0)
    goto <bb 4>;
  else
    goto <bb 3>;

  <bb 3>:
  goto <bb 8>;

  <bb 4>:
  if (fd_4 != 0B)
    goto <bb 5>;
  else
    goto <bb 3>;

  <bb 5>:
  _16 ={v} MEM[(const int *)fd_4];
  if (_16 > 1)
    goto <bb 6>;
  else
    goto <bb 3>;

  <bb 6>:
  _10 = dup_fd (fd_4, &error);
  *new_fdp_11(D) = _10;
  if (_10 == 0B)
    goto <bb 7>;
  else
    goto <bb 3>;

  <bb 7>:
  _13 = error;

  <bb 8>:
  # _1 = PHI <_13(7), 0(3)>
  error ={v} {CLOBBER};
  return _1;

}



;; Function sighand_ctor (sighand_ctor, funcdef_no=3665, decl_uid=51128, cgraph_uid=3667)

sighand_ctor (void * data)
{
  static struct lock_class_key __key;
  struct wait_queue_head_t * _4;

  <bb 2>:
  MEM[(struct sighand_struct *)data_1(D)].siglock.D.5408.rlock.raw_lock.val.counter = 0;
  _4 = &MEM[(struct sighand_struct *)data_1(D)].signalfd_wqh;
  __init_waitqueue_head (_4, "&sighand->signalfd_wqh", &__key);
  return;

}



;; Function copy_io (copy_io, funcdef_no=3645, decl_uid=50888, cgraph_uid=3645) (unlikely executed)

copy_io (long unsigned int clone_flags, struct task_struct * tsk)
{
  _Bool __warned.64;
  _Bool __warned.65;
  static bool __warned;
  static bool __warned;
  _Bool __warned.63;
  static bool __warned;
  struct task_struct * pfo_ret__;
  struct io_context * new_ioc;
  struct io_context * ioc;
  int _1;
  long unsigned int _6;
  short unsigned int _10;
  short unsigned int _11;
  short unsigned int _17;
  int _21;
  struct atomic_t * _29;
  long int _30;
  int _38;
  struct atomic_long_t * _46;
  struct atomic_t * _47;

  <bb 2>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___20 : "p" &current_task);
  ioc_4 = pfo_ret___20->io_context;
  if (ioc_4 == 0B)
    goto <bb 17>;
  else
    goto <bb 3>;

  <bb 3>:
  _6 = clone_flags_5(D) & 2147483648;
  if (_6 != 0)
    goto <bb 4>;
  else
    goto <bb 14>;

  <bb 4>:
  _30 ={v} MEM[(const long int *)ioc_4];
  if (_30 <= 0)
    goto <bb 5>;
  else
    goto <bb 7>;

  <bb 5>:
  __warned.64_34 = __warned;
  if (__warned.64_34 != 0)
    goto <bb 7>;
  else
    goto <bb 6>;

  <bb 6>:
  warn_slowpath_null ("include/linux/iocontext.h", 130);
  __warned = 1;

  <bb 7>:
  _38 ={v} MEM[(const int *)ioc_4 + 8B];
  if (_38 <= 0)
    goto <bb 8>;
  else
    goto <bb 10>;

  <bb 8>:
  __warned.65_42 = __warned;
  if (__warned.65_42 != 0)
    goto <bb 10>;
  else
    goto <bb 9>;

  <bb 9>:
  warn_slowpath_null ("include/linux/iocontext.h", 131);
  __warned = 1;

  <bb 10>:
  _46 = &ioc_4->refcount;
  __asm__ __volatile__(".pushsection .smp_locks,"a"
.balign 4
.long 671f - .
.popsection
671:
	lock; incq %0" : "=m" MEM[(struct atomic64_t *)_46].counter : "m" MEM[(struct atomic64_t *)_46].counter);
  _47 = &ioc_4->active_ref;
  __asm__ __volatile__(".pushsection .smp_locks,"a"
.balign 4
.long 671f - .
.popsection
671:
	lock; incl %0" : "=m" _47->counter : "m" _47->counter);
  _21 ={v} MEM[(const int *)ioc_4 + 12B];
  if (_21 <= 0)
    goto <bb 11>;
  else
    goto <bb 13>;

  <bb 11>:
  __warned.63_25 = __warned;
  if (__warned.63_25 != 0)
    goto <bb 13>;
  else
    goto <bb 12>;

  <bb 12>:
  warn_slowpath_null ("include/linux/iocontext.h", 140);
  __warned = 1;

  <bb 13>:
  _29 = &ioc_4->nr_tasks;
  __asm__ __volatile__(".pushsection .smp_locks,"a"
.balign 4
.long 671f - .
.popsection
671:
	lock; incl %0" : "=m" _29->counter : "m" _29->counter);
  tsk_8(D)->io_context = ioc_4;
  goto <bb 17>;

  <bb 14>:
  _10 = ioc_4->ioprio;
  _11 = _10 >> 13;
  if (_11 != 0)
    goto <bb 15>;
  else
    goto <bb 17>;

  <bb 15>:
  new_ioc_13 = get_task_io_context (tsk_8(D), 208, -1);
  if (new_ioc_13 == 0B)
    goto <bb 17>;
  else
    goto <bb 16>;

  <bb 16>:
  _17 = ioc_4->ioprio;
  new_ioc_13->ioprio = _17;
  put_io_context (new_ioc_13);

  <bb 17>:
  # _1 = PHI <0(14), -12(15), 0(16), 0(13), 0(2)>
  return _1;

}



;; Function copy_seccomp (copy_seccomp, funcdef_no=3650, decl_uid=50930, cgraph_uid=3650) (unlikely executed)

copy_seccomp (struct task_struct * p)
{
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct sighand_struct * _4;
  int _14;
  int _17;
  long unsigned int _21;
  long unsigned int _22;
  volatile long int * _23;
  void * _24;

  <bb 2>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___16 : "p" &current_task);
  _4 = pfo_ret___16->sighand;
  _17 ={v} MEM[(const int *)_4 + 2056B];
  if (_17 == 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  __asm__ __volatile__("1:	ud2
.pushsection __bug_table,"a"
2:	.long 1b - 2b, %c0 - 2b
	.word %c1, 0
	.org 2b+%c2
.popsection" :  : "i" "kernel/fork.c", "i" 1176, "i" 12);
  __builtin_unreachable ();

  <bb 4>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___18 : "p" &current_task);
  get_seccomp_filter (pfo_ret___18);
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___19 : "p" &current_task);
  p_10(D)->seccomp = pfo_ret___19->seccomp;
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___20 : "p" &current_task);
  _21 ={v} MEM[(const long unsigned int *)pfo_ret___20 + 976B];
  _22 = _21 & 1;
  if (_22 != 0)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  _23 = &p_10(D)->atomic_flags;
  __asm__ __volatile__(".pushsection .smp_locks,"a"
.balign 4
.long 671f - .
.popsection
671:
	lock; orb %1,%0" : "=m" *_23 : "iq" 1, "m" *_23 : "memory");

  <bb 6>:
  _14 = p_10(D)->seccomp.mode;
  if (_14 != 0)
    goto <bb 7>;
  else
    goto <bb 8>;

  <bb 7>:
  _24 = p_10(D)->stack;
  set_ti_thread_flag (_24, 8);

  <bb 8>:
  return;

}



;; Function ptrace_init_task (ptrace_init_task, funcdef_no=2456, decl_uid=32865, cgraph_uid=2456) (unlikely executed)

ptrace_init_task (struct task_struct * child, bool ptrace)
{
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct list_head * _4;
  struct list_head * _7;
  struct task_struct * _11;
  unsigned int _16;
  unsigned int _17;
  struct task_struct * _19;
  unsigned int _21;
  unsigned int _22;
  long unsigned int _29;
  long unsigned int _30;
  void * _31;

  <bb 2>:
  _4 = &child_3(D)->ptrace_entry;
  MEM[(struct list_head *)child_3(D) + 1112B].next = _4;
  MEM[(struct list_head *)child_3(D) + 1112B].prev = _4;
  _7 = &child_3(D)->ptraced;
  MEM[(struct list_head *)child_3(D) + 1096B].next = _7;
  MEM[(struct list_head *)child_3(D) + 1096B].prev = _7;
  child_3(D)->jobctl = 0;
  child_3(D)->ptrace = 0;
  _11 = child_3(D)->real_parent;
  child_3(D)->parent = _11;
  if (ptrace_13(D) != 0)
    goto <bb 3>;
  else
    goto <bb 8>;

  <bb 3>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___26 : "p" &current_task);
  _16 = pfo_ret___26->ptrace;
  if (_16 != 0)
    goto <bb 4>;
  else
    goto <bb 8>;

  <bb 4>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___27 : "p" &current_task);
  _17 = pfo_ret___27->ptrace;
  child_3(D)->ptrace = _17;
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___28 : "p" &current_task);
  _19 = pfo_ret___28->parent;
  __ptrace_link (child_3(D), _19);
  _21 = child_3(D)->ptrace;
  _22 = _21 & 65536;
  if (_22 != 0)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  task_set_jobctl_pending (child_3(D), 524288);
  goto <bb 7>;

  <bb 6>:
  _29 = MEM[(struct sigset_t *)child_3(D) + 1584B].sig[0];
  _30 = _29 | 262144;
  MEM[(struct sigset_t *)child_3(D) + 1584B].sig[0] = _30;

  <bb 7>:
  _31 = child_3(D)->stack;
  set_ti_thread_flag (_31, 2);

  <bb 8>:
  return;

}



;; Function audit_free (audit_free, funcdef_no=2575, decl_uid=37485, cgraph_uid=2575)

audit_free (struct task_struct * task)
{
  struct audit_context * _4;

  <bb 2>:
  _4 = task_3(D)->audit_context;
  if (_4 != 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  __audit_free (task_3(D));

  <bb 4>:
  return;

}



;; Function ptrace_event_pid (ptrace_event_pid, funcdef_no=2455, decl_uid=32850, cgraph_uid=2455)

ptrace_event_pid (int event, struct pid * pid)
{
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * ________p1;
  struct pid_namespace * ns;
  long unsigned int message;
  int _11;
  long long unsigned int _18;
  unsigned int _21;
  int _22;
  int _23;
  unsigned int _24;
  unsigned int _25;
  int _30;
  int _31;
  unsigned int _33;
  unsigned int _34;

  <bb 2>:
  __asm__ __volatile__("" :  :  : "memory");
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___16 : "p" &current_task);
  _18 ={v} MEM[(volatile __u64 *)pfo_ret___16 + 1048B];
  ________p1_6 = (struct task_struct *) _18;
  ns_8 = task_active_pid_ns (________p1_6);
  if (ns_8 != 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _11 = pid_nr_ns (pid_9(D), ns_8);
  message_12 = (long unsigned int) _11;

  <bb 4>:
  # message_1 = PHI <0(2), message_12(3)>
  __asm__ __volatile__("" :  :  : "memory");
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___20 : "p" &current_task);
  _21 = pfo_ret___20->ptrace;
  _22 = event_14(D) + 3;
  _23 = 1 << _22;
  _24 = (unsigned int) _23;
  _25 = _24 & _21;
  if (_25 != 0)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___29 : "p" &current_task);
  pfo_ret___29->ptrace_message = message_1;
  _30 = event_14(D) << 8;
  _31 = _30 | 5;
  ptrace_notify (_31);
  goto <bb 9>;

  <bb 6>:
  if (event_14(D) == 4)
    goto <bb 7>;
  else
    goto <bb 9>;

  <bb 7>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___32 : "p" &current_task);
  _33 = pfo_ret___32->ptrace;
  _34 = _33 & 65537;
  if (_34 == 1)
    goto <bb 8>;
  else
    goto <bb 9>;

  <bb 8>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___35 : "p" &current_task);
  send_sig (5, pfo_ret___35, 0);

  <bb 9>:
  return;

}



;; Function trace_event_define_fields_task_newtask (trace_event_define_fields_task_newtask, funcdef_no=3185, decl_uid=45596, cgraph_uid=3185) (unlikely executed)

trace_event_define_fields_task_newtask (struct trace_event_call * event_call)
{
  int ret;
  int ret;
  int _1;

  <bb 2>:
  ret_6 = trace_define_field (event_call_4(D), "pid_t", "pid", 8, 4, 1, 0);
  if (ret_6 != 0)
    goto <bb 6>;
  else
    goto <bb 3>;

  <bb 3>:
  ret_8 = trace_define_field (event_call_4(D), "char[16]", "comm", 12, 16, 1, 0);
  if (ret_8 != 0)
    goto <bb 6>;
  else
    goto <bb 4>;

  <bb 4>:
  ret_10 = trace_define_field (event_call_4(D), "unsigned long", "clone_flags", 32, 8, 0, 0);
  if (ret_10 != 0)
    goto <bb 6>;
  else
    goto <bb 5>;

  <bb 5>:
  ret_13 = trace_define_field (event_call_4(D), "short", "oom_score_adj", 40, 2, 1, 0);

  <bb 6>:
  # _1 = PHI <ret_6(2), ret_8(3), ret_10(4), ret_13(5)>
  return _1;

}



;; Function trace_event_define_fields_task_rename (trace_event_define_fields_task_rename, funcdef_no=3186, decl_uid=45606, cgraph_uid=3186) (unlikely executed)

trace_event_define_fields_task_rename (struct trace_event_call * event_call)
{
  int ret;
  int ret;
  int _1;

  <bb 2>:
  ret_6 = trace_define_field (event_call_4(D), "pid_t", "pid", 8, 4, 1, 0);
  if (ret_6 != 0)
    goto <bb 6>;
  else
    goto <bb 3>;

  <bb 3>:
  ret_8 = trace_define_field (event_call_4(D), "char[16]", "oldcomm", 12, 16, 1, 0);
  if (ret_8 != 0)
    goto <bb 6>;
  else
    goto <bb 4>;

  <bb 4>:
  ret_10 = trace_define_field (event_call_4(D), "char[16]", "newcomm", 28, 16, 1, 0);
  if (ret_10 != 0)
    goto <bb 6>;
  else
    goto <bb 5>;

  <bb 5>:
  ret_13 = trace_define_field (event_call_4(D), "short", "oom_score_adj", 44, 2, 1, 0);

  <bb 6>:
  # _1 = PHI <ret_6(2), ret_8(3), ret_10(4), ret_13(5)>
  return _1;

}



;; Function __mmdrop (__mmdrop, funcdef_no=3632, decl_uid=24854, cgraph_uid=3632)

__mmdrop (struct mm_struct * mm)
{
  unsigned long ivtmp.461;
  int i;
  struct kmem_cache * mm_cachep.33;
  struct atomic_long_t * _4;
  struct pgd_t * _11;
  struct atomic_long_t * _14;
  long int _15;
  long int _20;
  long int _21;
  long int _22;
  long int _23;
  long unsigned int _24;

  <bb 2>:
  if (mm_1(D) == &init_mm)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  __asm__ __volatile__("1:	ud2
.pushsection __bug_table,"a"
2:	.long 1b - 2b, %c0 - 2b
	.word %c1, 0
	.org 2b+%c2
.popsection" :  : "i" "kernel/fork.c", "i" 680, "i" 12);
  __builtin_unreachable ();

  <bb 4>:
  _11 = mm_1(D)->pgd;
  pgd_free (mm_1(D), _11);
  destroy_context (mm_1(D));
  _4 = mm_1(D) + 688;
  ivtmp.461_3 = (unsigned long) _4;

  <bb 5>:
  # i_16 = PHI <i_19(8), 0(4)>
  # ivtmp.461_17 = PHI <ivtmp.461_26(8), ivtmp.461_3(4)>
  _14 = (struct atomic_long_t *) ivtmp.461_17;
  _15 ={v} MEM[(const long int *)_14];
  if (_15 != 0)
    goto <bb 6>;
  else
    goto <bb 7>;

  <bb 6>:
  printk ("\11BUG: Bad rss-counter state mm:%p idx:%d val:%ld\n", mm_1(D), i_16, _15);

  <bb 7>:
  i_19 = i_16 + 1;
  ivtmp.461_26 = ivtmp.461_17 + 8;
  if (i_19 != 3)
    goto <bb 8>;
  else
    goto <bb 9>;

  <bb 8>:
  goto <bb 5>;

  <bb 9>:
  _20 ={v} MEM[(const long int *)mm_1(D) + 80B];
  if (_20 != 0)
    goto <bb 10>;
  else
    goto <bb 11>;

  <bb 10>:
  _21 ={v} MEM[(const long int *)mm_1(D) + 80B];
  printk ("\11BUG: non-zero nr_ptes on freeing mm: %ld\n", _21);

  <bb 11>:
  _22 ={v} MEM[(const long int *)mm_1(D) + 88B];
  if (_22 != 0)
    goto <bb 12>;
  else
    goto <bb 13>;

  <bb 12>:
  _23 ={v} MEM[(const long int *)mm_1(D) + 88B];
  _24 = (long unsigned int) _23;
  printk ("\11BUG: non-zero nr_pmds on freeing mm: %ld\n", _24);

  <bb 13>:
  mm_cachep.33_9 = mm_cachep;
  kmem_cache_free (mm_cachep.33_9, mm_1(D));
  return;

}



;; Function mm_init (mm_init, funcdef_no=3629, decl_uid=50742, cgraph_uid=3629)

mm_init (struct mm_struct * mm, struct task_struct * p)
{
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  static struct lock_class_key __key;
  struct kmem_cache * mm_cachep.32;
  long unsigned int default_dump_filter.31;
  struct mm_struct * _1;
  struct rw_semaphore * _12;
  struct list_head * _14;
  struct mm_rss_stat * _22;
  struct mm_struct * _28;
  struct mm_struct * _29;
  long unsigned int _30;
  long unsigned int _31;
  struct mm_struct * _33;
  long unsigned int _34;
  long unsigned int _35;
  int _43;
  struct pgd_t * _51;
  struct pgd_t * _56;

  <bb 2>:
  mm_6(D)->mmap = 0B;
  mm_6(D)->mm_rb.rb_node = 0B;
  mm_6(D)->vmacache_seqnum = 0;
  MEM[(struct atomic_t *)mm_6(D) + 72B].counter = 1;
  MEM[(struct atomic_t *)mm_6(D) + 76B].counter = 1;
  _12 = &mm_6(D)->mmap_sem;
  __init_rwsem (_12, "&mm->mmap_sem", &__key);
  _14 = &mm_6(D)->mmlist;
  MEM[(struct list_head *)mm_6(D) + 144B].next = _14;
  MEM[(struct list_head *)mm_6(D) + 144B].prev = _14;
  mm_6(D)->core_state = 0B;
  MEM[(struct atomic64_t *)mm_6(D) + 80B].counter = 0;
  MEM[(struct atomic64_t *)mm_6(D) + 88B].counter = 0;
  mm_6(D)->map_count = 0;
  mm_6(D)->locked_vm = 0;
  mm_6(D)->pinned_vm = 0;
  _22 = &mm_6(D)->rss_stat;
  memset (_22, 0, 24);
  mm_6(D)->page_table_lock.D.5408.rlock.raw_lock.val.counter = 0;
  MEM[(long unsigned int *)mm_6(D) + 720B] = 0;
  MEM[(int *)mm_6(D) + 816B] = 0;
  MEM[(struct kioctx_table * *)mm_6(D) + 824B] = 0B;
  __asm__ __volatile__("" :  :  : "memory");
  MEM[(bool *)mm_6(D) + 840B] = 0;
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___48 : "p" &current_task);
  _28 = pfo_ret___48->mm;
  if (_28 != 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___49 : "p" &current_task);
  _29 = pfo_ret___49->mm;
  _30 = _29->flags;
  _31 = _30 & 511;
  mm_6(D)->flags = _31;
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___50 : "p" &current_task);
  _33 = pfo_ret___50->mm;
  _34 = _33->def_flags;
  _35 = _34 & 1073741824;
  mm_6(D)->def_flags = _35;
  goto <bb 5>;

  <bb 4>:
  default_dump_filter.31_37 = default_dump_filter;
  mm_6(D)->flags = default_dump_filter.31_37;
  mm_6(D)->def_flags = 0;

  <bb 5>:
  _51 = pgd_alloc (mm_6(D));
  mm_6(D)->pgd = _51;
  if (_51 == 0B)
    goto <bb 7> (fail_nopgd);
  else
    goto <bb 9>;

fail_nocontext:
  _56 = mm_6(D)->pgd;
  pgd_free (mm_6(D), _56);

fail_nopgd:
  mm_cachep.32_45 = mm_cachep;
  kmem_cache_free (mm_cachep.32_45, mm_6(D));

  <bb 8>:
  # _1 = PHI <mm_6(D)(9), 0B(7)>
  return _1;

  <bb 9>:
  _43 = init_new_context (p_41(D), mm_6(D));
  if (_43 != 0)
    goto <bb 6> (fail_nocontext);
  else
    goto <bb 8>;

}



;; Function get_task_mm (get_task_mm, funcdef_no=3636, decl_uid=24861, cgraph_uid=3636)

get_task_mm (struct task_struct * task)
{
  struct mm_struct * mm;
  unsigned int _7;
  unsigned int _8;
  struct atomic_t * _9;
  struct raw_spinlock * _12;

  <bb 2>:
  _12 = &MEM[(struct spinlock_t *)task_4(D) + 1680B].D.5408.rlock;
  _raw_spin_lock (_12);
  mm_6 = task_4(D)->mm;
  if (mm_6 != 0B)
    goto <bb 3>;
  else
    goto <bb 5>;

  <bb 3>:
  _7 = task_4(D)->flags;
  _8 = _7 & 2097152;
  if (_8 != 0)
    goto <bb 5>;
  else
    goto <bb 4>;

  <bb 4>:
  _9 = &mm_6->mm_users;
  __asm__ __volatile__(".pushsection .smp_locks,"a"
.balign 4
.long 671f - .
.popsection
671:
	lock; incl %0" : "=m" _9->counter : "m" _9->counter);

  <bb 5>:
  # mm_1 = PHI <0B(3), mm_6(4), mm_6(2)>
  __asm__ __volatile__("" :  :  : "memory");
  MEM[(volatile __u8 *)task_4(D) + 1680B] ={v} 0;
  __asm__ __volatile__("" :  :  : "memory");
  return mm_1;

}



;; Function copy_fs (copy_fs, funcdef_no=3643, decl_uid=50875, cgraph_uid=3643)

copy_fs (long unsigned int clone_flags, struct task_struct * tsk)
{
  struct task_struct * pfo_ret__;
  struct fs_struct * fs;
  int _1;
  long unsigned int _6;
  int _8;
  int _10;
  int _11;
  struct fs_struct * _15;
  struct raw_spinlock * _19;

  <bb 2>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___18 : "p" &current_task);
  fs_4 = pfo_ret___18->fs;
  _6 = clone_flags_5(D) & 512;
  if (_6 != 0)
    goto <bb 3>;
  else
    goto <bb 6>;

  <bb 3>:
  _19 = &MEM[(struct spinlock_t *)fs_4 + 4B].D.5408.rlock;
  _raw_spin_lock (_19);
  _8 = fs_4->in_exec;
  if (_8 != 0)
    goto <bb 4>;
  else
    goto <bb 5>;

  <bb 4>:
  __asm__ __volatile__("" :  :  : "memory");
  MEM[(volatile __u8 *)fs_4 + 4B] ={v} 0;
  __asm__ __volatile__("" :  :  : "memory");
  goto <bb 8>;

  <bb 5>:
  _10 = fs_4->users;
  _11 = _10 + 1;
  fs_4->users = _11;
  __asm__ __volatile__("" :  :  : "memory");
  MEM[(volatile __u8 *)fs_4 + 4B] ={v} 0;
  __asm__ __volatile__("" :  :  : "memory");
  goto <bb 8>;

  <bb 6>:
  _15 = copy_fs_struct (fs_4);
  tsk_16(D)->fs = _15;
  if (_15 == 0B)
    goto <bb 7>;
  else
    goto <bb 8>;

  <bb 7>:

  <bb 8>:
  # _1 = PHI <-11(4), _8(5), -12(7), 0(6)>
  return _1;

}



;; Function copy_signal (copy_signal, funcdef_no=3649, decl_uid=50920, cgraph_uid=3649) (unlikely executed)

copy_signal (long unsigned int clone_flags, struct task_struct * tsk)
{
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  static struct lock_class_key __key;
  static struct lock_class_key __key;
  static struct lock_class_key __key;
  int iftmp.56;
  struct kmem_cache * signal_cachep.55;
  int _1;
  long unsigned int _5;
  struct list_head * _14;
  struct list_head * _17;
  struct wait_queue_head_t * _20;
  struct list_head * _24;
  struct hrtimer * _29;
  struct task_struct * _32;
  struct signal_struct * _34;
  struct rlimit[16] * _35;
  struct rlimit[16] * _36;
  struct task_struct * _38;
  struct rw_semaphore * _42;
  struct signal_struct * _44;
  short int _45;
  struct signal_struct * _47;
  short int _48;
  struct signal_struct * _50;
  unsigned char _51;
  unsigned char _52;
  struct signal_struct * _53;
  unsigned char _54;
  unsigned char _55;
  <unnamed-unsigned:1> _57;
  struct mutex * _59;
  void * _61;
  struct list_head * _62;
  struct raw_spinlock * _64;
  long long unsigned int _68;
  long unsigned int _69;
  struct list_head * _70;
  struct list_head * _71;
  struct list_head * _72;
  int _103;

  <bb 2>:
  _5 = clone_flags_4(D) & 65536;
  if (_5 != 0)
    goto <bb 9>;
  else
    goto <bb 3>;

  <bb 3>:
  signal_cachep.55_7 = signal_cachep;
  _61 = kmem_cache_alloc (signal_cachep.55_7, 32976);
  tsk_9(D)->signal = _61;
  if (_61 == 0B)
    goto <bb 9>;
  else
    goto <bb 4>;

  <bb 4>:
  MEM[(struct signal_struct *)_61].nr_threads = 1;
  MEM[(struct atomic_t *)_61 + 4B].counter = 1;
  MEM[(struct atomic_t *)_61].counter = 1;
  _14 = &tsk_9(D)->thread_node;
  MEM[(struct signal_struct *)_61].thread_head.next = _14;
  MEM[(struct signal_struct *)_61].thread_head.prev = _14;
  _17 = &MEM[(struct signal_struct *)_61].thread_head;
  tsk_9(D)->thread_node.next = _17;
  tsk_9(D)->thread_node.prev = _17;
  _20 = &MEM[(struct signal_struct *)_61].wait_chldexit;
  __init_waitqueue_head (_20, "&sig->wait_chldexit", &__key);
  MEM[(struct signal_struct *)_61].curr_target = tsk_9(D);
  MEM[(struct sigset_t *)_61 + 80B].sig[0] = 0;
  _62 = &MEM[(struct sigpending *)_61 + 64B].list;
  MEM[(struct list_head *)_61 + 64B].next = _62;
  MEM[(struct list_head *)_61 + 64B].prev = _62;
  _24 = &MEM[(struct signal_struct *)_61].posix_timers;
  MEM[(struct list_head *)_61 + 120B].next = _24;
  MEM[(struct list_head *)_61 + 120B].prev = _24;
  MEM[(struct seqcount_t *)_61 + 424B].sequence = 0;
  MEM[(struct signal_struct *)_61].stats_lock.lock.D.5408.rlock.raw_lock.val.counter = 0;
  MEM[(struct prev_cputime *)_61 + 480B].stime = 0;
  MEM[(struct prev_cputime *)_61 + 480B].utime = 0;
  MEM[(struct prev_cputime *)_61 + 480B].lock.raw_lock.val.counter = 0;
  _29 = &MEM[(struct signal_struct *)_61].real_timer;
  hrtimer_init (_29, 1, 1);
  MEM[(struct signal_struct *)_61].real_timer.function = it_real_fn;
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___63 : "p" &current_task);
  _32 = pfo_ret___63->group_leader;
  _64 = &MEM[(struct spinlock_t *)_32 + 1680B].D.5408.rlock;
  _raw_spin_lock (_64);
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___65 : "p" &current_task);
  _34 = pfo_ret___65->signal;
  _35 = &_34->rlim;
  _36 = &MEM[(struct signal_struct *)_61].rlim;
  memcpy (_36, _35, 256);
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___66 : "p" &current_task);
  _38 = pfo_ret___66->group_leader;
  __asm__ __volatile__("" :  :  : "memory");
  MEM[(volatile __u8 *)_38 + 1680B] ={v} 0;
  __asm__ __volatile__("" :  :  : "memory");
  _68 ={v} MEM[(volatile __u64 *)_61 + 680B];
  if (_68 != 18446744073709551615)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  _69 = _68 * 1000;
  MEM[(struct signal_struct *)_61].cputime_expires.stime = _69;
  MEM[(struct signal_struct *)_61].cputimer.running = 1;

  <bb 6>:
  _70 = &MEM[(struct signal_struct *)_61].cpu_timers[0];
  MEM[(struct list_head *)_61 + 352B].next = _70;
  MEM[(struct list_head *)_61 + 352B].prev = _70;
  _71 = &MEM[(struct signal_struct *)_61].cpu_timers[1];
  MEM[(struct list_head *)_61 + 368B].next = _71;
  MEM[(struct list_head *)_61 + 368B].prev = _71;
  _72 = &MEM[(struct signal_struct *)_61].cpu_timers[2];
  MEM[(struct list_head *)_61 + 384B].next = _72;
  MEM[(struct list_head *)_61 + 384B].prev = _72;
  tty_audit_fork (_61);
  _42 = &MEM[(struct signal_struct *)_61].group_rwsem;
  __init_rwsem (_42, "&sig->group_rwsem", &__key);
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___73 : "p" &current_task);
  _44 = pfo_ret___73->signal;
  _45 = _44->oom_score_adj;
  MEM[(struct signal_struct *)_61].oom_score_adj = _45;
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___74 : "p" &current_task);
  _47 = pfo_ret___74->signal;
  _48 = _47->oom_score_adj_min;
  MEM[(struct signal_struct *)_61].oom_score_adj_min = _48;
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___75 : "p" &current_task);
  _50 = pfo_ret___75->signal;
  _51 = BIT_FIELD_REF <*_50, 8, 896>;
  _52 = _51 & 2;
  if (_52 != 0)
    goto <bb 8>;
  else
    goto <bb 7>;

  <bb 7>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___76 : "p" &current_task);
  _53 = pfo_ret___76->signal;
  _54 = BIT_FIELD_REF <*_53, 8, 896>;
  _55 = _54 & 1;
  _103 = (int) _55;

  <bb 8>:
  # iftmp.56_2 = PHI <_103(7), 1(6)>
  _57 = (<unnamed-unsigned:1>) iftmp.56_2;
  MEM[(struct signal_struct *)_61].has_child_subreaper = _57;
  _59 = &MEM[(struct signal_struct *)_61].cred_guard_mutex;
  __mutex_init (_59, "&sig->cred_guard_mutex", &__key);

  <bb 9>:
  # _1 = PHI <0(2), -12(3), 0(8)>
  return _1;

}



;; Function perf_trace_task_newtask (perf_trace_task_newtask, funcdef_no=3193, decl_uid=45665, cgraph_uid=3193)

perf_trace_task_newtask (void * __data, struct task_struct * task, long unsigned int clone_flags)
{
  struct stack_frame * frame;
  long unsigned int tcp_ptr__;
  int rctx;
  struct pt_regs * __regs;
  struct trace_event_raw_task_newtask * entry;
  int rctx.4;
  struct pt_regs * __regs.3;
  struct hlist_head * _5;
  struct hlist_head * _7;
  int _8;
  int _9;
  int _15;
  char[16] * _17;
  char[16] * _18;
  struct signal_struct * _22;
  short int _23;
  struct hlist_node * _30;
  void * _34;
  long unsigned int _35;
  long unsigned int _38;

  <bb 2>:
  _5 = MEM[(struct trace_event_call *)__data_3(D)].perf_events;
  __asm__ __volatile__("add %%gs:%1, %0" : "=r" tcp_ptr___6 : "m" this_cpu_off, "0" _5);
  _7 = (struct hlist_head *) tcp_ptr___6;
  _30 = MEM[(const struct hlist_head *)_7].first;
  if (_30 == 0B)
    goto <bb 5>;
  else
    goto <bb 3>;

  <bb 3>:
  _8 = MEM[(struct trace_event_call *)__data_3(D)].event.type;
  _9 = _8 & 65535;
  entry_11 = perf_trace_buf_prepare (52, _9, &__regs, &rctx);
  if (entry_11 == 0B)
    goto <bb 5>;
  else
    goto <bb 4>;

  <bb 4>:
  __regs.3_12 = __regs;
  memset (__regs.3_12, 0, 168);
  _34 = __builtin_return_address (0);
  _35 = (long unsigned int) _34;
  __regs.3_12->ip = _35;
  __asm__("movq %%rbp, %0" : "=r" frame_36);
  frame_37 = frame_36->next_frame;
  _38 = (long unsigned int) frame_37;
  __regs.3_12->bp = _38;
  __regs.3_12->cs = 16;
  __regs.3_12->flags = 0;
  __asm__ __volatile__(" movq %%rsp, %0
" : "=m" __regs.3_12->sp :  : "memory");
  _15 = task_14(D)->pid;
  entry_11->pid = _15;
  _17 = &task_14(D)->comm;
  _18 = &entry_11->comm;
  memcpy (_18, _17, 16);
  entry_11->clone_flags = clone_flags_20(D);
  _22 = task_14(D)->signal;
  _23 = _22->oom_score_adj;
  entry_11->oom_score_adj = _23;
  __regs.3_25 = __regs;
  rctx.4_26 = rctx;
  perf_tp_event (0, 1, entry_11, 52, __regs.3_25, _7, rctx.4_26, 0B);
  __regs ={v} {CLOBBER};
  rctx ={v} {CLOBBER};
  goto <bb 6>;

  <bb 5>:
  __regs ={v} {CLOBBER};
  rctx ={v} {CLOBBER};

  <bb 6>:
  return;

}



;; Function trace_event_raw_event_task_newtask (trace_event_raw_event_task_newtask, funcdef_no=3189, decl_uid=45639, cgraph_uid=3189)

trace_event_raw_event_task_newtask (void * __data, struct task_struct * task, long unsigned int clone_flags)
{
  long unsigned int eflags;
  struct trace_event_raw_task_newtask * entry;
  struct trace_event_buffer fbuffer;
  int _10;
  char[16] * _12;
  char[16] * _13;
  struct signal_struct * _17;
  short int _18;
  long unsigned int _24;
  long unsigned int _25;
  long unsigned int _26;

  <bb 2>:
  eflags_23 = MEM[(struct trace_event_file *)__data_3(D)].flags;
  _24 = eflags_23 & 128;
  if (_24 == 0)
    goto <bb 3>;
  else
    goto <bb 9>;

  <bb 3>:
  _25 = eflags_23 & 64;
  if (_25 != 0)
    goto <bb 4>;
  else
    goto <bb 5>;

  <bb 4>:
  event_triggers_call (__data_3(D), 0B);

  <bb 5>:
  _26 = eflags_23 & 32;
  if (_26 != 0)
    goto <bb 7>;
  else
    goto <bb 9>;

  <bb 6>:
  _10 = task_9(D)->pid;
  entry_8->pid = _10;
  _12 = &task_9(D)->comm;
  _13 = &entry_8->comm;
  memcpy (_13, _12, 16);
  entry_8->clone_flags = clone_flags_15(D);
  _17 = task_9(D)->signal;
  _18 = _17->oom_score_adj;
  entry_8->oom_score_adj = _18;
  trace_event_buffer_commit (&fbuffer);
  fbuffer ={v} {CLOBBER};
  goto <bb 8>;

  <bb 7>:
  fbuffer ={v} {CLOBBER};

  <bb 8>:
  return;

  <bb 9>:
  entry_8 = trace_event_buffer_reserve (&fbuffer, __data_3(D), 48);
  if (entry_8 == 0B)
    goto <bb 7>;
  else
    goto <bb 6>;

}



;; Function nr_processes (nr_processes, funcdef_no=3197, decl_uid=23775, cgraph_uid=3197)

nr_processes ()
{
  long unsigned int __ptr;
  int total;
  int cpu;
  int nr_cpu_ids.14;
  unsigned int total.12;
  long unsigned int _10;
  long unsigned int _11;
  long unsigned int * _12;
  long unsigned int _13;
  unsigned int _14;
  unsigned int _16;
  int _18;
  long unsigned int _19;
  long unsigned int _21;
  const struct cpumask * const pretmp_24;
  const long unsigned int[1] * pretmp_28;

  <bb 2>:
  pretmp_24 = cpu_possible_mask;
  pretmp_28 = &pretmp_24->bits;
  goto <bb 4>;

  <bb 3>:
  __asm__("" : "=r" __ptr_9 : "0" &process_counts);
  _10 = __per_cpu_offset[cpu_7];
  _11 = __ptr_9 + _10;
  _12 = (long unsigned int *) _11;
  _13 = *_12;
  _14 = (unsigned int) _13;
  total.12_15 = (unsigned int) total_2;
  _16 = _14 + total.12_15;
  total_17 = (int) _16;

  <bb 4>:
  # cpu_1 = PHI <-1(2), cpu_7(3)>
  # total_2 = PHI <0(2), total_17(3)>
  _18 = cpu_1 + 1;
  _19 = (long unsigned int) _18;
  _21 = find_next_bit (pretmp_28, 64, _19);
  cpu_7 = (int) _21;
  nr_cpu_ids.14_8 = nr_cpu_ids;
  if (cpu_7 < nr_cpu_ids.14_8)
    goto <bb 3>;
  else
    goto <bb 5>;

  <bb 5>:
  # total_22 = PHI <total_2(4)>
  return total_22;

}



;; Function arch_release_task_struct (arch_release_task_struct, funcdef_no=3198, decl_uid=5237, cgraph_uid=3198)

arch_release_task_struct (struct task_struct * tsk)
{
  <bb 2>:
  return;

}



;; Function arch_release_thread_info (arch_release_thread_info, funcdef_no=3201, decl_uid=45753, cgraph_uid=3201)

arch_release_thread_info (struct thread_info * ti)
{
  <bb 2>:
  return;

}



;; Function free_task (free_task, funcdef_no=3205, decl_uid=24505, cgraph_uid=3205)

free_task (struct task_struct * tsk)
{
  struct kmem_cache * task_struct_cachep.19;
  long unsigned int ti.18;
  void * _3;
  void * _5;
  void * _7;

  <bb 2>:
  _3 = tsk_2(D)->stack;
  account_kernel_stack (_3, -1);
  _5 = tsk_2(D)->stack;
  arch_release_thread_info (_5);
  _7 = tsk_2(D)->stack;
  ti.18_12 = (long unsigned int) _7;
  free_kmem_pages (ti.18_12, 2);
  put_seccomp_filter (tsk_2(D));
  arch_release_task_struct (tsk_2(D));
  task_struct_cachep.19_13 = task_struct_cachep;
  kmem_cache_free (task_struct_cachep.19_13, tsk_2(D));
  return;

}



;; Function __put_task_struct (__put_task_struct, funcdef_no=3208, decl_uid=24507, cgraph_uid=3208)

__put_task_struct (struct task_struct * tsk)
{
  struct kmem_cache * taskstats_cache.22;
  struct kmem_cache * signal_cachep.21;
  struct kmem_cache * delayacct_cache.20;
  struct task_struct * pfo_ret__;
  int _7;
  struct signal_struct * _24;
  int _27;
  int _29;
  struct task_delay_info * _31;
  struct atomic_t * _36;
  struct taskstats * _38;

  <bb 2>:
  _7 = tsk_6(D)->exit_state;
  if (_7 == 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  warn_slowpath_null ("kernel/fork.c", 250);

  <bb 4>:
  _29 ={v} MEM[(const int *)tsk_6(D) + 16B];
  if (_29 != 0)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  warn_slowpath_null ("kernel/fork.c", 251);

  <bb 6>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___30 : "p" &current_task);
  if (tsk_6(D) == pfo_ret___30)
    goto <bb 7>;
  else
    goto <bb 8>;

  <bb 7>:
  warn_slowpath_null ("kernel/fork.c", 252);

  <bb 8>:
  security_task_free (tsk_6(D));
  exit_creds (tsk_6(D));
  _31 = tsk_6(D)->delays;
  if (_31 != 0B)
    goto <bb 9>;
  else
    goto <bb 10>;

  <bb 9>:
  delayacct_cache.20_32 = delayacct_cache;
  kmem_cache_free (delayacct_cache.20_32, _31);

  <bb 10>:
  tsk_6(D)->delays = 0B;
  _24 = tsk_6(D)->signal;
  _36 = &_24->sigcnt;
  __asm__ __volatile__ goto(".pushsection .smp_locks,"a"
.balign 4
.long 671f - .
.popsection
671:
	lock; decl %0; je %l1" :  : "m" _36->counter : "memory" : "cc_label" <L10>);

  <bb 11>:
  __asm__ __volatile__("");
  goto <bb 14>;

  <bb 12>:
  taskstats_cache.22_39 = taskstats_cache;
  kmem_cache_free (taskstats_cache.22_39, _38);

  <bb 13>:
  signal_cachep.21_40 = signal_cachep;
  kmem_cache_free (signal_cachep.21_40, _24);

  <bb 14>:
  _27 = profile_handoff_task (tsk_6(D));
  if (_27 == 0)
    goto <bb 15>;
  else
    goto <bb 16>;

  <bb 15>:
  free_task (tsk_6(D));

  <bb 16>:
  return;

<L10>:
  _38 = MEM[(struct signal_struct *)_24 + 992B];
  if (_38 != 0B)
    goto <bb 12>;
  else
    goto <bb 13>;

}



;; Function wait_for_vfork_done (wait_for_vfork_done, funcdef_no=3639, decl_uid=50839, cgraph_uid=3639)

wait_for_vfork_done (struct task_struct * child, struct completion * vfork)
{
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  int killed;
  unsigned int _14;
  unsigned int _15;
  struct raw_spinlock * _16;
  unsigned int _21;
  unsigned int _22;
  int _25;
  bool _29;
  struct atomic_t * _36;

  <bb 2>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___13 : "p" &current_task);
  _14 = pfo_ret___13->flags;
  _15 = _14 | 1073741824;
  pfo_ret___13->flags = _15;
  killed_6 = wait_for_completion_killable (vfork_4(D));
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___20 : "p" &current_task);
  _21 = pfo_ret___20->flags;
  _22 = _21 & 3221225471;
  pfo_ret___20->flags = _22;
  __asm__ __volatile__("mfence" :  :  : "memory");
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___23 : "p" &current_task);
  _cond_resched ();
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___24 : "p" &current_task);
  _25 ={v} MEM[(const int *)&system_freezing_cnt];
  if (_25 == 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  goto <bb 6>;

  <bb 4>:
  _29 = freezing_slow_path (pfo_ret___24);
  if (_29 != 0)
    goto <bb 5>;
  else
    goto <bb 3>;

  <bb 5>:
  __refrigerator (0);

  <bb 6>:
  if (killed_6 != 0)
    goto <bb 7>;
  else
    goto <bb 8>;

  <bb 7>:
  _16 = &MEM[(struct spinlock_t *)child_8(D) + 1680B].D.5408.rlock;
  _raw_spin_lock (_16);
  child_8(D)->vfork_done = 0B;
  __asm__ __volatile__("" :  :  : "memory");
  MEM[(volatile __u8 *)child_8(D) + 1680B] ={v} 0;
  __asm__ __volatile__("" :  :  : "memory");

  <bb 8>:
  _36 = &child_8(D)->usage;
  __asm__ __volatile__ goto(".pushsection .smp_locks,"a"
.balign 4
.long 671f - .
.popsection
671:
	lock; decl %0; je %l1" :  : "m" _36->counter : "memory" : "cc_label" <L5>);

  <bb 9>:
  __asm__ __volatile__("");

  <bb 10>:
  return killed_6;

<L5>:
  __put_task_struct (child_8(D));
  goto <bb 10>;

}



;; Function arch_task_cache_init (arch_task_cache_init, funcdef_no=3209, decl_uid=5232, cgraph_uid=3209) (unlikely executed)

arch_task_cache_init ()
{
  <bb 2>:
  return;

}



;; Function fork_init (fork_init, funcdef_no=3211, decl_uid=45817, cgraph_uid=3211) (unlikely executed)

fork_init ()
{
  int max_threads.25;
  struct kmem_cache * task_struct_cachep.24;
  int arch_task_struct_size.23;
  long unsigned int _3;
  struct signal_struct * _9;
  int _11;
  long unsigned int _12;
  struct signal_struct * _14;
  struct signal_struct * _16;

  <bb 2>:
  arch_task_struct_size.23_2 = arch_task_struct_size;
  _3 = (long unsigned int) arch_task_struct_size.23_2;
  task_struct_cachep.24_5 = kmem_cache_create ("task_struct", _3, 64, 262144, 0B);
  task_struct_cachep = task_struct_cachep.24_5;
  arch_task_cache_init ();
  set_max_threads (1073741823);
  _9 = init_task.signal;
  max_threads.25_10 = max_threads;
  _11 = max_threads.25_10 / 2;
  _12 = (long unsigned int) _11;
  _9->rlim[6].rlim_cur = _12;
  _14 = init_task.signal;
  _14->rlim[6].rlim_max = _12;
  _16 = init_task.signal;
  _16->rlim[11] = _16->rlim[6];
  return;

}



;; Function arch_dup_task_struct (arch_dup_task_struct, funcdef_no=3212, decl_uid=5235, cgraph_uid=3212)

arch_dup_task_struct (struct task_struct * dst, struct task_struct * src)
{
  <bb 2>:
  *dst_2(D) = *src_3(D);
  return 0;

}



;; Function dup_task_struct (dup_task_struct, funcdef_no=3214, decl_uid=45828, cgraph_uid=3214)

dup_task_struct (struct task_struct * orig)
{
  long int page.52;
  struct page * page;
  struct kmem_cache * task_struct_cachep.19;
  struct kmem_cache * task_struct_cachep.50;
  int err;
  int node;
  struct task_struct * _1;
  struct task_struct * _26;
  void * _27;
  void * _28;
  long int _39;
  long int _40;
  long long unsigned int _41;
  long long unsigned int _42;
  long unsigned int _43;
  void * _44;
  void * _47;
  void * _48;
  volatile long int * _54;

  <bb 2>:
  node_7 = tsk_fork_get_node (orig_5(D));
  task_struct_cachep.50_25 = task_struct_cachep;
  _26 = kmem_cache_alloc_node (task_struct_cachep.50_25, 208, node_7);
  if (_26 == 0B)
    goto <bb 9>;
  else
    goto <bb 3>;

  <bb 3>:
  page_37 = alloc_kmem_pages_node (node_7, 2130128, 2);
  if (page_37 != 0B)
    goto <bb 4>;
  else
    goto <bb 8> (free_tsk);

  <bb 4>:
  page.52_38 = (long int) page_37;
  _39 = page.52_38 + 24189255811072;
  _40 = _39 /[ex] 64;
  _41 = (long long unsigned int) _40;
  _42 = _41 << 12;
  _43 = _42 + 18446612132314218496;
  _44 = (void *) _43;
  if (_44 == 0B)
    goto <bb 8> (free_tsk);
  else
    goto <bb 5>;

  <bb 5>:
  err_12 = arch_dup_task_struct (_26, orig_5(D));
  if (err_12 != 0)
    goto <bb 7> (free_ti);
  else
    goto <bb 6>;

  <bb 6>:
  _26->stack = _44;
  _26->seccomp.filter = 0B;
  _47 = orig_5(D)->stack;
  MEM[(struct thread_info *)_44] = MEM[(struct thread_info *)_47];
  _48 = _26->stack;
  MEM[(struct thread_info *)_48].task = _26;
  _27 = _26->stack;
  _54 = &MEM[(struct thread_info *)_27].flags;
  __asm__ __volatile__(".pushsection .smp_locks,"a"
.balign 4
.long 671f - .
.popsection
671:
	lock; andb %1,%0" : "=m" *_54 : "iq" 247, "m" *_54);
  _28 = _26->stack;
  MEM[(long unsigned int *)_28 + 48B] = 1470918301;
  MEM[(struct atomic_t *)_26 + 16B].counter = 2;
  _26->btrace_seq = 0;
  _26->splice_pipe = 0B;
  _26->task_frag.page = 0B;
  account_kernel_stack (_44, 1);
  goto <bb 9>;

free_ti:
  free_kmem_pages (_43, 2);

free_tsk:
  task_struct_cachep.19_30 = task_struct_cachep;
  kmem_cache_free (task_struct_cachep.19_30, _26);

  <bb 9>:
  # _1 = PHI <_26(2), _26(6), 0B(8)>
  return _1;

}



;; Function set_task_stack_end_magic (set_task_stack_end_magic, funcdef_no=3213, decl_uid=25012, cgraph_uid=3213)

set_task_stack_end_magic (struct task_struct * tsk)
{
  void * _4;

  <bb 2>:
  _4 = tsk_2(D)->stack;
  MEM[(long unsigned int *)_4 + 48B] = 1470918301;
  return;

}



;; Function mm_alloc (mm_alloc, funcdef_no=3631, decl_uid=24852, cgraph_uid=3631)

mm_alloc ()
{
  struct task_struct * pfo_ret__;
  struct mm_struct * mm;
  struct kmem_cache * mm_cachep.30;
  struct mm_struct * _1;
  struct mm_struct * _9;

  <bb 2>:
  mm_cachep.30_4 = mm_cachep;
  mm_6 = kmem_cache_alloc (mm_cachep.30_4, 208);
  if (mm_6 == 0B)
    goto <bb 4>;
  else
    goto <bb 3>;

  <bb 3>:
  memset (mm_6, 0, 848);
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___10 : "p" &current_task);
  _9 = mm_init (mm_6, pfo_ret___10);

  <bb 4>:
  # _1 = PHI <0B(2), _9(3)>
  return _1;

}



;; Function set_mm_exe_file (set_mm_exe_file, funcdef_no=3634, decl_uid=17458, cgraph_uid=3634)

set_mm_exe_file (struct mm_struct * mm, struct file * new_exe_file)
{
  struct file * old_exe_file;
  long long unsigned int _7;
  long long unsigned int _13;
  struct atomic_long_t * _14;

  <bb 2>:
  _13 ={v} MEM[(volatile __u64 *)mm_3(D) + 832B];
  old_exe_file_6 = (struct file *) _13;
  if (new_exe_file_8(D) != 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _14 = &new_exe_file_8(D)->f_count;
  __asm__ __volatile__(".pushsection .smp_locks,"a"
.balign 4
.long 671f - .
.popsection
671:
	lock; incq %0" : "=m" MEM[(struct atomic64_t *)_14].counter : "m" MEM[(struct atomic64_t *)_14].counter);

  <bb 4>:
  __asm__ __volatile__("" :  :  : "memory");
  _7 = (long long unsigned int) new_exe_file_8(D);
  MEM[(volatile __u64 *)mm_3(D) + 832B] ={v} _7;
  if (old_exe_file_6 != 0B)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  fput (old_exe_file_6);

  <bb 6>:
  return;

}



;; Function mmput (mmput, funcdef_no=3633, decl_uid=24859, cgraph_uid=3633)

mmput (struct mm_struct * mm)
{
  struct atomic_t * _4;
  struct list_head * _13;
  struct list_head * _14;
  struct list_head * _15;
  struct list_head * _16;
  struct linux_binfmt * _17;
  struct module * _18;
  struct atomic_t * _19;

  <bb 2>:
  _cond_resched ();
  _4 = &mm_3(D)->mm_users;
  __asm__ __volatile__ goto(".pushsection .smp_locks,"a"
.balign 4
.long 671f - .
.popsection
671:
	lock; decl %0; je %l1" :  : "m" _4->counter : "memory" : "cc_label" <L10>);

  <bb 3>:
  __asm__ __volatile__("");
  goto <bb 9>;

  <bb 4>:
  _raw_spin_lock (&mmlist_lock.D.5408.rlock);
  _15 = MEM[(struct list_head *)mm_3(D) + 144B].next;
  _16 = MEM[(struct list_head *)mm_3(D) + 144B].prev;
  _15->prev = _16;
  _16->next = _15;
  MEM[(struct list_head *)mm_3(D) + 144B].next = -2401263026318606080B;
  MEM[(struct list_head *)mm_3(D) + 144B].prev = -2401263026318605824B;
  __asm__ __volatile__("" :  :  : "memory");
  MEM[(volatile __u8 *)&mmlist_lock] ={v} 0;
  __asm__ __volatile__("" :  :  : "memory");

  <bb 5>:
  _17 = mm_3(D)->binfmt;
  if (_17 != 0B)
    goto <bb 6>;
  else
    goto <bb 7>;

  <bb 6>:
  _18 = _17->module;
  module_put (_18);

  <bb 7>:
  _19 = &mm_3(D)->mm_count;
  __asm__ __volatile__ goto(".pushsection .smp_locks,"a"
.balign 4
.long 671f - .
.popsection
671:
	lock; decl %0; je %l1" :  : "m" _19->counter : "memory" : "cc_label" <L11>);

  <bb 8>:
  __asm__ __volatile__("");

  <bb 9>:
  return;

<L10>:
  exit_aio (mm_3(D));
  exit_mmap (mm_3(D));
  set_mm_exe_file (mm_3(D), 0B);
  _13 = &mm_3(D)->mmlist;
  _14 = MEM[(const struct list_head *)mm_3(D) + 144B].next;
  if (_13 != _14)
    goto <bb 4>;
  else
    goto <bb 5>;

<L11>:
  __mmdrop (mm_3(D));
  goto <bb 9>;

}



;; Function copy_mm (copy_mm, funcdef_no=3642, decl_uid=50866, cgraph_uid=3642) (unlikely executed)

copy_mm (long unsigned int clone_flags, struct task_struct * tsk)
{
  long int len.59;
  struct kmem_cache * vm_area_cachep.60;
  long int charge.61;
  struct vm_area_struct * mpnt;
  struct vm_area_struct * prev;
  struct vm_area_struct * * pprev;
  struct rb_node * * rb_link;
  struct rb_node * rb_parent;
  int retval;
  long unsigned int charge;
  struct file * file;
  struct address_space * mapping;
  int vm_committed_as_batch.62;
  struct kmem_cache * mm_cachep.58;
  struct mm_struct * oldmm;
  int err;
  struct task_struct * pfo_ret__;
  long int val;
  long int val;
  struct task_struct * pfo_ret__;
  struct mm_struct * mm;
  int _2;
  long unsigned int _16;
  struct atomic_t * _17;
  struct vm_area_struct *[4] * _24;
  struct mm_struct * _31;
  long unsigned int _35;
  long unsigned int _38;
  long unsigned int _39;
  long unsigned int _40;
  struct linux_binfmt * _41;
  struct module * _42;
  _Bool _43;
  struct rw_semaphore * _45;
  struct rw_semaphore * _46;
  struct file * _47;
  long long unsigned int _48;
  long unsigned int _49;
  long unsigned int _50;
  long unsigned int _51;
  long unsigned int _52;
  long unsigned int _57;
  long unsigned int _58;
  long unsigned int _59;
  long unsigned int _60;
  long unsigned int _61;
  long unsigned int _62;
  long unsigned int _63;
  long int _64;
  struct file * _65;
  long unsigned int _66;
  long unsigned int _67;
  long unsigned int _68;
  long unsigned int _69;
  int _72;
  struct list_head * _75;
  int _77;
  long unsigned int _78;
  long unsigned int _79;
  struct inode * _81;
  struct atomic_long_t * _83;
  long unsigned int _84;
  long unsigned int _85;
  struct atomic_t * _86;
  struct rw_semaphore * _87;
  long unsigned int _88;
  long unsigned int _89;
  struct atomic_t * _90;
  struct rb_root * _91;
  long unsigned int _92;
  long unsigned int _93;
  int _101;
  int _102;
  const struct vm_operations_struct * _104;
  void (*<T2753>) (struct vm_area_struct *) _105;
  struct mempolicy * _108;
  long int _112;

  <bb 2>:
  tsk_6(D)->maj_flt = 0;
  tsk_6(D)->min_flt = 0;
  tsk_6(D)->nivcsw = 0;
  tsk_6(D)->nvcsw = 0;
  tsk_6(D)->mm = 0B;
  tsk_6(D)->active_mm = 0B;
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___23 : "p" &current_task);
  mm_13 = pfo_ret___23->mm;
  if (mm_13 == 0B)
    goto <bb 39> (fail_nomem);
  else
    goto <bb 3>;

  <bb 3>:
  _24 = &tsk_6(D)->vmacache;
  memset (_24, 0, 32);
  _16 = clone_flags_15(D) & 256;
  if (_16 != 0)
    goto <bb 4>;
  else
    goto <bb 5>;

  <bb 4>:
  _17 = &mm_13->mm_users;
  __asm__ __volatile__(".pushsection .smp_locks,"a"
.balign 4
.long 671f - .
.popsection
671:
	lock; incl %0" : "=m" _17->counter : "m" _17->counter);
  goto <bb 38> (good_mm);

  <bb 5>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___27 : "p" &current_task);
  oldmm_28 = pfo_ret___27->mm;
  mm_cachep.58_29 = mm_cachep;
  mm_30 = kmem_cache_alloc (mm_cachep.58_29, 208);
  if (mm_30 == 0B)
    goto <bb 41>;
  else
    goto <bb 6>;

  <bb 6>:
  memcpy (mm_30, oldmm_28, 848);
  _31 = mm_init (mm_30, tsk_6(D));
  if (_31 == 0B)
    goto <bb 41>;
  else
    goto <bb 7>;

  <bb 7>:
  _45 = &oldmm_28->mmap_sem;
  down_write (_45);
  _46 = &mm_30->mmap_sem;
  down_write (_46);
  _47 = get_mm_exe_file (oldmm_28);
  _48 = (long long unsigned int) _47;
  MEM[(volatile __u64 *)mm_30 + 832B] ={v} _48;
  _49 = oldmm_28->total_vm;
  mm_30->total_vm = _49;
  _50 = oldmm_28->shared_vm;
  mm_30->shared_vm = _50;
  _51 = oldmm_28->exec_vm;
  mm_30->exec_vm = _51;
  _52 = oldmm_28->stack_vm;
  mm_30->stack_vm = _52;
  rb_link_53 = &mm_30->mm_rb.rb_node;
  pprev_54 = &mm_30->mmap;
  mpnt_55 = oldmm_28->mmap;
  goto <bb 29>;

  <bb 8>:
  _57 = mpnt_56->vm_flags;
  _58 = _57 & 131072;
  if (_58 != 0)
    goto <bb 9>;
  else
    goto <bb 10>;

  <bb 9>:
  _59 = MEM[(struct vm_area_struct *)mpnt_56];
  _60 = MEM[(struct vm_area_struct *)mpnt_56 + 8B];
  _61 = _60 - _59;
  _62 = _61 >> 12;
  _63 = -_62;
  _64 = (long int) _63;
  _65 = mpnt_56->vm_file;
  vm_stat_account (mm_30, _57, _65, _64);
  goto <bb 28>;

  <bb 10>:
  _66 = _57 & 1048576;
  if (_66 != 0)
    goto <bb 11>;
  else
    goto <bb 12>;

  <bb 11>:
  _67 = MEM[(struct vm_area_struct *)mpnt_56];
  _68 = MEM[(struct vm_area_struct *)mpnt_56 + 8B];
  _69 = _68 - _67;
  charge_70 = _69 >> 12;
  len.59_71 = (long int) charge_70;
  _72 = security_vm_enough_memory_mm (oldmm_28, len.59_71);
  if (_72 != 0)
    goto <bb 35> (fail_nomem);
  else
    goto <bb 12>;

  <bb 12>:
  # charge_114 = PHI <0(10), charge_70(11)>
  vm_area_cachep.60_73 = vm_area_cachep;
  prev_74 = kmem_cache_alloc (vm_area_cachep.60_73, 208);
  if (prev_74 == 0B)
    goto <bb 35> (fail_nomem);
  else
    goto <bb 13>;

  <bb 13>:
  *prev_74 = *mpnt_56;
  _75 = &prev_74->anon_vma_chain;
  MEM[(struct list_head *)prev_74 + 120B].next = _75;
  MEM[(struct list_head *)prev_74 + 120B].prev = _75;
  retval_76 = vma_dup_policy (mpnt_56, prev_74);
  if (retval_76 != 0)
    goto <bb 14>;
  else
    goto <bb 15>;

  <bb 14>:
  goto <bb 34> (fail_nomem_policy);

  <bb 15>:
  prev_74->vm_mm = mm_30;
  _77 = anon_vma_fork (prev_74, mpnt_56);
  if (_77 != 0)
    goto <bb 32> (fail_nomem_anon_vma_fork);
  else
    goto <bb 16>;

  <bb 16>:
  _78 = prev_74->vm_flags;
  _79 = _78 & 18446744073709538815;
  prev_74->vm_flags = _79;
  prev_74->vm_prev = 0B;
  prev_74->vm_next = 0B;
  prev_74->vm_userfaultfd_ctx = {};
  file_80 = prev_74->vm_file;
  if (file_80 != 0B)
    goto <bb 17>;
  else
    goto <bb 22>;

  <bb 17>:
  _81 = MEM[(const struct file *)file_80 + 32B];
  mapping_82 = file_80->f_mapping;
  _83 = &file_80->f_count;
  __asm__ __volatile__(".pushsection .smp_locks,"a"
.balign 4
.long 671f - .
.popsection
671:
	lock; incq %0" : "=m" MEM[(struct atomic64_t *)_83].counter : "m" MEM[(struct atomic64_t *)_83].counter);
  _84 = prev_74->vm_flags;
  _85 = _84 & 2048;
  if (_85 != 0)
    goto <bb 18>;
  else
    goto <bb 19>;

  <bb 18>:
  _86 = &_81->i_writecount;
  __asm__ __volatile__(".pushsection .smp_locks,"a"
.balign 4
.long 671f - .
.popsection
671:
	lock; decl %0" : "=m" _86->counter : "m" _86->counter);

  <bb 19>:
  _87 = &mapping_82->i_mmap_rwsem;
  down_write (_87);
  _88 = prev_74->vm_flags;
  _89 = _88 & 8;
  if (_89 != 0)
    goto <bb 20>;
  else
    goto <bb 21>;

  <bb 20>:
  _90 = &mapping_82->i_mmap_writable;
  __asm__ __volatile__(".pushsection .smp_locks,"a"
.balign 4
.long 671f - .
.popsection
671:
	lock; incl %0" : "=m" _90->counter : "m" _90->counter);

  <bb 21>:
  _91 = &mapping_82->i_mmap;
  vma_interval_tree_insert_after (prev_74, mpnt_56, _91);
  up_write (_87);

  <bb 22>:
  _92 = MEM[(struct vm_area_struct *)prev_74 + 80B];
  _93 = _92 & 4194304;
  if (_93 != 0)
    goto <bb 23>;
  else
    goto <bb 24>;

  <bb 23>:
  reset_vma_resv_huge_pages (prev_74);

  <bb 24>:
  *pprev_94 = prev_74;
  pprev_95 = &prev_74->vm_next;
  prev_74->vm_prev = prev_96;
  __vma_link_rb (mm_30, prev_74, rb_link_97, rb_parent_98);
  rb_link_99 = &prev_74->vm_rb.rb_right;
  rb_parent_100 = &prev_74->vm_rb;
  _101 = mm_30->map_count;
  _102 = _101 + 1;
  mm_30->map_count = _102;
  err_103 = copy_page_range (mm_30, oldmm_28, mpnt_56);
  _104 = prev_74->vm_ops;
  if (_104 != 0B)
    goto <bb 25>;
  else
    goto <bb 27>;

  <bb 25>:
  _105 = _104->open;
  if (_105 != 0B)
    goto <bb 26>;
  else
    goto <bb 27>;

  <bb 26>:
  _105 (prev_74);

  <bb 27>:
  if (err_103 != 0)
    goto <bb 30> (out);
  else
    goto <bb 28>;

  <bb 28>:
  # prev_115 = PHI <prev_96(9), prev_74(27)>
  # pprev_116 = PHI <pprev_94(9), pprev_95(27)>
  # rb_link_117 = PHI <rb_link_97(9), rb_link_99(27)>
  # rb_parent_118 = PHI <rb_parent_98(9), rb_parent_100(27)>
  mpnt_106 = mpnt_56->vm_next;

  <bb 29>:
  # mpnt_56 = PHI <mpnt_55(7), mpnt_106(28)>
  # prev_96 = PHI <0B(7), prev_115(28)>
  # pprev_94 = PHI <pprev_54(7), pprev_116(28)>
  # rb_link_97 = PHI <rb_link_53(7), rb_link_117(28)>
  # rb_parent_98 = PHI <0B(7), rb_parent_118(28)>
  if (mpnt_56 != 0B)
    goto <bb 8>;
  else
    goto <bb 30> (out);

  # err_107 = PHI <err_103(27), 0(29), -12(35)>
out:
  up_write (_46);
  flush_tlb_mm_range (oldmm_28, 0, 18446744073709551615, 0);
  up_write (_45);
  if (err_107 != 0)
    goto <bb 31>;
  else
    goto <bb 36>;

  <bb 31>:
  mm_30->binfmt = 0B;
  mmput (mm_30);
  goto <bb 42>;

  # prev_37 = PHI <prev_74(15)>
fail_nomem_anon_vma_fork:
  _108 = prev_37->vm_policy;
  if (_108 != 0B)
    goto <bb 33>;
  else
    goto <bb 14>;

  <bb 33>:
  __mpol_put (_108);

  # prev_187 = PHI <prev_74(14), prev_74(33)>
fail_nomem_policy:
  vm_area_cachep.60_109 = vm_area_cachep;
  kmem_cache_free (vm_area_cachep.60_109, prev_187);

  # charge_110 = PHI <0(11), charge_114(12), charge_114(34)>
fail_nomem:
  charge.61_111 = (long int) charge_110;
  _112 = -charge.61_111;
  vm_committed_as_batch.62_113 = vm_committed_as_batch;
  __percpu_counter_add (&vm_committed_as, _112, vm_committed_as_batch.62_113);
  goto <bb 30> (out);

  <bb 36>:
  val_33 ={v} MEM[(const long int *)mm_30 + 688B];
  val_191 = MAX_EXPR <val_33, 0>;
  _35 = (long unsigned int) val_191;
  val_36 ={v} MEM[(const long int *)mm_30 + 696B];
  val_20 = MAX_EXPR <val_36, 0>;
  _38 = (long unsigned int) val_20;
  _39 = _38 + _35;
  mm_30->hiwater_rss = _39;
  _40 = mm_30->total_vm;
  mm_30->hiwater_vm = _40;
  _41 = mm_30->binfmt;
  if (_41 != 0B)
    goto <bb 37>;
  else
    goto <bb 40>;

  <bb 37>:
  _42 = _41->module;
  _43 = try_module_get (_42);
  if (_43 != 0)
    goto <bb 40>;
  else
    goto <bb 31>;

  # mm_1 = PHI <mm_13(4), mm_30(40)>
good_mm:
  tsk_6(D)->mm = mm_1;
  tsk_6(D)->active_mm = mm_1;

  # _2 = PHI <0(2), 0(38), -12(42)>
fail_nomem:
  return _2;

  <bb 40>:
  goto <bb 38> (good_mm);

  <bb 41>:

  <bb 42>:
  goto <bb 39> (fail_nomem);

}



;; Function mm_access (mm_access, funcdef_no=3637, decl_uid=24864, cgraph_uid=3637)

mm_access (struct task_struct * task, unsigned int mode)
{
  struct task_struct * pfo_ret__;
  int err;
  struct mm_struct * mm;
  struct mm_struct * _2;
  struct signal_struct * _7;
  struct mutex * _8;
  long int _11;
  struct mm_struct * _14;
  _Bool _17;
  struct signal_struct * _19;
  struct mutex * _20;
  void * _22;

  <bb 2>:
  _7 = task_6(D)->signal;
  _8 = &_7->cred_guard_mutex;
  err_10 = mutex_lock_killable (_8);
  if (err_10 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _11 = (long int) err_10;
  _22 = (void *) _11;
  goto <bb 9>;

  <bb 4>:
  mm_13 = get_task_mm (task_6(D));
  if (mm_13 != 0B)
    goto <bb 5>;
  else
    goto <bb 8>;

  <bb 5>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___23 : "p" &current_task);
  _14 = pfo_ret___23->mm;
  if (_14 != mm_13)
    goto <bb 6>;
  else
    goto <bb 8>;

  <bb 6>:
  _17 = ptrace_may_access (task_6(D), mode_15(D));
  if (_17 != 0)
    goto <bb 8>;
  else
    goto <bb 7>;

  <bb 7>:
  mmput (mm_13);

  <bb 8>:
  # mm_1 = PHI <mm_13(4), mm_13(5), mm_13(6), -13B(7)>
  _19 = task_6(D)->signal;
  _20 = &_19->cred_guard_mutex;
  mutex_unlock (_20);

  <bb 9>:
  # _2 = PHI <_22(3), mm_1(8)>
  return _2;

}



;; Function mm_release (mm_release, funcdef_no=3640, decl_uid=24867, cgraph_uid=3640)

mm_release (struct task_struct * tsk, struct mm_struct * mm)
{
  struct completion * vfork;
  int __ret_pu;
  short unsigned int __val;
  struct robust_list_head * _9;
  struct compat_robust_list_head * _15;
  struct list_head * _21;
  int * _29;
  unsigned int _30;
  unsigned int _31;
  struct completion * _37;
  struct list_head * _39;
  int _41;
  struct raw_spinlock * _43;

  <bb 2>:
  _9 = tsk_8(D)->robust_list;
  if (_9 != 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  exit_robust_list (tsk_8(D));
  tsk_8(D)->robust_list = 0B;

  <bb 4>:
  _15 = tsk_8(D)->compat_robust_list;
  if (_15 != 0B)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  compat_exit_robust_list (tsk_8(D));
  tsk_8(D)->compat_robust_list = 0B;

  <bb 6>:
  _21 = &tsk_8(D)->pi_state_list;
  _39 = MEM[(const struct list_head *)tsk_8(D) + 1928B].next;
  if (_21 != _39)
    goto <bb 7>;
  else
    goto <bb 8>;

  <bb 7>:
  exit_pi_state_list (tsk_8(D));

  <bb 8>:
  native_load_gs_index (0);
  __asm__ __volatile__("						
1:	movl %k0,%%fs		
.section .fixup,"ax"			
2:	xorl %k0,%k0			
		jmp 1b				
.previous					
 .pushsection "__ex_table","a"
 .balign 8
 .long (1b) - .
 .long (2b) - .
 .popsection
" : "=r" __val_28 : "0" 0 : "memory");
  _29 = tsk_8(D)->clear_child_tid;
  if (_29 != 0B)
    goto <bb 9>;
  else
    goto <bb 13>;

  <bb 9>:
  _30 = tsk_8(D)->flags;
  _31 = _30 & 1024;
  if (_31 == 0)
    goto <bb 10>;
  else
    goto <bb 12>;

  <bb 10>:
  _41 ={v} MEM[(const int *)mm_32(D) + 72B];
  if (_41 > 1)
    goto <bb 11>;
  else
    goto <bb 12>;

  <bb 11>:
  __asm__ __volatile__("call __put_user_4" : "=a" __ret_pu_34 : "0" 0, "c" _29 : "ebx");
  sys_futex (_29, 1, 1, 0B, 0B, 0);

  <bb 12>:
  tsk_8(D)->clear_child_tid = 0B;

  <bb 13>:
  _37 = tsk_8(D)->vfork_done;
  if (_37 != 0B)
    goto <bb 14>;
  else
    goto <bb 17>;

  <bb 14>:
  _43 = &MEM[(struct spinlock_t *)tsk_8(D) + 1680B].D.5408.rlock;
  _raw_spin_lock (_43);
  vfork_44 = tsk_8(D)->vfork_done;
  if (vfork_44 != 0B)
    goto <bb 15>;
  else
    goto <bb 16>;

  <bb 15>:
  tsk_8(D)->vfork_done = 0B;
  complete (vfork_44);

  <bb 16>:
  __asm__ __volatile__("" :  :  : "memory");
  MEM[(volatile __u8 *)tsk_8(D) + 1680B] ={v} 0;
  __asm__ __volatile__("" :  :  : "memory");

  <bb 17>:
  return;

}



;; Function __cleanup_sighand (__cleanup_sighand, funcdef_no=3647, decl_uid=24881, cgraph_uid=3647)

__cleanup_sighand (struct sighand_struct * sighand)
{
  struct kmem_cache * sighand_cachep.40;
  struct atomic_t * _3;

  <bb 2>:
  _3 = &sighand_2(D)->count;
  __asm__ __volatile__ goto(".pushsection .smp_locks,"a"
.balign 4
.long 671f - .
.popsection
671:
	lock; decl %0; je %l1" :  : "m" _3->counter : "memory" : "cc_label" <L4>);

  <bb 3>:
  __asm__ __volatile__("");

  <bb 4>:
  return;

<L4>:
  signalfd_cleanup (sighand_2(D));
  sighand_cachep.40_7 = sighand_cachep;
  kmem_cache_free (sighand_cachep.40_7, sighand_2(D));
  goto <bb 4>;

}



;; Function SyS_set_tid_address (SyS_set_tid_address, funcdef_no=3651, decl_uid=50937, cgraph_uid=3652)

SyS_set_tid_address (long int tidptr)
{
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  int * tidptr.41;
  pid_t _7;
  long int _8;

  <bb 2>:
  tidptr.41_2 = (int *) tidptr_1(D);
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___5 : "p" &current_task);
  pfo_ret___5->clear_child_tid = tidptr.41_2;
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___6 : "p" &current_task);
  _7 = __task_pid_nr_ns (pfo_ret___6, 0, 0B);
  _8 = (long int) _7;
  return _8;

}



;; Function fork_idle (fork_idle, funcdef_no=3658, decl_uid=24912, cgraph_uid=3659)

fork_idle (int cpu)
{
  struct kmem_cache * delayacct_cache.20;
  struct pid_namespace * ns;
  pid_t nr;
  struct mempolicy * pol;
  union ktime_t D.55554;
  s64 SR.313;
  union ktime D.55551;
  int delayacct_on.53;
  int nr_threads.42;
  int max_threads.43;
  int nr_threads.47;
  long unsigned int total_forks.48;
  long unsigned int total_forks.49;
  int retval;
  struct task_struct * p;
  void * cgrp_ss_priv[0:];
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  long unsigned int ptr.74;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct pid_link[3] * _4;
  const struct cred * _11;
  struct user_struct * _12;
  int _13;
  long unsigned int _14;
  _Bool _18;
  _Bool _19;
  unsigned int _21;
  unsigned int _22;
  unsigned int _26;
  unsigned int _27;
  unsigned int _28;
  struct list_head * _29;
  struct list_head * _30;
  struct task_rss_stat * _33;
  long unsigned int _35;
  struct task_io_accounting * _36;
  long int _45;
  struct list_head * _51;
  struct list_head * _65;
  struct list_head * _67;
  unsigned int _71;
  struct sighand_struct * _73;
  struct raw_spinlock * _74;
  int _76;
  struct sighand_struct * _78;
  int _80;
  struct signal_struct * _91;
  unsigned int _92;
  unsigned int _93;
  struct signal_struct * _94;
  struct signal_struct * _95;
  struct signal_struct * _97;
  struct tty_struct * _98;
  struct tty_struct * _99;
  struct task_struct * _100;
  struct list_head * _101;
  struct list_head * _102;
  struct signal_struct * _104;
  int _105;
  int _106;
  struct signal_struct * _108;
  struct atomic_t * _109;
  struct signal_struct * _111;
  struct atomic_t * _112;
  struct task_struct * _113;
  struct list_head * _114;
  struct signal_struct * _115;
  struct list_head * _116;
  struct list_head * _117;
  struct sighand_struct * _123;
  struct io_context * _125;
  struct mm_struct * _126;
  struct signal_struct * _127;
  struct sighand_struct * _128;
  struct mempolicy * _129;
  const struct cred * _130;
  struct user_struct * _131;
  struct atomic_t * _132;
  struct task_struct * _136;
  struct pid_link * _158;
  struct signal_struct * _313;
  long long unsigned int _314;
  struct list_head * _316;
  long long int _317;
  u64 _318;
  u64 _320;
  int _325;
  struct task_struct * _327;
  struct pid * _328;
  struct task_struct * _329;
  struct pid * _330;
  unsigned int _331;
  int _332;
  struct list_head * _337;
  struct list_head * _338;
  long long unsigned int _339;
  struct list_head * _340;
  long long unsigned int _341;
  struct list_head * _342;
  long long unsigned int _343;
  struct audit_context * _344;
  struct task_delay_info * _348;
  struct pid_link * _454;
  long int pretmp_461;
  void * pretmp_464;
  void * prephitmp_466;
  long unsigned int pretmp_467;
  long unsigned int prephitmp_469;
  long int pretmp_470;
  void * pretmp_473;
  void * prephitmp_475;
  long unsigned int pretmp_476;
  long unsigned int prephitmp_478;
  long int pretmp_479;
  void * pretmp_481;
  void * prephitmp_482;
  long unsigned int pretmp_483;
  long unsigned int prephitmp_484;
  long unsigned int pretmp_485;
  long unsigned int prephitmp_486;

  <bb 2>:
  cgrp_ss_priv = {};
  retval_8 = security_task_create (256);
  if (retval_8 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  pretmp_461 = (long int) retval_8;
  pretmp_464 = (void *) pretmp_461;
  pretmp_467 = (long unsigned int) retval_8;
  goto <bb 64> (fork_out);

  <bb 4>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___9 : "p" &current_task);
  p_10 = dup_task_struct (pfo_ret___9);
  if (p_10 == 0B)
    goto <bb 64> (fork_out);
  else
    goto <bb 5>;

  <bb 5>:
  p_10->pi_lock.raw_lock.val.counter = 0;
  p_10->pi_waiters.rb_node = 0B;
  p_10->pi_waiters_leftmost = 0B;
  p_10->pi_blocked_on = 0B;
  _11 = p_10->real_cred;
  _12 = _11->user;
  _13 ={v} MEM[(const int *)_12 + 4B];
  _14 = (long unsigned int) _13;
  _313 = MEM[(const struct task_struct *)p_10].signal;
  _314 ={v} MEM[(volatile __u64 *)_313].rlim[6].rlim_cur;
  if (_14 >= _314)
    goto <bb 7>;
  else
    goto <bb 6>;

  <bb 6>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___20 : "p" &current_task);
  _21 = pfo_ret___20->flags;
  _22 = _21 & 4294963199;
  pfo_ret___20->flags = _22;
  retval_23 = copy_creds (p_10, 256);
  if (retval_23 < 0)
    goto <bb 10>;
  else
    goto <bb 11>;

  <bb 7>:
  if (_12 != &root_user)
    goto <bb 8>;
  else
    goto <bb 6>;

  <bb 8>:
  _18 = capable (24);
  if (_18 != 0)
    goto <bb 6>;
  else
    goto <bb 9>;

  <bb 9>:
  _19 = capable (21);
  if (_19 != 0)
    goto <bb 6>;
  else
    goto <bb 63> (bad_fork_free);

  <bb 10>:
  pretmp_470 = (long int) retval_23;
  pretmp_473 = (void *) pretmp_470;
  pretmp_476 = (long unsigned int) retval_23;
  goto <bb 63> (bad_fork_free);

  <bb 11>:
  nr_threads.42_24 = nr_threads;
  max_threads.43_25 = max_threads;
  if (nr_threads.42_24 >= max_threads.43_25)
    goto <bb 62> (bad_fork_cleanup_count);
  else
    goto <bb 12>;

  <bb 12>:
  p_10->delays = 0B;
  delayacct_on.53_315 = delayacct_on;
  if (delayacct_on.53_315 != 0)
    goto <bb 13>;
  else
    goto <bb 14>;

  <bb 13>:
  __delayacct_tsk_init (p_10);

  <bb 14>:
  _26 = p_10->flags;
  _27 = _26 & 4294967007;
  _28 = _27 | 64;
  p_10->flags = _28;
  _29 = &p_10->children;
  MEM[(struct list_head *)p_10 + 1056B].next = _29;
  MEM[(struct list_head *)p_10 + 1056B].prev = _29;
  _30 = &p_10->sibling;
  MEM[(struct list_head *)p_10 + 1072B].next = _30;
  MEM[(struct list_head *)p_10 + 1072B].prev = _30;
  p_10->vfork_done = 0B;
  p_10->alloc_lock.D.5408.rlock.raw_lock.val.counter = 0;
  MEM[(struct sigset_t *)p_10 + 1584B].sig[0] = 0;
  _316 = &MEM[(struct sigpending *)p_10 + 1568B].list;
  MEM[(struct list_head *)p_10 + 1568B].next = _316;
  MEM[(struct list_head *)p_10 + 1568B].prev = _316;
  p_10->gtime = 0;
  p_10->stime = 0;
  p_10->utime = 0;
  p_10->stimescaled = 0;
  p_10->utimescaled = 0;
  MEM[(struct prev_cputime *)p_10 + 1296B].stime = 0;
  MEM[(struct prev_cputime *)p_10 + 1296B].utime = 0;
  MEM[(struct prev_cputime *)p_10 + 1296B].lock.raw_lock.val.counter = 0;
  _33 = &p_10->rss_stat;
  memset (_33, 0, 16);
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___34 : "p" &current_task);
  _35 = pfo_ret___34->timer_slack_ns;
  p_10->default_timer_slack_ns = _35;
  _36 = &p_10->ioac;
  memset (_36, 0, 56);
  acct_clear_integrals (p_10);
  posix_cpu_timers_init (p_10);
  D.55551 = ktime_get ();
  _317 = D.55551.tv64;
  _318 = (u64) _317;
  p_10->start_time = _318;
  D.55554 = ktime_get_with_offset (1);
  SR.313_319 = MEM[(union ktime *)&D.55554];
  _320 = (u64) SR.313_319;
  p_10->real_start_time = _320;
  p_10->io_context = 0B;
  p_10->audit_context = 0B;
  cgroup_fork (p_10);
  pol_39 = p_10->mempolicy;
  if (pol_39 != 0B)
    goto <bb 15>;
  else
    goto <bb 17>;

  <bb 15>:
  pol_321 = __mpol_dup (pol_39);
  p_10->mempolicy = pol_321;
  ptr.74_41 = (long unsigned int) pol_321;
  if (ptr.74_41 > 18446744073709547520)
    goto <bb 16>;
  else
    goto <bb 17>;

  <bb 16>:
  _45 = (long int) pol_321;
  retval_46 = (int) _45;
  p_10->mempolicy = 0B;
  goto <bb 59> (bad_fork_cleanup_threadgroup_lock);

  <bb 17>:
  p_10->cpuset_mem_spread_rotor = -1;
  p_10->cpuset_slab_spread_rotor = -1;
  MEM[(struct seqcount_t *)p_10 + 1872B].sequence = 0;
  p_10->pagefault_disabled = 0;
  retval_48 = sched_fork (256, p_10);
  if (retval_48 != 0)
    goto <bb 57> (bad_fork_cleanup_policy);
  else
    goto <bb 18>;

  <bb 18>:
  retval_49 = perf_event_init_task (p_10);
  if (retval_49 != 0)
    goto <bb 57> (bad_fork_cleanup_policy);
  else
    goto <bb 19>;

  <bb 19>:
  retval_50 = audit_alloc (p_10);
  if (retval_50 != 0)
    goto <bb 56> (bad_fork_cleanup_perf);
  else
    goto <bb 20>;

  <bb 20>:
  _51 = &p_10->sysvshm.shm_clist;
  MEM[(struct list_head *)p_10 + 1488B].next = _51;
  MEM[(struct list_head *)p_10 + 1488B].prev = _51;
  retval_52 = copy_semundo (256, p_10);
  if (retval_52 != 0)
    goto <bb 54> (bad_fork_cleanup_audit);
  else
    goto <bb 21>;

  <bb 21>:
  retval_53 = copy_files (256, p_10);
  if (retval_53 != 0)
    goto <bb 53> (bad_fork_cleanup_semundo);
  else
    goto <bb 22>;

  <bb 22>:
  retval_54 = copy_fs (256, p_10);
  if (retval_54 != 0)
    goto <bb 52> (bad_fork_cleanup_files);
  else
    goto <bb 23>;

  <bb 23>:
  retval_55 = copy_sighand (256, p_10);
  if (retval_55 != 0)
    goto <bb 51> (bad_fork_cleanup_fs);
  else
    goto <bb 24>;

  <bb 24>:
  retval_56 = copy_signal (256, p_10);
  if (retval_56 != 0)
    goto <bb 50> (bad_fork_cleanup_sighand);
  else
    goto <bb 25>;

  <bb 25>:
  retval_57 = copy_mm (256, p_10);
  if (retval_57 != 0)
    goto <bb 49> (bad_fork_cleanup_signal);
  else
    goto <bb 26>;

  <bb 26>:
  retval_58 = copy_namespaces (256, p_10);
  if (retval_58 != 0)
    goto <bb 47> (bad_fork_cleanup_mm);
  else
    goto <bb 27>;

  <bb 27>:
  retval_59 = copy_io (256, p_10);
  if (retval_59 != 0)
    goto <bb 46> (bad_fork_cleanup_namespaces);
  else
    goto <bb 28>;

  <bb 28>:
  retval_60 = copy_thread_tls (256, 0, 0, p_10, 0);
  if (retval_60 != 0)
    goto <bb 44> (bad_fork_cleanup_io);
  else
    goto <bb 29>;

  <bb 29>:
  p_10->set_child_tid = 0B;
  p_10->clear_child_tid = 0B;
  p_10->plug = 0B;
  p_10->robust_list = 0B;
  p_10->compat_robust_list = 0B;
  _65 = &p_10->pi_state_list;
  MEM[(struct list_head *)p_10 + 1928B].next = _65;
  MEM[(struct list_head *)p_10 + 1928B].prev = _65;
  p_10->pi_state_cache = 0B;
  p_10->sas_ss_size = 0;
  p_10->sas_ss_sp = 0;
  user_disable_single_step (p_10);
  clear_tsk_thread_flag (p_10, 0);
  clear_tsk_thread_flag (p_10, 6);
  if (&init_struct_pid != 0B)
    goto <bb 30>;
  else
    goto <bb 31>;

  <bb 30>:
  nr_323 = init_struct_pid.numbers[0].nr;

  <bb 31>:
  # nr_324 = PHI <0(29), nr_323(30)>
  p_10->pid = nr_324;
  p_10->exit_signal = 0;
  p_10->group_leader = p_10;
  p_10->tgid = nr_324;
  p_10->nr_dirtied = 0;
  p_10->nr_dirtied_pause = 32;
  p_10->dirty_paused_when = 0;
  p_10->pdeath_signal = 0;
  _67 = &p_10->thread_group;
  MEM[(struct list_head *)p_10 + 1200B].next = _67;
  MEM[(struct list_head *)p_10 + 1200B].prev = _67;
  p_10->task_works = 0B;
  retval_68 = cgroup_can_fork (p_10, &cgrp_ss_priv);
  if (retval_68 != 0)
    goto <bb 44> (bad_fork_cleanup_io);
  else
    goto <bb 32>;

  <bb 32>:
  _raw_write_lock_irq (&tasklist_lock);
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___69 : "p" &current_task);
  p_10->real_parent = pfo_ret___69;
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___70 : "p" &current_task);
  _71 = pfo_ret___70->self_exec_id;
  p_10->parent_exec_id = _71;
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___72 : "p" &current_task);
  _73 = pfo_ret___72->sighand;
  _74 = &MEM[(struct spinlock_t *)_73 + 2056B].D.5408.rlock;
  _raw_spin_lock (_74);
  copy_seccomp (p_10);
  recalc_sigpending ();
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___75 : "p" &current_task);
  _76 = signal_pending (pfo_ret___75);
  if (_76 != 0)
    goto <bb 33>;
  else
    goto <bb 34>;

  <bb 33>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___77 : "p" &current_task);
  _78 = pfo_ret___77->sighand;
  __asm__ __volatile__("" :  :  : "memory");
  MEM[(volatile __u8 *)_78 + 2056B] ={v} 0;
  __asm__ __volatile__("" :  :  : "memory");
  __asm__ __volatile__("" :  :  : "memory");
  MEM[(volatile __u8 *)&tasklist_lock] ={v} 0;
  __asm__ __volatile__("sti" :  :  : "memory");
  __asm__ __volatile__("" :  :  : "memory");
  cgroup_cancel_fork (p_10, &cgrp_ss_priv);
  goto <bb 44> (bad_fork_cleanup_io);

  <bb 34>:
  _80 = p_10->pid;
  if (_80 != 0)
    goto <bb 35>;
  else
    goto <bb 43>;

  <bb 35>:
  ptrace_init_task (p_10, 0);
  p_10->pids[0].pid = &init_struct_pid;
  _325 = p_10->exit_signal;
  if (_325 >= 0)
    goto <bb 36>;
  else
    goto <bb 41>;

  <bb 36>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___85 : "p" &current_task);
  _327 = pfo_ret___85->group_leader;
  _328 = _327->pids[1].pid;
  p_10->pids[1].pid = _328;
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___87 : "p" &current_task);
  _329 = pfo_ret___87->group_leader;
  _330 = _329->pids[2].pid;
  p_10->pids[2].pid = _330;
  _331 = init_struct_pid.level;
  _332 = init_struct_pid.numbers[_331].nr;
  if (_332 == 1)
    goto <bb 37>;
  else
    goto <bb 40>;

  <bb 37>:
  if (&init_struct_pid != 0B)
    goto <bb 38>;
  else
    goto <bb 39>;

  <bb 38>:
  ns_335 = init_struct_pid.numbers[_331].ns;

  <bb 39>:
  # ns_336 = PHI <0B(37), ns_335(38)>
  ns_336->child_reaper = p_10;
  _91 = p_10->signal;
  _92 = _91->flags;
  _93 = _92 | 64;
  _91->flags = _93;

  <bb 40>:
  _94 = p_10->signal;
  _94->leader_pid = &init_struct_pid;
  _95 = p_10->signal;
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___96 : "p" &current_task);
  _97 = pfo_ret___96->signal;
  _98 = _97->tty;
  _99 = tty_kref_get (_98);
  _95->tty = _99;
  _100 = p_10->real_parent;
  _101 = &_100->children;
  _337 = MEM[(struct list_head *)_100 + 1056B].prev;
  MEM[(struct list_head *)_100 + 1056B].prev = _30;
  MEM[(struct list_head *)p_10 + 1072B].next = _101;
  MEM[(struct list_head *)p_10 + 1072B].prev = _337;
  _337->next = _30;
  _102 = &p_10->tasks;
  _338 = MEM[(struct list_head *)&init_task + 792B].prev;
  MEM[(struct list_head *)p_10 + 792B].next = &init_task.tasks;
  MEM[(struct list_head *)p_10 + 792B].prev = _338;
  __asm__ __volatile__("" :  :  : "memory");
  _339 = (long long unsigned int) _102;
  MEM[(volatile __u64 *)_338] ={v} _339;
  MEM[(struct list_head *)&init_task + 792B].prev = _102;
  attach_pid (p_10, 1);
  attach_pid (p_10, 2);
  __asm__("incq %%gs:%0" : "=m" process_counts : "m" process_counts);
  goto <bb 42>;

  <bb 41>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___103 : "p" &current_task);
  _104 = pfo_ret___103->signal;
  _105 = _104->nr_threads;
  _106 = _105 + 1;
  _104->nr_threads = _106;
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___107 : "p" &current_task);
  _108 = pfo_ret___107->signal;
  _109 = &_108->live;
  __asm__ __volatile__(".pushsection .smp_locks,"a"
.balign 4
.long 671f - .
.popsection
671:
	lock; incl %0" : "=m" _109->counter : "m" _109->counter);
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___110 : "p" &current_task);
  _111 = pfo_ret___110->signal;
  _112 = &_111->sigcnt;
  __asm__ __volatile__(".pushsection .smp_locks,"a"
.balign 4
.long 671f - .
.popsection
671:
	lock; incl %0" : "=m" _112->counter : "m" _112->counter);
  _113 = p_10->group_leader;
  _114 = &_113->thread_group;
  _340 = MEM[(struct list_head *)_113 + 1200B].prev;
  MEM[(struct list_head *)p_10 + 1200B].next = _114;
  MEM[(struct list_head *)p_10 + 1200B].prev = _340;
  __asm__ __volatile__("" :  :  : "memory");
  _341 = (long long unsigned int) _67;
  MEM[(volatile __u64 *)_340] ={v} _341;
  MEM[(struct list_head *)_113 + 1200B].prev = _67;
  _115 = p_10->signal;
  _116 = &_115->thread_head;
  _117 = &p_10->thread_node;
  _342 = MEM[(struct list_head *)_115 + 16B].prev;
  MEM[(struct list_head *)p_10 + 1216B].next = _116;
  MEM[(struct list_head *)p_10 + 1216B].prev = _342;
  __asm__ __volatile__("" :  :  : "memory");
  _343 = (long long unsigned int) _117;
  MEM[(volatile __u64 *)_342] ={v} _343;
  MEM[(struct list_head *)_115 + 16B].prev = _117;

  <bb 42>:
  attach_pid (p_10, 0);
  nr_threads.42_118 = nr_threads;
  nr_threads.47_119 = nr_threads.42_118 + 1;
  nr_threads = nr_threads.47_119;

  <bb 43>:
  total_forks.48_120 = total_forks;
  total_forks.49_121 = total_forks.48_120 + 1;
  total_forks = total_forks.49_121;
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___122 : "p" &current_task);
  _123 = pfo_ret___122->sighand;
  __asm__ __volatile__("" :  :  : "memory");
  MEM[(volatile __u8 *)_123 + 2056B] ={v} 0;
  __asm__ __volatile__("" :  :  : "memory");
  syscall_tracepoint_update (p_10);
  __asm__ __volatile__("" :  :  : "memory");
  MEM[(volatile __u8 *)&tasklist_lock] ={v} 0;
  __asm__ __volatile__("sti" :  :  : "memory");
  __asm__ __volatile__("" :  :  : "memory");
  proc_fork_connector (p_10);
  cgroup_post_fork (p_10, &cgrp_ss_priv);
  perf_event_fork (p_10);
  trace_task_newtask (p_10, 256);
  pretmp_485 = (long unsigned int) p_10;
  goto <bb 65>;

  # retval_137 = PHI <retval_60(28), -513(33), retval_68(31)>
bad_fork_cleanup_io:
  _125 = p_10->io_context;
  if (_125 != 0B)
    goto <bb 45>;
  else
    goto <bb 46> (bad_fork_cleanup_namespaces);

  <bb 45>:
  exit_io_context (p_10);

  # retval_138 = PHI <retval_59(27), retval_137(44), retval_137(45)>
bad_fork_cleanup_namespaces:
  exit_task_namespaces (p_10);

  # retval_139 = PHI <retval_58(26), retval_138(46)>
bad_fork_cleanup_mm:
  _126 = p_10->mm;
  if (_126 != 0B)
    goto <bb 48>;
  else
    goto <bb 49> (bad_fork_cleanup_signal);

  <bb 48>:
  mmput (_126);

  # retval_140 = PHI <retval_57(25), retval_139(47), retval_139(48)>
bad_fork_cleanup_signal:
  _127 = p_10->signal;
  free_signal_struct (_127);

  # retval_141 = PHI <retval_56(24), retval_140(49)>
bad_fork_cleanup_sighand:
  _128 = p_10->sighand;
  __cleanup_sighand (_128);

  # retval_142 = PHI <retval_55(23), retval_141(50)>
bad_fork_cleanup_fs:
  exit_fs (p_10);

  # retval_143 = PHI <retval_54(22), retval_142(51)>
bad_fork_cleanup_files:
  exit_files (p_10);

  # retval_144 = PHI <retval_53(21), retval_143(52)>
bad_fork_cleanup_semundo:
  exit_sem (p_10);

  # retval_145 = PHI <retval_52(20), retval_144(53)>
bad_fork_cleanup_audit:
  _344 = p_10->audit_context;
  if (_344 != 0B)
    goto <bb 55>;
  else
    goto <bb 56> (bad_fork_cleanup_perf);

  <bb 55>:
  __audit_free (p_10);

  # retval_146 = PHI <retval_50(19), retval_145(55), retval_145(54)>
bad_fork_cleanup_perf:
  perf_event_free_task (p_10);

  # retval_147 = PHI <retval_48(17), retval_49(18), retval_146(56)>
bad_fork_cleanup_policy:
  _129 = p_10->mempolicy;
  if (_129 != 0B)
    goto <bb 58>;
  else
    goto <bb 59> (bad_fork_cleanup_threadgroup_lock);

  <bb 58>:
  __mpol_put (_129);

  # retval_148 = PHI <retval_46(16), retval_147(58), retval_147(57)>
bad_fork_cleanup_threadgroup_lock:
  _348 = p_10->delays;
  if (_348 != 0B)
    goto <bb 60>;
  else
    goto <bb 61>;

  <bb 60>:
  delayacct_cache.20_349 = delayacct_cache;
  kmem_cache_free (delayacct_cache.20_349, _348);

  <bb 61>:
  p_10->delays = 0B;
  pretmp_479 = (long int) retval_148;
  pretmp_481 = (void *) pretmp_479;
  pretmp_483 = (long unsigned int) retval_148;

  # prephitmp_482 = PHI <-11B(11), pretmp_481(61)>
  # prephitmp_484 = PHI <18446744073709551605(11), pretmp_483(61)>
bad_fork_cleanup_count:
  _130 = p_10->cred;
  _131 = _130->user;
  _132 = &_131->processes;
  __asm__ __volatile__(".pushsection .smp_locks,"a"
.balign 4
.long 671f - .
.popsection
671:
	lock; decl %0" : "=m" _132->counter : "m" _132->counter);
  exit_creds (p_10);

  # prephitmp_475 = PHI <-11B(9), pretmp_473(10), prephitmp_482(62)>
  # prephitmp_478 = PHI <18446744073709551605(9), pretmp_476(10), prephitmp_484(62)>
bad_fork_free:
  free_task (p_10);

  # prephitmp_466 = PHI <pretmp_464(3), -12B(4), prephitmp_475(63)>
  # prephitmp_469 = PHI <pretmp_467(3), 18446744073709551604(4), prephitmp_478(63)>
fork_out:

  <bb 65>:
  # _136 = PHI <prephitmp_466(64), p_10(43)>
  # prephitmp_486 = PHI <prephitmp_469(64), pretmp_485(43)>
  cgrp_ss_priv ={v} {CLOBBER};
  if (prephitmp_486 <= 18446744073709547520)
    goto <bb 66>;
  else
    goto <bb 67>;

  <bb 66>:
  _4 = &_136->pids;
  MEM[(struct hlist_node *)_136 + 1128B].next = 0B;
  MEM[(struct hlist_node *)_136 + 1128B].pprev = 0B;
  MEM[(struct pid_link *)_136 + 1128B].pid = &init_struct_pid;
  _454 = &MEM[(void *)_136 + 1152B];
  MEM[(struct hlist_node *)_136 + 1152B].next = 0B;
  MEM[(struct hlist_node *)_136 + 1152B].pprev = 0B;
  MEM[(struct pid_link *)_136 + 1152B].pid = &init_struct_pid;
  _158 = &MEM[(void *)_136 + 1176B];
  MEM[(struct hlist_node *)_136 + 1176B].next = 0B;
  MEM[(struct hlist_node *)_136 + 1176B].pprev = 0B;
  MEM[(struct pid_link *)_136 + 1176B].pid = &init_struct_pid;
  init_idle (_136, cpu_6(D));

  <bb 67>:
  return _136;

}



;; Function _do_fork (_do_fork, funcdef_no=3659, decl_uid=24904, cgraph_uid=3660)

_do_fork (long unsigned int clone_flags, long unsigned int stack_start, long unsigned int stack_size, int * parent_tidptr, int * child_tidptr, long unsigned int tls)
{
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * ________p1;
  struct pid_namespace * ns;
  long unsigned int message;
  static struct lock_class_key __key;
  void (*<T6b5e>) (void *, struct task_struct *, struct task_struct *) it_func.78;
  struct tracepoint_func * it_func_ptr;
  void * __data;
  struct kmem_cache * delayacct_cache.20;
  struct pid_namespace * ns;
  pid_t nr;
  struct mempolicy * pol;
  union ktime_t D.55669;
  s64 SR.313;
  union ktime D.55666;
  int delayacct_on.53;
  struct task_struct * pfo_ret__;
  int nr_threads.42;
  int max_threads.43;
  int * iftmp.44;
  int * iftmp.45;
  int iftmp.46;
  int nr_threads.47;
  long unsigned int total_forks.48;
  long unsigned int total_forks.49;
  int retval;
  struct task_struct * p;
  void * cgrp_ss_priv[0:];
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  long unsigned int ptr.74;
  long unsigned int ptr.74;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct pid * pid;
  struct task_struct * pfo_ret__;
  int __ret_pu;
  struct pid * pid;
  struct completion vfork;
  long int nr;
  int trace;
  long unsigned int _9;
  long unsigned int _10;
  long unsigned int _11;
  long unsigned int prephitmp_14;
  unsigned int prephitmp_15;
  long unsigned int pretmp_16;
  int _26;
  long unsigned int _28;
  long unsigned int _31;
  struct atomic_t * _34;
  int _42;
  long unsigned int _47;
  long unsigned int _48;
  long unsigned int _49;
  long unsigned int _50;
  long unsigned int _51;
  struct signal_struct * _53;
  unsigned int _54;
  unsigned int _55;
  long unsigned int _56;
  long unsigned int _57;
  struct pid_namespace * _59;
  struct nsproxy * _61;
  struct pid_namespace * _62;
  const struct cred * _66;
  struct user_struct * _67;
  int _68;
  long unsigned int _69;
  _Bool _73;
  _Bool _74;
  unsigned int _76;
  unsigned int _77;
  unsigned int _81;
  unsigned int _82;
  unsigned int _83;
  struct list_head * _84;
  struct list_head * _85;
  struct task_rss_stat * _88;
  long unsigned int _90;
  struct task_io_accounting * _91;
  long int pretmp_98;
  void * prephitmp_99;
  long int _101;
  struct list_head * _107;
  struct nsproxy * _117;
  struct pid_namespace * _118;
  long unsigned int pretmp_122;
  void * prephitmp_123;
  long int _124;
  long unsigned int _126;
  long unsigned int _128;
  struct list_head * _130;
  long unsigned int _131;
  struct task_struct * _135;
  int _137;
  struct task_struct * _139;
  int _140;
  int _141;
  int _142;
  struct list_head * _143;
  long unsigned int _145;
  struct task_struct * _147;
  unsigned int _149;
  unsigned int _152;
  struct sighand_struct * _154;
  struct raw_spinlock * _155;
  int _157;
  struct sighand_struct * _159;
  int _161;
  void * prephitmp_163;
  long unsigned int _165;
  struct signal_struct * _175;
  unsigned int _176;
  unsigned int _177;
  struct signal_struct * _178;
  struct signal_struct * _179;
  struct signal_struct * _181;
  struct tty_struct * _182;
  struct tty_struct * _183;
  struct task_struct * _184;
  struct list_head * _185;
  struct list_head * _186;
  struct signal_struct * _188;
  int _189;
  int _190;
  struct signal_struct * _192;
  struct atomic_t * _193;
  struct signal_struct * _195;
  struct atomic_t * _196;
  struct task_struct * _197;
  struct list_head * _198;
  struct signal_struct * _199;
  struct list_head * _200;
  struct list_head * _201;
  struct sighand_struct * _207;
  struct io_context * _210;
  struct mm_struct * _211;
  struct signal_struct * _212;
  struct sighand_struct * _213;
  struct mempolicy * _214;
  const struct cred * _216;
  struct user_struct * _217;
  struct atomic_t * _218;
  struct task_struct * _222;
  unsigned int _420;
  unsigned int _424;
  long unsigned int prephitmp_425;
  struct signal_struct * _426;
  long long unsigned int _427;
  struct list_head * _429;
  long long int _430;
  u64 _431;
  u64 _433;
  _Bool _435;
  int _438;
  struct task_struct * _440;
  struct pid * _441;
  struct task_struct * _442;
  struct pid * _443;
  unsigned int _444;
  int _445;
  struct list_head * _450;
  struct list_head * _451;
  long long unsigned int _452;
  struct list_head * _453;
  long long unsigned int _454;
  struct list_head * _455;
  long long unsigned int _456;
  struct task_delay_info * _457;
  long long unsigned int _460;
  void * _467;
  long long unsigned int _471;
  int _474;
  unsigned int _478;
  unsigned int _482;
  long unsigned int pretmp_592;
  void * pretmp_598;
  long unsigned int pretmp_599;
  long unsigned int prephitmp_600;
  void * pretmp_601;
  void * pretmp_603;
  long int pretmp_606;
  long unsigned int prephitmp_607;
  long int pretmp_610;
  void * prephitmp_611;
  void * pretmp_612;
  long int pretmp_614;
  int _643;

  <bb 2>:
  _9 = clone_flags_8(D) & 8388608;
  if (_9 == 0)
    goto <bb 3>;
  else
    goto <bb 8>;

  <bb 3>:
  _10 = clone_flags_8(D) & 16384;
  if (_10 != 0)
    goto <bb 6>;
  else
    goto <bb 4>;

  <bb 4>:
  _11 = clone_flags_8(D) & 255;
  if (_11 != 17)
    goto <bb 6>;
  else
    goto <bb 5>;

  <bb 5>:

  <bb 6>:
  # trace_1 = PHI <2(3), 3(4), 1(5)>
  # prephitmp_15 = PHI <32(3), 64(4), 16(5)>
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___46 : "p" &current_task);
  _420 = pfo_ret___46->ptrace;
  _424 = prephitmp_15 & _420;
  if (_424 == 0)
    goto <bb 8>;
  else
    goto <bb 7>;

  <bb 7>:

  <bb 8>:
  # trace_2 = PHI <0(2), trace_1(7), 0(6)>
  cgrp_ss_priv = {};
  _47 = clone_flags_8(D) & 131584;
  if (_47 == 131584)
    goto <bb 131>;
  else
    goto <bb 9>;

  <bb 9>:
  _48 = clone_flags_8(D) & 268435968;
  if (_48 == 268435968)
    goto <bb 131>;
  else
    goto <bb 10>;

  <bb 10>:
  _49 = clone_flags_8(D) & 67584;
  if (_49 == 65536)
    goto <bb 131>;
  else
    goto <bb 11>;

  <bb 11>:
  _50 = clone_flags_8(D) & 2304;
  if (_50 == 2048)
    goto <bb 131>;
  else
    goto <bb 12>;

  <bb 12>:
  _51 = clone_flags_8(D) & 32768;
  if (_51 != 0)
    goto <bb 13>;
  else
    goto <bb 14>;

  <bb 13>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___52 : "p" &current_task);
  _53 = pfo_ret___52->signal;
  _54 = _53->flags;
  _55 = _54 & 64;
  if (_55 != 0)
    goto <bb 131>;
  else
    goto <bb 14>;

  <bb 14>:
  _56 = clone_flags_8(D) & 65536;
  if (_56 != 0)
    goto <bb 16>;
  else
    goto <bb 15>;

  <bb 15>:
  retval_63 = security_task_create (clone_flags_8(D));
  if (retval_63 != 0)
    goto <bb 18>;
  else
    goto <bb 19>;

  <bb 16>:
  _57 = clone_flags_8(D) & 805306368;
  if (_57 != 0)
    goto <bb 131>;
  else
    goto <bb 17>;

  <bb 17>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___58 : "p" &current_task);
  _59 = task_active_pid_ns (pfo_ret___58);
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___60 : "p" &current_task);
  _61 = pfo_ret___60->nsproxy;
  _62 = _61->pid_ns_for_children;
  if (_59 != _62)
    goto <bb 131>;
  else
    goto <bb 15>;

  <bb 18>:
  pretmp_610 = (long int) retval_63;
  pretmp_598 = (void *) pretmp_610;
  pretmp_599 = (long unsigned int) retval_63;
  goto <bb 107> (fork_out);

  <bb 19>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___64 : "p" &current_task);
  p_65 = dup_task_struct (pfo_ret___64);
  if (p_65 == 0B)
    goto <bb 107> (fork_out);
  else
    goto <bb 20>;

  <bb 20>:
  p_65->pi_lock.raw_lock.val.counter = 0;
  p_65->pi_waiters.rb_node = 0B;
  p_65->pi_waiters_leftmost = 0B;
  p_65->pi_blocked_on = 0B;
  _66 = p_65->real_cred;
  _67 = _66->user;
  _68 ={v} MEM[(const int *)_67 + 4B];
  _69 = (long unsigned int) _68;
  _426 = MEM[(const struct task_struct *)p_65].signal;
  _427 ={v} MEM[(volatile __u64 *)_426].rlim[6].rlim_cur;
  if (_69 >= _427)
    goto <bb 22>;
  else
    goto <bb 21>;

  <bb 21>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___75 : "p" &current_task);
  _76 = pfo_ret___75->flags;
  _77 = _76 & 4294963199;
  pfo_ret___75->flags = _77;
  retval_78 = copy_creds (p_65, clone_flags_8(D));
  if (retval_78 < 0)
    goto <bb 25>;
  else
    goto <bb 26>;

  <bb 22>:
  if (_67 != &root_user)
    goto <bb 23>;
  else
    goto <bb 21>;

  <bb 23>:
  _73 = capable (24);
  if (_73 != 0)
    goto <bb 21>;
  else
    goto <bb 24>;

  <bb 24>:
  _74 = capable (21);
  if (_74 != 0)
    goto <bb 21>;
  else
    goto <bb 106> (bad_fork_free);

  <bb 25>:
  pretmp_606 = (long int) retval_78;
  pretmp_603 = (void *) pretmp_606;
  pretmp_122 = (long unsigned int) retval_78;
  goto <bb 106> (bad_fork_free);

  <bb 26>:
  nr_threads.42_79 = nr_threads;
  max_threads.43_80 = max_threads;
  if (nr_threads.42_79 >= max_threads.43_80)
    goto <bb 105> (bad_fork_cleanup_count);
  else
    goto <bb 27>;

  <bb 27>:
  p_65->delays = 0B;
  delayacct_on.53_428 = delayacct_on;
  if (delayacct_on.53_428 != 0)
    goto <bb 28>;
  else
    goto <bb 29>;

  <bb 28>:
  __delayacct_tsk_init (p_65);

  <bb 29>:
  _81 = p_65->flags;
  _82 = _81 & 4294967007;
  _83 = _82 | 64;
  p_65->flags = _83;
  _84 = &p_65->children;
  MEM[(struct list_head *)p_65 + 1056B].next = _84;
  MEM[(struct list_head *)p_65 + 1056B].prev = _84;
  _85 = &p_65->sibling;
  MEM[(struct list_head *)p_65 + 1072B].next = _85;
  MEM[(struct list_head *)p_65 + 1072B].prev = _85;
  p_65->vfork_done = 0B;
  p_65->alloc_lock.D.5408.rlock.raw_lock.val.counter = 0;
  MEM[(struct sigset_t *)p_65 + 1584B].sig[0] = 0;
  _429 = &MEM[(struct sigpending *)p_65 + 1568B].list;
  MEM[(struct list_head *)p_65 + 1568B].next = _429;
  MEM[(struct list_head *)p_65 + 1568B].prev = _429;
  p_65->gtime = 0;
  p_65->stime = 0;
  p_65->utime = 0;
  p_65->stimescaled = 0;
  p_65->utimescaled = 0;
  MEM[(struct prev_cputime *)p_65 + 1296B].stime = 0;
  MEM[(struct prev_cputime *)p_65 + 1296B].utime = 0;
  MEM[(struct prev_cputime *)p_65 + 1296B].lock.raw_lock.val.counter = 0;
  _88 = &p_65->rss_stat;
  memset (_88, 0, 16);
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___89 : "p" &current_task);
  _90 = pfo_ret___89->timer_slack_ns;
  p_65->default_timer_slack_ns = _90;
  _91 = &p_65->ioac;
  memset (_91, 0, 56);
  acct_clear_integrals (p_65);
  posix_cpu_timers_init (p_65);
  D.55666 = ktime_get ();
  _430 = D.55666.tv64;
  _431 = (u64) _430;
  p_65->start_time = _431;
  D.55669 = ktime_get_with_offset (1);
  SR.313_432 = MEM[(union ktime *)&D.55669];
  _433 = (u64) SR.313_432;
  p_65->real_start_time = _433;
  p_65->io_context = 0B;
  p_65->audit_context = 0B;
  if (_56 != 0)
    goto <bb 30>;
  else
    goto <bb 31>;

  <bb 30>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___94 : "p" &current_task);
  _cond_resched ();
  cgroup_threadgroup_change_begin (pfo_ret___94);

  <bb 31>:
  cgroup_fork (p_65);
  pol_95 = p_65->mempolicy;
  if (pol_95 != 0B)
    goto <bb 32>;
  else
    goto <bb 34>;

  <bb 32>:
  pol_434 = __mpol_dup (pol_95);
  p_65->mempolicy = pol_434;
  ptr.74_97 = (long unsigned int) pol_434;
  if (ptr.74_97 > 18446744073709547520)
    goto <bb 33>;
  else
    goto <bb 34>;

  <bb 33>:
  _101 = (long int) pol_434;
  retval_102 = (int) _101;
  p_65->mempolicy = 0B;
  goto <bb 100> (bad_fork_cleanup_threadgroup_lock);

  <bb 34>:
  p_65->cpuset_mem_spread_rotor = -1;
  p_65->cpuset_slab_spread_rotor = -1;
  MEM[(struct seqcount_t *)p_65 + 1872B].sequence = 0;
  p_65->pagefault_disabled = 0;
  retval_104 = sched_fork (clone_flags_8(D), p_65);
  if (retval_104 != 0)
    goto <bb 98> (bad_fork_cleanup_policy);
  else
    goto <bb 35>;

  <bb 35>:
  retval_105 = perf_event_init_task (p_65);
  if (retval_105 != 0)
    goto <bb 98> (bad_fork_cleanup_policy);
  else
    goto <bb 36>;

  <bb 36>:
  retval_106 = audit_alloc (p_65);
  if (retval_106 != 0)
    goto <bb 97> (bad_fork_cleanup_perf);
  else
    goto <bb 37>;

  <bb 37>:
  _107 = &p_65->sysvshm.shm_clist;
  MEM[(struct list_head *)p_65 + 1488B].next = _107;
  MEM[(struct list_head *)p_65 + 1488B].prev = _107;
  retval_108 = copy_semundo (clone_flags_8(D), p_65);
  if (retval_108 != 0)
    goto <bb 96> (bad_fork_cleanup_audit);
  else
    goto <bb 38>;

  <bb 38>:
  retval_109 = copy_files (clone_flags_8(D), p_65);
  if (retval_109 != 0)
    goto <bb 95> (bad_fork_cleanup_semundo);
  else
    goto <bb 39>;

  <bb 39>:
  retval_110 = copy_fs (clone_flags_8(D), p_65);
  if (retval_110 != 0)
    goto <bb 94> (bad_fork_cleanup_files);
  else
    goto <bb 40>;

  <bb 40>:
  retval_111 = copy_sighand (clone_flags_8(D), p_65);
  if (retval_111 != 0)
    goto <bb 93> (bad_fork_cleanup_fs);
  else
    goto <bb 41>;

  <bb 41>:
  retval_112 = copy_signal (clone_flags_8(D), p_65);
  if (retval_112 != 0)
    goto <bb 92> (bad_fork_cleanup_sighand);
  else
    goto <bb 42>;

  <bb 42>:
  retval_113 = copy_mm (clone_flags_8(D), p_65);
  if (retval_113 != 0)
    goto <bb 90> (bad_fork_cleanup_signal);
  else
    goto <bb 43>;

  <bb 43>:
  retval_114 = copy_namespaces (clone_flags_8(D), p_65);
  if (retval_114 != 0)
    goto <bb 88> (bad_fork_cleanup_mm);
  else
    goto <bb 44>;

  <bb 44>:
  retval_115 = copy_io (clone_flags_8(D), p_65);
  if (retval_115 != 0)
    goto <bb 87> (bad_fork_cleanup_namespaces);
  else
    goto <bb 45>;

  <bb 45>:
  retval_116 = copy_thread_tls (clone_flags_8(D), stack_start_17(D), stack_size_18(D), p_65, tls_20(D));
  if (retval_116 != 0)
    goto <bb 85> (bad_fork_cleanup_io);
  else
    goto <bb 46>;

  <bb 46>:
  if (&init_struct_pid != 0B)
    goto <bb 47>;
  else
    goto <bb 49>;

  <bb 47>:
  _117 = p_65->nsproxy;
  _118 = _117->pid_ns_for_children;
  pid_119 = alloc_pid (_118);
  ptr.74_120 = (long unsigned int) pid_119;
  if (ptr.74_120 > 18446744073709547520)
    goto <bb 48>;
  else
    goto <bb 49>;

  <bb 48>:
  _124 = (long int) pid_119;
  retval_125 = (int) _124;
  goto <bb 85> (bad_fork_cleanup_io);

  <bb 49>:
  # pid_132 = PHI <0B(46), pid_119(47)>
  _126 = clone_flags_8(D) & 16777216;
  if (_126 != 0)
    goto <bb 51>;
  else
    goto <bb 50>;

  <bb 50>:

  <bb 51>:
  # iftmp.44_127 = PHI <0B(50), child_tidptr_19(D)(49)>
  p_65->set_child_tid = iftmp.44_127;
  _128 = clone_flags_8(D) & 2097152;
  if (_128 != 0)
    goto <bb 53>;
  else
    goto <bb 52>;

  <bb 52>:

  <bb 53>:
  # iftmp.45_129 = PHI <0B(52), child_tidptr_19(D)(51)>
  p_65->clear_child_tid = iftmp.45_129;
  p_65->plug = 0B;
  p_65->robust_list = 0B;
  p_65->compat_robust_list = 0B;
  _130 = &p_65->pi_state_list;
  MEM[(struct list_head *)p_65 + 1928B].next = _130;
  MEM[(struct list_head *)p_65 + 1928B].prev = _130;
  p_65->pi_state_cache = 0B;
  _131 = clone_flags_8(D) & 16640;
  if (_131 == 256)
    goto <bb 54>;
  else
    goto <bb 55>;

  <bb 54>:
  p_65->sas_ss_size = 0;
  p_65->sas_ss_sp = 0;

  <bb 55>:
  user_disable_single_step (p_65);
  clear_tsk_thread_flag (p_65, 0);
  clear_tsk_thread_flag (p_65, 6);
  if (pid_132 != 0B)
    goto <bb 56>;
  else
    goto <bb 57>;

  <bb 56>:
  nr_436 = pid_132->numbers[0].nr;

  <bb 57>:
  # nr_437 = PHI <0(55), nr_436(56)>
  p_65->pid = nr_437;
  if (_56 != 0)
    goto <bb 58>;
  else
    goto <bb 59>;

  <bb 58>:
  p_65->exit_signal = -1;
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___134 : "p" &current_task);
  _135 = pfo_ret___134->group_leader;
  p_65->group_leader = _135;
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___136 : "p" &current_task);
  _137 = pfo_ret___136->tgid;
  p_65->tgid = _137;
  goto <bb 63>;

  <bb 59>:
  if (_51 != 0)
    goto <bb 60>;
  else
    goto <bb 61>;

  <bb 60>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___138 : "p" &current_task);
  _139 = pfo_ret___138->group_leader;
  _140 = _139->exit_signal;
  p_65->exit_signal = _140;
  goto <bb 62>;

  <bb 61>:
  _141 = (int) clone_flags_8(D);
  _142 = _141 & 255;
  p_65->exit_signal = _142;

  <bb 62>:
  p_65->group_leader = p_65;
  p_65->tgid = nr_437;

  <bb 63>:
  p_65->nr_dirtied = 0;
  p_65->nr_dirtied_pause = 32;
  p_65->dirty_paused_when = 0;
  p_65->pdeath_signal = 0;
  _143 = &p_65->thread_group;
  MEM[(struct list_head *)p_65 + 1200B].next = _143;
  MEM[(struct list_head *)p_65 + 1200B].prev = _143;
  p_65->task_works = 0B;
  retval_144 = cgroup_can_fork (p_65, &cgrp_ss_priv);
  if (retval_144 != 0)
    goto <bb 83> (bad_fork_free_pid);
  else
    goto <bb 64>;

  <bb 64>:
  _raw_write_lock_irq (&tasklist_lock);
  _145 = clone_flags_8(D) & 98304;
  if (_145 != 0)
    goto <bb 65>;
  else
    goto <bb 66>;

  <bb 65>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___146 : "p" &current_task);
  _147 = pfo_ret___146->real_parent;
  p_65->real_parent = _147;
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___148 : "p" &current_task);
  _149 = pfo_ret___148->parent_exec_id;
  p_65->parent_exec_id = _149;
  goto <bb 67>;

  <bb 66>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___150 : "p" &current_task);
  p_65->real_parent = pfo_ret___150;
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___151 : "p" &current_task);
  _152 = pfo_ret___151->self_exec_id;
  p_65->parent_exec_id = _152;

  <bb 67>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___153 : "p" &current_task);
  _154 = pfo_ret___153->sighand;
  _155 = &MEM[(struct spinlock_t *)_154 + 2056B].D.5408.rlock;
  _raw_spin_lock (_155);
  copy_seccomp (p_65);
  recalc_sigpending ();
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___156 : "p" &current_task);
  _157 = signal_pending (pfo_ret___156);
  if (_157 != 0)
    goto <bb 68>;
  else
    goto <bb 69>;

  <bb 68>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___158 : "p" &current_task);
  _159 = pfo_ret___158->sighand;
  __asm__ __volatile__("" :  :  : "memory");
  MEM[(volatile __u8 *)_159 + 2056B] ={v} 0;
  __asm__ __volatile__("" :  :  : "memory");
  __asm__ __volatile__("" :  :  : "memory");
  MEM[(volatile __u8 *)&tasklist_lock] ={v} 0;
  __asm__ __volatile__("sti" :  :  : "memory");
  __asm__ __volatile__("" :  :  : "memory");
  cgroup_cancel_fork (p_65, &cgrp_ss_priv);
  goto <bb 83> (bad_fork_free_pid);

  <bb 69>:
  _161 = p_65->pid;
  if (_161 != 0)
    goto <bb 70>;
  else
    goto <bb 80>;

  <bb 70>:
  _165 = clone_flags_8(D) & 8192;
  if (_165 != 0)
    goto <bb 72>;
  else
    goto <bb 71>;

  <bb 71>:
  _435 = trace_2 != 0;
  _643 = (int) _435;

  <bb 72>:
  # iftmp.46_166 = PHI <1(70), _643(71)>
  ptrace_init_task (p_65, iftmp.46_166);
  p_65->pids[0].pid = pid_132;
  _438 = p_65->exit_signal;
  if (_438 >= 0)
    goto <bb 73>;
  else
    goto <bb 78>;

  <bb 73>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___169 : "p" &current_task);
  _440 = pfo_ret___169->group_leader;
  _441 = _440->pids[1].pid;
  p_65->pids[1].pid = _441;
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___171 : "p" &current_task);
  _442 = pfo_ret___171->group_leader;
  _443 = _442->pids[2].pid;
  p_65->pids[2].pid = _443;
  _444 = pid_132->level;
  _445 = pid_132->numbers[_444].nr;
  if (_445 == 1)
    goto <bb 74>;
  else
    goto <bb 77>;

  <bb 74>:
  if (pid_132 != 0B)
    goto <bb 75>;
  else
    goto <bb 76>;

  <bb 75>:
  ns_448 = pid_132->numbers[_444].ns;

  <bb 76>:
  # ns_449 = PHI <0B(74), ns_448(75)>
  ns_449->child_reaper = p_65;
  _175 = p_65->signal;
  _176 = _175->flags;
  _177 = _176 | 64;
  _175->flags = _177;

  <bb 77>:
  _178 = p_65->signal;
  _178->leader_pid = pid_132;
  _179 = p_65->signal;
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___180 : "p" &current_task);
  _181 = pfo_ret___180->signal;
  _182 = _181->tty;
  _183 = tty_kref_get (_182);
  _179->tty = _183;
  _184 = p_65->real_parent;
  _185 = &_184->children;
  _450 = MEM[(struct list_head *)_184 + 1056B].prev;
  MEM[(struct list_head *)_184 + 1056B].prev = _85;
  MEM[(struct list_head *)p_65 + 1072B].next = _185;
  MEM[(struct list_head *)p_65 + 1072B].prev = _450;
  _450->next = _85;
  _186 = &p_65->tasks;
  _451 = MEM[(struct list_head *)&init_task + 792B].prev;
  MEM[(struct list_head *)p_65 + 792B].next = &init_task.tasks;
  MEM[(struct list_head *)p_65 + 792B].prev = _451;
  __asm__ __volatile__("" :  :  : "memory");
  _452 = (long long unsigned int) _186;
  MEM[(volatile __u64 *)_451] ={v} _452;
  MEM[(struct list_head *)&init_task + 792B].prev = _186;
  attach_pid (p_65, 1);
  attach_pid (p_65, 2);
  __asm__("incq %%gs:%0" : "=m" process_counts : "m" process_counts);
  goto <bb 79>;

  <bb 78>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___187 : "p" &current_task);
  _188 = pfo_ret___187->signal;
  _189 = _188->nr_threads;
  _190 = _189 + 1;
  _188->nr_threads = _190;
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___191 : "p" &current_task);
  _192 = pfo_ret___191->signal;
  _193 = &_192->live;
  __asm__ __volatile__(".pushsection .smp_locks,"a"
.balign 4
.long 671f - .
.popsection
671:
	lock; incl %0" : "=m" _193->counter : "m" _193->counter);
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___194 : "p" &current_task);
  _195 = pfo_ret___194->signal;
  _196 = &_195->sigcnt;
  __asm__ __volatile__(".pushsection .smp_locks,"a"
.balign 4
.long 671f - .
.popsection
671:
	lock; incl %0" : "=m" _196->counter : "m" _196->counter);
  _197 = p_65->group_leader;
  _198 = &_197->thread_group;
  _453 = MEM[(struct list_head *)_197 + 1200B].prev;
  MEM[(struct list_head *)p_65 + 1200B].next = _198;
  MEM[(struct list_head *)p_65 + 1200B].prev = _453;
  __asm__ __volatile__("" :  :  : "memory");
  _454 = (long long unsigned int) _143;
  MEM[(volatile __u64 *)_453] ={v} _454;
  MEM[(struct list_head *)_197 + 1200B].prev = _143;
  _199 = p_65->signal;
  _200 = &_199->thread_head;
  _201 = &p_65->thread_node;
  _455 = MEM[(struct list_head *)_199 + 16B].prev;
  MEM[(struct list_head *)p_65 + 1216B].next = _200;
  MEM[(struct list_head *)p_65 + 1216B].prev = _455;
  __asm__ __volatile__("" :  :  : "memory");
  _456 = (long long unsigned int) _201;
  MEM[(volatile __u64 *)_455] ={v} _456;
  MEM[(struct list_head *)_199 + 16B].prev = _201;

  <bb 79>:
  attach_pid (p_65, 0);
  nr_threads.42_202 = nr_threads;
  nr_threads.47_203 = nr_threads.42_202 + 1;
  nr_threads = nr_threads.47_203;

  <bb 80>:
  total_forks.48_204 = total_forks;
  total_forks.49_205 = total_forks.48_204 + 1;
  total_forks = total_forks.49_205;
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___206 : "p" &current_task);
  _207 = pfo_ret___206->sighand;
  __asm__ __volatile__("" :  :  : "memory");
  MEM[(volatile __u8 *)_207 + 2056B] ={v} 0;
  __asm__ __volatile__("" :  :  : "memory");
  syscall_tracepoint_update (p_65);
  __asm__ __volatile__("" :  :  : "memory");
  MEM[(volatile __u8 *)&tasklist_lock] ={v} 0;
  __asm__ __volatile__("sti" :  :  : "memory");
  __asm__ __volatile__("" :  :  : "memory");
  proc_fork_connector (p_65);
  cgroup_post_fork (p_65, &cgrp_ss_priv);
  if (_56 != 0)
    goto <bb 81>;
  else
    goto <bb 82>;

  <bb 81>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___209 : "p" &current_task);
  cgroup_threadgroup_change_end (pfo_ret___209);

  <bb 82>:
  perf_event_fork (p_65);
  trace_task_newtask (p_65, clone_flags_8(D));
  pretmp_16 = (long unsigned int) p_65;
  goto <bb 108>;

  # retval_223 = PHI <retval_144(63), -513(68)>
bad_fork_free_pid:
  if (pid_132 != &init_struct_pid)
    goto <bb 84>;
  else
    goto <bb 85> (bad_fork_cleanup_io);

  <bb 84>:
  free_pid (pid_132);

  # retval_224 = PHI <retval_116(45), retval_125(48), retval_223(83), retval_223(84)>
bad_fork_cleanup_io:
  _210 = p_65->io_context;
  if (_210 != 0B)
    goto <bb 86>;
  else
    goto <bb 87> (bad_fork_cleanup_namespaces);

  <bb 86>:
  exit_io_context (p_65);

  # retval_225 = PHI <retval_115(44), retval_224(85), retval_224(86)>
bad_fork_cleanup_namespaces:
  exit_task_namespaces (p_65);

  # retval_226 = PHI <retval_114(43), retval_225(87)>
bad_fork_cleanup_mm:
  _211 = p_65->mm;
  if (_211 != 0B)
    goto <bb 89>;
  else
    goto <bb 90> (bad_fork_cleanup_signal);

  <bb 89>:
  mmput (_211);

  # retval_227 = PHI <retval_113(42), retval_226(88), retval_226(89)>
bad_fork_cleanup_signal:
  if (_56 == 0)
    goto <bb 91>;
  else
    goto <bb 92> (bad_fork_cleanup_sighand);

  <bb 91>:
  _212 = p_65->signal;
  free_signal_struct (_212);

  # retval_228 = PHI <retval_112(41), retval_227(90), retval_227(91)>
bad_fork_cleanup_sighand:
  _213 = p_65->sighand;
  __cleanup_sighand (_213);

  # retval_229 = PHI <retval_111(40), retval_228(92)>
bad_fork_cleanup_fs:
  exit_fs (p_65);

  # retval_230 = PHI <retval_110(39), retval_229(93)>
bad_fork_cleanup_files:
  exit_files (p_65);

  # retval_231 = PHI <retval_109(38), retval_230(94)>
bad_fork_cleanup_semundo:
  exit_sem (p_65);

  # retval_232 = PHI <retval_108(37), retval_231(95)>
bad_fork_cleanup_audit:
  audit_free (p_65);

  # retval_233 = PHI <retval_106(36), retval_232(96)>
bad_fork_cleanup_perf:
  perf_event_free_task (p_65);

  # retval_234 = PHI <retval_104(34), retval_105(35), retval_233(97)>
bad_fork_cleanup_policy:
  _214 = p_65->mempolicy;
  if (_214 != 0B)
    goto <bb 99>;
  else
    goto <bb 100> (bad_fork_cleanup_threadgroup_lock);

  <bb 99>:
  __mpol_put (_214);

  # retval_235 = PHI <retval_102(33), retval_234(99), retval_234(98)>
bad_fork_cleanup_threadgroup_lock:
  if (_56 != 0)
    goto <bb 101>;
  else
    goto <bb 102>;

  <bb 101>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___215 : "p" &current_task);
  cgroup_threadgroup_change_end (pfo_ret___215);

  <bb 102>:
  _457 = p_65->delays;
  if (_457 != 0B)
    goto <bb 103>;
  else
    goto <bb 104>;

  <bb 103>:
  delayacct_cache.20_458 = delayacct_cache;
  kmem_cache_free (delayacct_cache.20_458, _457);

  <bb 104>:
  p_65->delays = 0B;
  pretmp_98 = (long int) retval_235;
  pretmp_601 = (void *) pretmp_98;
  pretmp_592 = (long unsigned int) retval_235;

  # prephitmp_99 = PHI <-11B(26), pretmp_601(104)>
  # prephitmp_14 = PHI <18446744073709551605(26), pretmp_592(104)>
bad_fork_cleanup_count:
  _216 = p_65->cred;
  _217 = _216->user;
  _218 = &_217->processes;
  __asm__ __volatile__(".pushsection .smp_locks,"a"
.balign 4
.long 671f - .
.popsection
671:
	lock; decl %0" : "=m" _218->counter : "m" _218->counter);
  exit_creds (p_65);

  # prephitmp_123 = PHI <-11B(24), pretmp_603(25), prephitmp_99(105)>
  # prephitmp_600 = PHI <18446744073709551605(24), pretmp_122(25), prephitmp_14(105)>
bad_fork_free:
  free_task (p_65);

  # prephitmp_163 = PHI <pretmp_598(18), -12B(19), prephitmp_123(106)>
  # prephitmp_607 = PHI <pretmp_599(18), 18446744073709551604(19), prephitmp_600(106)>
fork_out:

  <bb 108>:
  # _222 = PHI <prephitmp_163(107), p_65(82)>
  # prephitmp_425 = PHI <prephitmp_607(107), pretmp_16(82)>
  cgrp_ss_priv ={v} {CLOBBER};
  if (prephitmp_425 <= 18446744073709547520)
    goto <bb 109>;
  else
    goto <bb 128>;

  <bb 109>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___242 : "p" &current_task);
  __asm__ __volatile__ goto("1:.byte 0x0f,0x1f,0x44,0x00,0
	.pushsection __jump_table,  "aw" 
	 .balign 8 
	 .quad 1b, %l2, %c0 + %c1 
	.popsection 
	" :  : "i" &__tracepoint_sched_process_fork.key, "i" 0 :  : "l_yes" <L48>);

  <bb 110>:
  __asm__ __volatile__("");
  goto <bb 114>;

  <bb 111>:

  <bb 112>:
  # it_func_ptr_462 = PHI <it_func_ptr_461(133), it_func_ptr_466(111)>
  # prephitmp_611 = PHI <pretmp_612(133), _467(111)>
  __data_464 = MEM[base: it_func_ptr_462, offset: 8B];
  it_func.78_465 = (void (*<T6b5e>) (void *, struct task_struct *, struct task_struct *)) prephitmp_611;
  it_func.78_465 (__data_464, pfo_ret___242, _222);
  it_func_ptr_466 = it_func_ptr_462 + 16;
  _467 = MEM[base: it_func_ptr_466, offset: 0B];
  if (_467 != 0B)
    goto <bb 111>;
  else
    goto <bb 113>;

  <bb 113>:
  __asm__ __volatile__("" :  :  : "memory");

  <bb 114>:
  pid_24 = get_task_pid (_222, 0);
  _26 = pid_vnr (pid_24);
  nr_27 = (long int) _26;
  _28 = clone_flags_8(D) & 1048576;
  if (_28 != 0)
    goto <bb 115>;
  else
    goto <bb 116>;

  <bb 115>:
  __asm__ __volatile__("call __put_user_4" : "=a" __ret_pu_30 : "0" _26, "c" parent_tidptr_29(D) : "ebx");

  <bb 116>:
  _31 = clone_flags_8(D) & 16384;
  if (_31 != 0)
    goto <bb 117>;
  else
    goto <bb 118>;

  <bb 117>:
  _222->vfork_done = &vfork;
  vfork.done = 0;
  __init_waitqueue_head (&vfork.wait, "&x->wait", &__key);
  _34 = &_222->usage;
  __asm__ __volatile__(".pushsection .smp_locks,"a"
.balign 4
.long 671f - .
.popsection
671:
	lock; incl %0" : "=m" _34->counter : "m" _34->counter);

  <bb 118>:
  wake_up_new_task (_222);
  if (trace_2 != 0)
    goto <bb 119>;
  else
    goto <bb 120>;

  <bb 119>:
  ptrace_event_pid (trace_2, pid_24);

  <bb 120>:
  if (_31 != 0)
    goto <bb 122>;
  else
    goto <bb 121>;

  <bb 121>:
  goto <bb 127>;

  <bb 122>:
  _42 = wait_for_vfork_done (_222, &vfork);
  if (_42 == 0)
    goto <bb 123>;
  else
    goto <bb 121>;

  <bb 123>:
  __asm__ __volatile__("" :  :  : "memory");
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___470 : "p" &current_task);
  _471 ={v} MEM[(volatile __u64 *)pfo_ret___470 + 1048B];
  ________p1_472 = (struct task_struct *) _471;
  ns_473 = task_active_pid_ns (________p1_472);
  if (ns_473 != 0B)
    goto <bb 124>;
  else
    goto <bb 125>;

  <bb 124>:
  _474 = pid_nr_ns (pid_24, ns_473);
  message_475 = (long unsigned int) _474;

  <bb 125>:
  # message_476 = PHI <0(123), message_475(124)>
  __asm__ __volatile__("" :  :  : "memory");
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___477 : "p" &current_task);
  _478 = pfo_ret___477->ptrace;
  _482 = _478 & 256;
  if (_482 != 0)
    goto <bb 126>;
  else
    goto <bb 121>;

  <bb 126>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___486 : "p" &current_task);
  pfo_ret___486->ptrace_message = message_476;
  ptrace_notify (1285);

  <bb 127>:
  put_pid (pid_24);
  vfork ={v} {CLOBBER};
  goto <bb 130>;

  <bb 128>:
  pretmp_614 = (long int) _222;

  <bb 129>:
  # nr_613 = PHI <pretmp_614(128), -22(131)>

  <bb 130>:
  # nr_3 = PHI <nr_27(127), nr_613(129)>
  return nr_3;

  <bb 131>:
  cgrp_ss_priv ={v} {CLOBBER};
  goto <bb 129>;

<L48>:
  __asm__ __volatile__("" :  :  : "memory");
  _460 ={v} MEM[(volatile __u64 *)&__tracepoint_sched_process_fork + 48B];
  it_func_ptr_461 = (struct tracepoint_func *) _460;
  if (it_func_ptr_461 != 0B)
    goto <bb 133>;
  else
    goto <bb 113>;

  <bb 133>:
  pretmp_612 = it_func_ptr_461->func;
  goto <bb 112>;

}



;; Function kernel_thread (kernel_thread, funcdef_no=3660, decl_uid=24917, cgraph_uid=3661)

kernel_thread (int (*<T2fa9>) (void *) fn, void * arg, long unsigned int flags)
{
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * ________p1;
  struct pid_namespace * ns;
  long unsigned int message;
  static struct lock_class_key __key;
  void (*<T6b5e>) (void *, struct task_struct *, struct task_struct *) it_func.78;
  struct tracepoint_func * it_func_ptr;
  void * __data;
  struct kmem_cache * delayacct_cache.20;
  struct pid_namespace * ns;
  pid_t nr;
  struct mempolicy * pol;
  union ktime_t D.55832;
  s64 SR.313;
  union ktime D.55829;
  int delayacct_on.53;
  struct completion vfork;
  struct pid * pid;
  int __ret_pu;
  struct pid * pid;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  long unsigned int ptr.74;
  long unsigned int ptr.74;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  void * cgrp_ss_priv[0:];
  struct task_struct * p;
  int retval;
  long unsigned int total_forks.49;
  long unsigned int total_forks.48;
  int nr_threads.47;
  int max_threads.43;
  int nr_threads.42;
  struct task_struct * pfo_ret__;
  long unsigned int fn.84;
  long unsigned int arg.83;
  long unsigned int _6;
  long unsigned int _10;
  long unsigned int _11;
  long unsigned int _12;
  long unsigned int _13;
  struct signal_struct * _15;
  unsigned int _16;
  unsigned int _17;
  long unsigned int _18;
  long unsigned int _19;
  struct pid_namespace * _21;
  struct nsproxy * _23;
  struct pid_namespace * _24;
  const struct cred * _28;
  struct user_struct * _29;
  int _30;
  long unsigned int _31;
  _Bool _35;
  _Bool _36;
  unsigned int _38;
  unsigned int _39;
  unsigned int _43;
  unsigned int _44;
  unsigned int _45;
  struct list_head * _46;
  struct list_head * _47;
  struct task_rss_stat * _50;
  long unsigned int _52;
  struct task_io_accounting * _53;
  long unsigned int prephitmp_60;
  long int pretmp_61;
  long int _63;
  struct list_head * _69;
  struct nsproxy * _79;
  struct pid_namespace * _80;
  void * prephitmp_84;
  long unsigned int pretmp_85;
  long int _86;
  struct list_head * _90;
  long unsigned int _91;
  struct task_struct * _95;
  int _97;
  struct task_struct * _99;
  int _100;
  int _101;
  int _102;
  struct list_head * _103;
  long unsigned int _105;
  struct task_struct * _107;
  unsigned int _109;
  unsigned int _112;
  struct sighand_struct * _114;
  struct raw_spinlock * _115;
  int _117;
  struct sighand_struct * _119;
  void * pretmp_120;
  int _121;
  long unsigned int pretmp_123;
  long int pretmp_124;
  long unsigned int _125;
  struct signal_struct * _135;
  unsigned int _136;
  unsigned int _137;
  struct signal_struct * _138;
  struct signal_struct * _139;
  struct signal_struct * _141;
  struct tty_struct * _142;
  struct tty_struct * _143;
  struct task_struct * _144;
  struct list_head * _145;
  struct list_head * _146;
  struct signal_struct * _148;
  int _149;
  int _150;
  struct signal_struct * _152;
  struct atomic_t * _153;
  struct signal_struct * _155;
  struct atomic_t * _156;
  struct task_struct * _157;
  struct list_head * _158;
  struct signal_struct * _159;
  struct list_head * _160;
  struct list_head * _161;
  struct sighand_struct * _167;
  struct io_context * _170;
  struct mm_struct * _171;
  struct signal_struct * _172;
  struct sighand_struct * _173;
  struct mempolicy * _174;
  const struct cred * _176;
  struct user_struct * _177;
  struct atomic_t * _178;
  struct task_struct * _182;
  int _189;
  long unsigned int _191;
  long unsigned int _193;
  struct atomic_t * _194;
  int _195;
  long unsigned int _242;
  struct signal_struct * _401;
  long long unsigned int _402;
  struct list_head * _404;
  long long int _405;
  u64 _406;
  u64 _408;
  _Bool _410;
  int _413;
  struct task_struct * _415;
  struct pid * _416;
  struct task_struct * _417;
  struct pid * _418;
  unsigned int _419;
  int _420;
  struct list_head * _425;
  struct list_head * _426;
  long long unsigned int _427;
  struct list_head * _428;
  long long unsigned int _429;
  struct list_head * _430;
  long long unsigned int _431;
  struct task_delay_info * _432;
  long long unsigned int _435;
  void * _442;
  long long unsigned int _446;
  int _449;
  unsigned int _453;
  unsigned int _457;
  void * pretmp_513;
  long int pretmp_562;
  void * prephitmp_563;
  long unsigned int prephitmp_564;
  long int pretmp_566;
  void * prephitmp_567;
  void * pretmp_568;
  pid_t prephitmp_569;
  pid_t pretmp_570;
  int _605;
  void * pretmp_612;
  void * prephitmp_613;
  long unsigned int pretmp_614;
  long unsigned int prephitmp_615;
  pid_t pretmp_616;
  pid_t prephitmp_617;
  long unsigned int pretmp_618;
  long unsigned int prephitmp_619;

  <bb 2>:
  cgrp_ss_priv = {};
  _10 = flags_5(D) & 131584;
  if (_10 == 131584)
    goto <bb 114>;
  else
    goto <bb 3>;

  <bb 3>:
  _11 = flags_5(D) & 268435968;
  if (_11 == 268435968)
    goto <bb 114>;
  else
    goto <bb 4>;

  <bb 4>:
  _12 = flags_5(D) & 67584;
  if (_12 == 65536)
    goto <bb 114>;
  else
    goto <bb 5>;

  <bb 5>:
  _13 = flags_5(D) & 32768;
  if (_13 != 0)
    goto <bb 6>;
  else
    goto <bb 7>;

  <bb 6>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___14 : "p" &current_task);
  _15 = pfo_ret___14->signal;
  _16 = _15->flags;
  _17 = _16 & 64;
  if (_17 != 0)
    goto <bb 114>;
  else
    goto <bb 7>;

  <bb 7>:
  _18 = flags_5(D) & 65536;
  if (_18 != 0)
    goto <bb 9>;
  else
    goto <bb 8>;

  <bb 8>:
  _6 = flags_5(D) | 8388864;
  retval_25 = security_task_create (_6);
  if (retval_25 != 0)
    goto <bb 11>;
  else
    goto <bb 12>;

  <bb 9>:
  _19 = flags_5(D) & 805306368;
  if (_19 != 0)
    goto <bb 114>;
  else
    goto <bb 10>;

  <bb 10>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___20 : "p" &current_task);
  _21 = task_active_pid_ns (pfo_ret___20);
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___22 : "p" &current_task);
  _23 = pfo_ret___22->nsproxy;
  _24 = _23->pid_ns_for_children;
  if (_21 != _24)
    goto <bb 114>;
  else
    goto <bb 8>;

  <bb 11>:
  pretmp_566 = (long int) retval_25;
  pretmp_513 = (void *) pretmp_566;
  pretmp_123 = (long unsigned int) retval_25;
  goto <bb 94> (fork_out);

  <bb 12>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___26 : "p" &current_task);
  p_27 = dup_task_struct (pfo_ret___26);
  if (p_27 == 0B)
    goto <bb 94> (fork_out);
  else
    goto <bb 13>;

  <bb 13>:
  p_27->pi_lock.raw_lock.val.counter = 0;
  p_27->pi_waiters.rb_node = 0B;
  p_27->pi_waiters_leftmost = 0B;
  p_27->pi_blocked_on = 0B;
  _28 = p_27->real_cred;
  _29 = _28->user;
  _30 ={v} MEM[(const int *)_29 + 4B];
  _31 = (long unsigned int) _30;
  _401 = MEM[(const struct task_struct *)p_27].signal;
  _402 ={v} MEM[(volatile __u64 *)_401].rlim[6].rlim_cur;
  if (_31 >= _402)
    goto <bb 15>;
  else
    goto <bb 14>;

  <bb 14>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___37 : "p" &current_task);
  _38 = pfo_ret___37->flags;
  _39 = _38 & 4294963199;
  pfo_ret___37->flags = _39;
  retval_40 = copy_creds (p_27, _6);
  if (retval_40 < 0)
    goto <bb 18>;
  else
    goto <bb 19>;

  <bb 15>:
  if (_29 != &root_user)
    goto <bb 16>;
  else
    goto <bb 14>;

  <bb 16>:
  _35 = capable (24);
  if (_35 != 0)
    goto <bb 14>;
  else
    goto <bb 17>;

  <bb 17>:
  _36 = capable (21);
  if (_36 != 0)
    goto <bb 14>;
  else
    goto <bb 93> (bad_fork_free);

  <bb 18>:
  pretmp_124 = (long int) retval_40;
  pretmp_120 = (void *) pretmp_124;
  pretmp_85 = (long unsigned int) retval_40;
  goto <bb 93> (bad_fork_free);

  <bb 19>:
  nr_threads.42_41 = nr_threads;
  max_threads.43_42 = max_threads;
  if (nr_threads.42_41 >= max_threads.43_42)
    goto <bb 92> (bad_fork_cleanup_count);
  else
    goto <bb 20>;

  <bb 20>:
  p_27->delays = 0B;
  delayacct_on.53_403 = delayacct_on;
  if (delayacct_on.53_403 != 0)
    goto <bb 21>;
  else
    goto <bb 22>;

  <bb 21>:
  __delayacct_tsk_init (p_27);

  <bb 22>:
  _43 = p_27->flags;
  _44 = _43 & 4294967007;
  _45 = _44 | 64;
  p_27->flags = _45;
  _46 = &p_27->children;
  MEM[(struct list_head *)p_27 + 1056B].next = _46;
  MEM[(struct list_head *)p_27 + 1056B].prev = _46;
  _47 = &p_27->sibling;
  MEM[(struct list_head *)p_27 + 1072B].next = _47;
  MEM[(struct list_head *)p_27 + 1072B].prev = _47;
  p_27->vfork_done = 0B;
  p_27->alloc_lock.D.5408.rlock.raw_lock.val.counter = 0;
  MEM[(struct sigset_t *)p_27 + 1584B].sig[0] = 0;
  _404 = &MEM[(struct sigpending *)p_27 + 1568B].list;
  MEM[(struct list_head *)p_27 + 1568B].next = _404;
  MEM[(struct list_head *)p_27 + 1568B].prev = _404;
  p_27->gtime = 0;
  p_27->stime = 0;
  p_27->utime = 0;
  p_27->stimescaled = 0;
  p_27->utimescaled = 0;
  MEM[(struct prev_cputime *)p_27 + 1296B].stime = 0;
  MEM[(struct prev_cputime *)p_27 + 1296B].utime = 0;
  MEM[(struct prev_cputime *)p_27 + 1296B].lock.raw_lock.val.counter = 0;
  _50 = &p_27->rss_stat;
  memset (_50, 0, 16);
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___51 : "p" &current_task);
  _52 = pfo_ret___51->timer_slack_ns;
  p_27->default_timer_slack_ns = _52;
  _53 = &p_27->ioac;
  memset (_53, 0, 56);
  acct_clear_integrals (p_27);
  posix_cpu_timers_init (p_27);
  D.55829 = ktime_get ();
  _405 = D.55829.tv64;
  _406 = (u64) _405;
  p_27->start_time = _406;
  D.55832 = ktime_get_with_offset (1);
  SR.313_407 = MEM[(union ktime *)&D.55832];
  _408 = (u64) SR.313_407;
  p_27->real_start_time = _408;
  p_27->io_context = 0B;
  p_27->audit_context = 0B;
  if (_18 != 0)
    goto <bb 23>;
  else
    goto <bb 24>;

  <bb 23>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___56 : "p" &current_task);
  _cond_resched ();
  cgroup_threadgroup_change_begin (pfo_ret___56);

  <bb 24>:
  cgroup_fork (p_27);
  pol_57 = p_27->mempolicy;
  if (pol_57 != 0B)
    goto <bb 25>;
  else
    goto <bb 27>;

  <bb 25>:
  pol_409 = __mpol_dup (pol_57);
  p_27->mempolicy = pol_409;
  ptr.74_59 = (long unsigned int) pol_409;
  if (ptr.74_59 > 18446744073709547520)
    goto <bb 26>;
  else
    goto <bb 27>;

  <bb 26>:
  _63 = (long int) pol_409;
  retval_64 = (int) _63;
  p_27->mempolicy = 0B;
  goto <bb 87> (bad_fork_cleanup_threadgroup_lock);

  <bb 27>:
  p_27->cpuset_mem_spread_rotor = -1;
  p_27->cpuset_slab_spread_rotor = -1;
  MEM[(struct seqcount_t *)p_27 + 1872B].sequence = 0;
  p_27->pagefault_disabled = 0;
  retval_66 = sched_fork (_6, p_27);
  if (retval_66 != 0)
    goto <bb 85> (bad_fork_cleanup_policy);
  else
    goto <bb 28>;

  <bb 28>:
  retval_67 = perf_event_init_task (p_27);
  if (retval_67 != 0)
    goto <bb 85> (bad_fork_cleanup_policy);
  else
    goto <bb 29>;

  <bb 29>:
  retval_68 = audit_alloc (p_27);
  if (retval_68 != 0)
    goto <bb 84> (bad_fork_cleanup_perf);
  else
    goto <bb 30>;

  <bb 30>:
  _69 = &p_27->sysvshm.shm_clist;
  MEM[(struct list_head *)p_27 + 1488B].next = _69;
  MEM[(struct list_head *)p_27 + 1488B].prev = _69;
  retval_70 = copy_semundo (_6, p_27);
  if (retval_70 != 0)
    goto <bb 83> (bad_fork_cleanup_audit);
  else
    goto <bb 31>;

  <bb 31>:
  retval_71 = copy_files (_6, p_27);
  if (retval_71 != 0)
    goto <bb 82> (bad_fork_cleanup_semundo);
  else
    goto <bb 32>;

  <bb 32>:
  retval_72 = copy_fs (_6, p_27);
  if (retval_72 != 0)
    goto <bb 81> (bad_fork_cleanup_files);
  else
    goto <bb 33>;

  <bb 33>:
  retval_73 = copy_sighand (_6, p_27);
  if (retval_73 != 0)
    goto <bb 80> (bad_fork_cleanup_fs);
  else
    goto <bb 34>;

  <bb 34>:
  retval_74 = copy_signal (_6, p_27);
  if (retval_74 != 0)
    goto <bb 79> (bad_fork_cleanup_sighand);
  else
    goto <bb 35>;

  <bb 35>:
  retval_75 = copy_mm (_6, p_27);
  if (retval_75 != 0)
    goto <bb 77> (bad_fork_cleanup_signal);
  else
    goto <bb 36>;

  <bb 36>:
  retval_76 = copy_namespaces (_6, p_27);
  if (retval_76 != 0)
    goto <bb 75> (bad_fork_cleanup_mm);
  else
    goto <bb 37>;

  <bb 37>:
  retval_77 = copy_io (_6, p_27);
  if (retval_77 != 0)
    goto <bb 74> (bad_fork_cleanup_namespaces);
  else
    goto <bb 38>;

  <bb 38>:
  fn.84_4 = (long unsigned int) fn_3(D);
  arg.83_2 = (long unsigned int) arg_1(D);
  retval_78 = copy_thread_tls (_6, fn.84_4, arg.83_2, p_27, 0);
  if (retval_78 != 0)
    goto <bb 72> (bad_fork_cleanup_io);
  else
    goto <bb 39>;

  <bb 39>:
  if (&init_struct_pid != 0B)
    goto <bb 40>;
  else
    goto <bb 42>;

  <bb 40>:
  _79 = p_27->nsproxy;
  _80 = _79->pid_ns_for_children;
  pid_81 = alloc_pid (_80);
  ptr.74_82 = (long unsigned int) pid_81;
  if (ptr.74_82 > 18446744073709547520)
    goto <bb 41>;
  else
    goto <bb 42>;

  <bb 41>:
  _86 = (long int) pid_81;
  retval_87 = (int) _86;
  goto <bb 72> (bad_fork_cleanup_io);

  <bb 42>:
  # pid_92 = PHI <0B(39), pid_81(40)>
  p_27->set_child_tid = 0B;
  p_27->clear_child_tid = 0B;
  p_27->plug = 0B;
  p_27->robust_list = 0B;
  p_27->compat_robust_list = 0B;
  _90 = &p_27->pi_state_list;
  MEM[(struct list_head *)p_27 + 1928B].next = _90;
  MEM[(struct list_head *)p_27 + 1928B].prev = _90;
  p_27->pi_state_cache = 0B;
  _242 = flags_5(D) & 16640;
  _91 = _242 | 256;
  if (_91 == 256)
    goto <bb 43>;
  else
    goto <bb 44>;

  <bb 43>:
  p_27->sas_ss_size = 0;
  p_27->sas_ss_sp = 0;

  <bb 44>:
  user_disable_single_step (p_27);
  clear_tsk_thread_flag (p_27, 0);
  clear_tsk_thread_flag (p_27, 6);
  if (pid_92 != 0B)
    goto <bb 45>;
  else
    goto <bb 46>;

  <bb 45>:
  nr_411 = pid_92->numbers[0].nr;

  <bb 46>:
  # nr_412 = PHI <0(44), nr_411(45)>
  p_27->pid = nr_412;
  if (_18 != 0)
    goto <bb 47>;
  else
    goto <bb 48>;

  <bb 47>:
  p_27->exit_signal = -1;
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___94 : "p" &current_task);
  _95 = pfo_ret___94->group_leader;
  p_27->group_leader = _95;
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___96 : "p" &current_task);
  _97 = pfo_ret___96->tgid;
  p_27->tgid = _97;
  goto <bb 52>;

  <bb 48>:
  if (_13 != 0)
    goto <bb 49>;
  else
    goto <bb 50>;

  <bb 49>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___98 : "p" &current_task);
  _99 = pfo_ret___98->group_leader;
  _100 = _99->exit_signal;
  p_27->exit_signal = _100;
  goto <bb 51>;

  <bb 50>:
  _101 = (int) _6;
  _102 = _101 & 255;
  p_27->exit_signal = _102;

  <bb 51>:
  p_27->group_leader = p_27;
  p_27->tgid = nr_412;

  <bb 52>:
  p_27->nr_dirtied = 0;
  p_27->nr_dirtied_pause = 32;
  p_27->dirty_paused_when = 0;
  p_27->pdeath_signal = 0;
  _103 = &p_27->thread_group;
  MEM[(struct list_head *)p_27 + 1200B].next = _103;
  MEM[(struct list_head *)p_27 + 1200B].prev = _103;
  p_27->task_works = 0B;
  retval_104 = cgroup_can_fork (p_27, &cgrp_ss_priv);
  if (retval_104 != 0)
    goto <bb 70> (bad_fork_free_pid);
  else
    goto <bb 53>;

  <bb 53>:
  _raw_write_lock_irq (&tasklist_lock);
  _105 = flags_5(D) & 98304;
  if (_105 != 0)
    goto <bb 54>;
  else
    goto <bb 55>;

  <bb 54>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___106 : "p" &current_task);
  _107 = pfo_ret___106->real_parent;
  p_27->real_parent = _107;
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___108 : "p" &current_task);
  _109 = pfo_ret___108->parent_exec_id;
  p_27->parent_exec_id = _109;
  goto <bb 56>;

  <bb 55>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___110 : "p" &current_task);
  p_27->real_parent = pfo_ret___110;
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___111 : "p" &current_task);
  _112 = pfo_ret___111->self_exec_id;
  p_27->parent_exec_id = _112;

  <bb 56>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___113 : "p" &current_task);
  _114 = pfo_ret___113->sighand;
  _115 = &MEM[(struct spinlock_t *)_114 + 2056B].D.5408.rlock;
  _raw_spin_lock (_115);
  copy_seccomp (p_27);
  recalc_sigpending ();
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___116 : "p" &current_task);
  _117 = signal_pending (pfo_ret___116);
  if (_117 != 0)
    goto <bb 57>;
  else
    goto <bb 58>;

  <bb 57>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___118 : "p" &current_task);
  _119 = pfo_ret___118->sighand;
  __asm__ __volatile__("" :  :  : "memory");
  MEM[(volatile __u8 *)_119 + 2056B] ={v} 0;
  __asm__ __volatile__("" :  :  : "memory");
  __asm__ __volatile__("" :  :  : "memory");
  MEM[(volatile __u8 *)&tasklist_lock] ={v} 0;
  __asm__ __volatile__("sti" :  :  : "memory");
  __asm__ __volatile__("" :  :  : "memory");
  cgroup_cancel_fork (p_27, &cgrp_ss_priv);
  goto <bb 70> (bad_fork_free_pid);

  <bb 58>:
  _121 = p_27->pid;
  if (_121 != 0)
    goto <bb 59>;
  else
    goto <bb 67>;

  <bb 59>:
  _125 = flags_5(D) & 8192;
  _410 = _125 != 0;
  _605 = (int) _410;
  ptrace_init_task (p_27, _605);
  p_27->pids[0].pid = pid_92;
  _413 = p_27->exit_signal;
  if (_413 >= 0)
    goto <bb 60>;
  else
    goto <bb 65>;

  <bb 60>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___129 : "p" &current_task);
  _415 = pfo_ret___129->group_leader;
  _416 = _415->pids[1].pid;
  p_27->pids[1].pid = _416;
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___131 : "p" &current_task);
  _417 = pfo_ret___131->group_leader;
  _418 = _417->pids[2].pid;
  p_27->pids[2].pid = _418;
  _419 = pid_92->level;
  _420 = pid_92->numbers[_419].nr;
  if (_420 == 1)
    goto <bb 61>;
  else
    goto <bb 64>;

  <bb 61>:
  if (pid_92 != 0B)
    goto <bb 62>;
  else
    goto <bb 63>;

  <bb 62>:
  ns_423 = pid_92->numbers[_419].ns;

  <bb 63>:
  # ns_424 = PHI <0B(61), ns_423(62)>
  ns_424->child_reaper = p_27;
  _135 = p_27->signal;
  _136 = _135->flags;
  _137 = _136 | 64;
  _135->flags = _137;

  <bb 64>:
  _138 = p_27->signal;
  _138->leader_pid = pid_92;
  _139 = p_27->signal;
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___140 : "p" &current_task);
  _141 = pfo_ret___140->signal;
  _142 = _141->tty;
  _143 = tty_kref_get (_142);
  _139->tty = _143;
  _144 = p_27->real_parent;
  _145 = &_144->children;
  _425 = MEM[(struct list_head *)_144 + 1056B].prev;
  MEM[(struct list_head *)_144 + 1056B].prev = _47;
  MEM[(struct list_head *)p_27 + 1072B].next = _145;
  MEM[(struct list_head *)p_27 + 1072B].prev = _425;
  _425->next = _47;
  _146 = &p_27->tasks;
  _426 = MEM[(struct list_head *)&init_task + 792B].prev;
  MEM[(struct list_head *)p_27 + 792B].next = &init_task.tasks;
  MEM[(struct list_head *)p_27 + 792B].prev = _426;
  __asm__ __volatile__("" :  :  : "memory");
  _427 = (long long unsigned int) _146;
  MEM[(volatile __u64 *)_426] ={v} _427;
  MEM[(struct list_head *)&init_task + 792B].prev = _146;
  attach_pid (p_27, 1);
  attach_pid (p_27, 2);
  __asm__("incq %%gs:%0" : "=m" process_counts : "m" process_counts);
  goto <bb 66>;

  <bb 65>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___147 : "p" &current_task);
  _148 = pfo_ret___147->signal;
  _149 = _148->nr_threads;
  _150 = _149 + 1;
  _148->nr_threads = _150;
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___151 : "p" &current_task);
  _152 = pfo_ret___151->signal;
  _153 = &_152->live;
  __asm__ __volatile__(".pushsection .smp_locks,"a"
.balign 4
.long 671f - .
.popsection
671:
	lock; incl %0" : "=m" _153->counter : "m" _153->counter);
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___154 : "p" &current_task);
  _155 = pfo_ret___154->signal;
  _156 = &_155->sigcnt;
  __asm__ __volatile__(".pushsection .smp_locks,"a"
.balign 4
.long 671f - .
.popsection
671:
	lock; incl %0" : "=m" _156->counter : "m" _156->counter);
  _157 = p_27->group_leader;
  _158 = &_157->thread_group;
  _428 = MEM[(struct list_head *)_157 + 1200B].prev;
  MEM[(struct list_head *)p_27 + 1200B].next = _158;
  MEM[(struct list_head *)p_27 + 1200B].prev = _428;
  __asm__ __volatile__("" :  :  : "memory");
  _429 = (long long unsigned int) _103;
  MEM[(volatile __u64 *)_428] ={v} _429;
  MEM[(struct list_head *)_157 + 1200B].prev = _103;
  _159 = p_27->signal;
  _160 = &_159->thread_head;
  _161 = &p_27->thread_node;
  _430 = MEM[(struct list_head *)_159 + 16B].prev;
  MEM[(struct list_head *)p_27 + 1216B].next = _160;
  MEM[(struct list_head *)p_27 + 1216B].prev = _430;
  __asm__ __volatile__("" :  :  : "memory");
  _431 = (long long unsigned int) _161;
  MEM[(volatile __u64 *)_430] ={v} _431;
  MEM[(struct list_head *)_159 + 16B].prev = _161;

  <bb 66>:
  attach_pid (p_27, 0);
  nr_threads.42_162 = nr_threads;
  nr_threads.47_163 = nr_threads.42_162 + 1;
  nr_threads = nr_threads.47_163;

  <bb 67>:
  total_forks.48_164 = total_forks;
  total_forks.49_165 = total_forks.48_164 + 1;
  total_forks = total_forks.49_165;
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___166 : "p" &current_task);
  _167 = pfo_ret___166->sighand;
  __asm__ __volatile__("" :  :  : "memory");
  MEM[(volatile __u8 *)_167 + 2056B] ={v} 0;
  __asm__ __volatile__("" :  :  : "memory");
  syscall_tracepoint_update (p_27);
  __asm__ __volatile__("" :  :  : "memory");
  MEM[(volatile __u8 *)&tasklist_lock] ={v} 0;
  __asm__ __volatile__("sti" :  :  : "memory");
  __asm__ __volatile__("" :  :  : "memory");
  proc_fork_connector (p_27);
  cgroup_post_fork (p_27, &cgrp_ss_priv);
  if (_18 != 0)
    goto <bb 68>;
  else
    goto <bb 69>;

  <bb 68>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___169 : "p" &current_task);
  cgroup_threadgroup_change_end (pfo_ret___169);

  <bb 69>:
  perf_event_fork (p_27);
  trace_task_newtask (p_27, _6);
  pretmp_618 = (long unsigned int) p_27;
  goto <bb 95>;

  # retval_198 = PHI <retval_104(52), -513(57)>
bad_fork_free_pid:
  if (pid_92 != &init_struct_pid)
    goto <bb 71>;
  else
    goto <bb 72> (bad_fork_cleanup_io);

  <bb 71>:
  free_pid (pid_92);

  # retval_199 = PHI <retval_78(38), retval_87(41), retval_198(70), retval_198(71)>
bad_fork_cleanup_io:
  _170 = p_27->io_context;
  if (_170 != 0B)
    goto <bb 73>;
  else
    goto <bb 74> (bad_fork_cleanup_namespaces);

  <bb 73>:
  exit_io_context (p_27);

  # retval_200 = PHI <retval_77(37), retval_199(72), retval_199(73)>
bad_fork_cleanup_namespaces:
  exit_task_namespaces (p_27);

  # retval_201 = PHI <retval_76(36), retval_200(74)>
bad_fork_cleanup_mm:
  _171 = p_27->mm;
  if (_171 != 0B)
    goto <bb 76>;
  else
    goto <bb 77> (bad_fork_cleanup_signal);

  <bb 76>:
  mmput (_171);

  # retval_202 = PHI <retval_75(35), retval_201(75), retval_201(76)>
bad_fork_cleanup_signal:
  if (_18 == 0)
    goto <bb 78>;
  else
    goto <bb 79> (bad_fork_cleanup_sighand);

  <bb 78>:
  _172 = p_27->signal;
  free_signal_struct (_172);

  # retval_203 = PHI <retval_74(34), retval_202(77), retval_202(78)>
bad_fork_cleanup_sighand:
  _173 = p_27->sighand;
  __cleanup_sighand (_173);

  # retval_204 = PHI <retval_73(33), retval_203(79)>
bad_fork_cleanup_fs:
  exit_fs (p_27);

  # retval_205 = PHI <retval_72(32), retval_204(80)>
bad_fork_cleanup_files:
  exit_files (p_27);

  # retval_206 = PHI <retval_71(31), retval_205(81)>
bad_fork_cleanup_semundo:
  exit_sem (p_27);

  # retval_207 = PHI <retval_70(30), retval_206(82)>
bad_fork_cleanup_audit:
  audit_free (p_27);

  # retval_208 = PHI <retval_68(29), retval_207(83)>
bad_fork_cleanup_perf:
  perf_event_free_task (p_27);

  # retval_209 = PHI <retval_66(27), retval_67(28), retval_208(84)>
bad_fork_cleanup_policy:
  _174 = p_27->mempolicy;
  if (_174 != 0B)
    goto <bb 86>;
  else
    goto <bb 87> (bad_fork_cleanup_threadgroup_lock);

  <bb 86>:
  __mpol_put (_174);

  # retval_210 = PHI <retval_64(26), retval_209(86), retval_209(85)>
bad_fork_cleanup_threadgroup_lock:
  if (_18 != 0)
    goto <bb 88>;
  else
    goto <bb 89>;

  <bb 88>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___175 : "p" &current_task);
  cgroup_threadgroup_change_end (pfo_ret___175);

  <bb 89>:
  _432 = p_27->delays;
  if (_432 != 0B)
    goto <bb 90>;
  else
    goto <bb 91>;

  <bb 90>:
  delayacct_cache.20_433 = delayacct_cache;
  kmem_cache_free (delayacct_cache.20_433, _432);

  <bb 91>:
  p_27->delays = 0B;
  pretmp_61 = (long int) retval_210;
  pretmp_612 = (void *) pretmp_61;
  pretmp_614 = (long unsigned int) retval_210;

  # prephitmp_613 = PHI <-11B(19), pretmp_612(91)>
  # prephitmp_615 = PHI <18446744073709551605(19), pretmp_614(91)>
bad_fork_cleanup_count:
  _176 = p_27->cred;
  _177 = _176->user;
  _178 = &_177->processes;
  __asm__ __volatile__(".pushsection .smp_locks,"a"
.balign 4
.long 671f - .
.popsection
671:
	lock; decl %0" : "=m" _178->counter : "m" _178->counter);
  exit_creds (p_27);

  # prephitmp_84 = PHI <-11B(17), pretmp_120(18), prephitmp_613(92)>
  # prephitmp_60 = PHI <18446744073709551605(17), pretmp_85(18), prephitmp_615(92)>
bad_fork_free:
  free_task (p_27);

  # prephitmp_563 = PHI <pretmp_513(11), -12B(12), prephitmp_84(93)>
  # prephitmp_564 = PHI <pretmp_123(11), 18446744073709551604(12), prephitmp_60(93)>
fork_out:

  <bb 95>:
  # _182 = PHI <p_27(69), prephitmp_563(94)>
  # prephitmp_619 = PHI <pretmp_618(69), prephitmp_564(94)>
  cgrp_ss_priv ={v} {CLOBBER};
  if (prephitmp_619 <= 18446744073709547520)
    goto <bb 96>;
  else
    goto <bb 111>;

  <bb 96>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___187 : "p" &current_task);
  __asm__ __volatile__ goto("1:.byte 0x0f,0x1f,0x44,0x00,0
	.pushsection __jump_table,  "aw" 
	 .balign 8 
	 .quad 1b, %l2, %c0 + %c1 
	.popsection 
	" :  : "i" &__tracepoint_sched_process_fork.key, "i" 0 :  : "l_yes" <L19>);

  <bb 97>:
  __asm__ __volatile__("");
  goto <bb 101>;

  <bb 98>:

  <bb 99>:
  # it_func_ptr_437 = PHI <it_func_ptr_436(116), it_func_ptr_441(98)>
  # prephitmp_567 = PHI <pretmp_568(116), _442(98)>
  __data_439 = MEM[base: it_func_ptr_437, offset: 8B];
  it_func.78_440 = (void (*<T6b5e>) (void *, struct task_struct *, struct task_struct *)) prephitmp_567;
  it_func.78_440 (__data_439, pfo_ret___187, _182);
  it_func_ptr_441 = it_func_ptr_437 + 16;
  _442 = MEM[base: it_func_ptr_441, offset: 0B];
  if (_442 != 0B)
    goto <bb 98>;
  else
    goto <bb 100>;

  <bb 100>:
  __asm__ __volatile__("" :  :  : "memory");

  <bb 101>:
  pid_188 = get_task_pid (_182, 0);
  _189 = pid_vnr (pid_188);
  _191 = flags_5(D) & 1048576;
  if (_191 != 0)
    goto <bb 102>;
  else
    goto <bb 103>;

  <bb 102>:
  __asm__ __volatile__("call __put_user_4" : "=a" __ret_pu_192 : "0" _189, "c" 0B : "ebx");

  <bb 103>:
  _193 = flags_5(D) & 16384;
  if (_193 != 0)
    goto <bb 104>;
  else
    goto <bb 117>;

  <bb 104>:
  _182->vfork_done = &vfork;
  vfork.done = 0;
  __init_waitqueue_head (&vfork.wait, "&x->wait", &__key);
  _194 = &_182->usage;
  __asm__ __volatile__(".pushsection .smp_locks,"a"
.balign 4
.long 671f - .
.popsection
671:
	lock; incl %0" : "=m" _194->counter : "m" _194->counter);
  wake_up_new_task (_182);
  _195 = wait_for_vfork_done (_182, &vfork);
  if (_195 == 0)
    goto <bb 106>;
  else
    goto <bb 105>;

  <bb 105>:
  goto <bb 110>;

  <bb 106>:
  __asm__ __volatile__("" :  :  : "memory");
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___445 : "p" &current_task);
  _446 ={v} MEM[(volatile __u64 *)pfo_ret___445 + 1048B];
  ________p1_447 = (struct task_struct *) _446;
  ns_448 = task_active_pid_ns (________p1_447);
  if (ns_448 != 0B)
    goto <bb 107>;
  else
    goto <bb 108>;

  <bb 107>:
  _449 = pid_nr_ns (pid_188, ns_448);
  message_450 = (long unsigned int) _449;

  <bb 108>:
  # message_451 = PHI <0(106), message_450(107)>
  __asm__ __volatile__("" :  :  : "memory");
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___452 : "p" &current_task);
  _453 = pfo_ret___452->ptrace;
  _457 = _453 & 256;
  if (_457 != 0)
    goto <bb 109>;
  else
    goto <bb 105>;

  <bb 109>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___461 : "p" &current_task);
  pfo_ret___461->ptrace_message = message_451;
  ptrace_notify (1285);

  <bb 110>:
  put_pid (pid_188);
  vfork ={v} {CLOBBER};
  pretmp_616 = _189;
  goto <bb 113>;

  <bb 111>:
  pretmp_562 = (long int) _182;
  pretmp_570 = (pid_t) pretmp_562;

  <bb 112>:
  # prephitmp_569 = PHI <pretmp_570(111), -22(114)>

  <bb 113>:
  # prephitmp_617 = PHI <pretmp_616(110), prephitmp_569(112)>
  return prephitmp_617;

  <bb 114>:
  cgrp_ss_priv ={v} {CLOBBER};
  goto <bb 112>;

<L19>:
  __asm__ __volatile__("" :  :  : "memory");
  _435 ={v} MEM[(volatile __u64 *)&__tracepoint_sched_process_fork + 48B];
  it_func_ptr_436 = (struct tracepoint_func *) _435;
  if (it_func_ptr_436 != 0B)
    goto <bb 116>;
  else
    goto <bb 100>;

  <bb 116>:
  pretmp_568 = it_func_ptr_436->func;
  goto <bb 99>;

  <bb 117>:
  wake_up_new_task (_182);
  goto <bb 110>;

}



;; Function sys_fork (sys_fork, funcdef_no=3661, decl_uid=35614, cgraph_uid=3662)

sys_fork ()
{
  void (*<T6b5e>) (void *, struct task_struct *, struct task_struct *) it_func.78;
  struct tracepoint_func * it_func_ptr;
  void * __data;
  struct kmem_cache * delayacct_cache.20;
  struct pid_namespace * ns;
  pid_t nr;
  struct mempolicy * pol;
  union ktime_t D.55997;
  s64 SR.313;
  union ktime D.55994;
  int delayacct_on.53;
  long int nr;
  struct pid * pid;
  struct task_struct * pfo_ret__;
  struct pid * pid;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  long unsigned int ptr.74;
  long unsigned int ptr.74;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  void * cgrp_ss_priv[0:];
  struct task_struct * p;
  int retval;
  long unsigned int total_forks.49;
  long unsigned int total_forks.48;
  int nr_threads.47;
  int max_threads.43;
  int nr_threads.42;
  struct task_struct * pfo_ret__;
  const struct cred * _11;
  struct user_struct * _12;
  int _13;
  long unsigned int _14;
  _Bool _18;
  _Bool _19;
  unsigned int _21;
  unsigned int _22;
  unsigned int _26;
  unsigned int _27;
  unsigned int _28;
  struct list_head * _29;
  struct list_head * _30;
  struct task_rss_stat * _33;
  long unsigned int _35;
  struct task_io_accounting * _36;
  long int _45;
  struct list_head * _51;
  struct nsproxy * _61;
  struct pid_namespace * _62;
  long int _68;
  struct list_head * _71;
  struct list_head * _74;
  unsigned int _78;
  struct sighand_struct * _80;
  struct raw_spinlock * _81;
  int _83;
  struct sighand_struct * _85;
  int _87;
  int _89;
  struct list_head * _94;
  struct signal_struct * _101;
  unsigned int _102;
  unsigned int _103;
  struct signal_struct * _104;
  struct signal_struct * _105;
  struct signal_struct * _107;
  struct tty_struct * _108;
  struct tty_struct * _109;
  struct task_struct * _110;
  struct list_head * _111;
  struct list_head * _112;
  struct signal_struct * _114;
  int _115;
  int _116;
  struct signal_struct * _118;
  struct atomic_t * _119;
  struct signal_struct * _121;
  struct atomic_t * _122;
  struct task_struct * _123;
  struct list_head * _124;
  struct signal_struct * _125;
  struct list_head * _126;
  struct list_head * _127;
  struct sighand_struct * _133;
  struct io_context * _135;
  struct mm_struct * _136;
  struct signal_struct * _137;
  struct sighand_struct * _138;
  struct mempolicy * _139;
  const struct cred * _140;
  struct user_struct * _141;
  struct atomic_t * _142;
  struct task_struct * _146;
  int _153;
  unsigned int _337;
  unsigned int _341;
  struct signal_struct * _343;
  long long unsigned int _344;
  struct list_head * _346;
  long long int _347;
  u64 _348;
  u64 _350;
  int _355;
  struct task_struct * _357;
  struct pid * _358;
  struct task_struct * _359;
  struct pid * _360;
  unsigned int _361;
  int _362;
  struct list_head * _367;
  struct list_head * _368;
  long long unsigned int _369;
  struct list_head * _370;
  long long unsigned int _371;
  struct list_head * _372;
  long long unsigned int _373;
  struct audit_context * _374;
  _Bool _375;
  struct task_delay_info * _378;
  long long unsigned int _381;
  void * _388;
  void * pretmp_503;
  void * prephitmp_504;
  long int pretmp_505;
  void * pretmp_508;
  void * prephitmp_510;
  long unsigned int pretmp_511;
  long unsigned int prephitmp_513;
  long int pretmp_514;
  void * pretmp_517;
  void * prephitmp_519;
  long unsigned int pretmp_520;
  long unsigned int prephitmp_522;
  long int pretmp_523;
  void * pretmp_525;
  void * prephitmp_526;
  long unsigned int pretmp_527;
  long unsigned int prephitmp_528;
  long unsigned int pretmp_529;
  long unsigned int prephitmp_530;

  <bb 2>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___3 : "p" &current_task);
  _337 = pfo_ret___3->ptrace;
  _341 = _337 & 16;
  _375 = _341 != 0;
  _89 = (int) _375;
  cgrp_ss_priv = {};
  retval_8 = security_task_create (17);
  if (retval_8 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  pretmp_505 = (long int) retval_8;
  pretmp_508 = (void *) pretmp_505;
  pretmp_511 = (long unsigned int) retval_8;
  goto <bb 69> (fork_out);

  <bb 4>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___9 : "p" &current_task);
  p_10 = dup_task_struct (pfo_ret___9);
  if (p_10 == 0B)
    goto <bb 69> (fork_out);
  else
    goto <bb 5>;

  <bb 5>:
  p_10->pi_lock.raw_lock.val.counter = 0;
  p_10->pi_waiters.rb_node = 0B;
  p_10->pi_waiters_leftmost = 0B;
  p_10->pi_blocked_on = 0B;
  _11 = p_10->real_cred;
  _12 = _11->user;
  _13 ={v} MEM[(const int *)_12 + 4B];
  _14 = (long unsigned int) _13;
  _343 = MEM[(const struct task_struct *)p_10].signal;
  _344 ={v} MEM[(volatile __u64 *)_343].rlim[6].rlim_cur;
  if (_14 >= _344)
    goto <bb 7>;
  else
    goto <bb 6>;

  <bb 6>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___20 : "p" &current_task);
  _21 = pfo_ret___20->flags;
  _22 = _21 & 4294963199;
  pfo_ret___20->flags = _22;
  retval_23 = copy_creds (p_10, 17);
  if (retval_23 < 0)
    goto <bb 10>;
  else
    goto <bb 11>;

  <bb 7>:
  if (_12 != &root_user)
    goto <bb 8>;
  else
    goto <bb 6>;

  <bb 8>:
  _18 = capable (24);
  if (_18 != 0)
    goto <bb 6>;
  else
    goto <bb 9>;

  <bb 9>:
  _19 = capable (21);
  if (_19 != 0)
    goto <bb 6>;
  else
    goto <bb 68> (bad_fork_free);

  <bb 10>:
  pretmp_514 = (long int) retval_23;
  pretmp_517 = (void *) pretmp_514;
  pretmp_520 = (long unsigned int) retval_23;
  goto <bb 68> (bad_fork_free);

  <bb 11>:
  nr_threads.42_24 = nr_threads;
  max_threads.43_25 = max_threads;
  if (nr_threads.42_24 >= max_threads.43_25)
    goto <bb 67> (bad_fork_cleanup_count);
  else
    goto <bb 12>;

  <bb 12>:
  p_10->delays = 0B;
  delayacct_on.53_345 = delayacct_on;
  if (delayacct_on.53_345 != 0)
    goto <bb 13>;
  else
    goto <bb 14>;

  <bb 13>:
  __delayacct_tsk_init (p_10);

  <bb 14>:
  _26 = p_10->flags;
  _27 = _26 & 4294967007;
  _28 = _27 | 64;
  p_10->flags = _28;
  _29 = &p_10->children;
  MEM[(struct list_head *)p_10 + 1056B].next = _29;
  MEM[(struct list_head *)p_10 + 1056B].prev = _29;
  _30 = &p_10->sibling;
  MEM[(struct list_head *)p_10 + 1072B].next = _30;
  MEM[(struct list_head *)p_10 + 1072B].prev = _30;
  p_10->vfork_done = 0B;
  p_10->alloc_lock.D.5408.rlock.raw_lock.val.counter = 0;
  MEM[(struct sigset_t *)p_10 + 1584B].sig[0] = 0;
  _346 = &MEM[(struct sigpending *)p_10 + 1568B].list;
  MEM[(struct list_head *)p_10 + 1568B].next = _346;
  MEM[(struct list_head *)p_10 + 1568B].prev = _346;
  p_10->gtime = 0;
  p_10->stime = 0;
  p_10->utime = 0;
  p_10->stimescaled = 0;
  p_10->utimescaled = 0;
  MEM[(struct prev_cputime *)p_10 + 1296B].stime = 0;
  MEM[(struct prev_cputime *)p_10 + 1296B].utime = 0;
  MEM[(struct prev_cputime *)p_10 + 1296B].lock.raw_lock.val.counter = 0;
  _33 = &p_10->rss_stat;
  memset (_33, 0, 16);
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___34 : "p" &current_task);
  _35 = pfo_ret___34->timer_slack_ns;
  p_10->default_timer_slack_ns = _35;
  _36 = &p_10->ioac;
  memset (_36, 0, 56);
  acct_clear_integrals (p_10);
  posix_cpu_timers_init (p_10);
  D.55994 = ktime_get ();
  _347 = D.55994.tv64;
  _348 = (u64) _347;
  p_10->start_time = _348;
  D.55997 = ktime_get_with_offset (1);
  SR.313_349 = MEM[(union ktime *)&D.55997];
  _350 = (u64) SR.313_349;
  p_10->real_start_time = _350;
  p_10->io_context = 0B;
  p_10->audit_context = 0B;
  cgroup_fork (p_10);
  pol_39 = p_10->mempolicy;
  if (pol_39 != 0B)
    goto <bb 15>;
  else
    goto <bb 17>;

  <bb 15>:
  pol_351 = __mpol_dup (pol_39);
  p_10->mempolicy = pol_351;
  ptr.74_41 = (long unsigned int) pol_351;
  if (ptr.74_41 > 18446744073709547520)
    goto <bb 16>;
  else
    goto <bb 17>;

  <bb 16>:
  _45 = (long int) pol_351;
  retval_46 = (int) _45;
  p_10->mempolicy = 0B;
  goto <bb 64> (bad_fork_cleanup_threadgroup_lock);

  <bb 17>:
  p_10->cpuset_mem_spread_rotor = -1;
  p_10->cpuset_slab_spread_rotor = -1;
  MEM[(struct seqcount_t *)p_10 + 1872B].sequence = 0;
  p_10->pagefault_disabled = 0;
  retval_48 = sched_fork (17, p_10);
  if (retval_48 != 0)
    goto <bb 62> (bad_fork_cleanup_policy);
  else
    goto <bb 18>;

  <bb 18>:
  retval_49 = perf_event_init_task (p_10);
  if (retval_49 != 0)
    goto <bb 62> (bad_fork_cleanup_policy);
  else
    goto <bb 19>;

  <bb 19>:
  retval_50 = audit_alloc (p_10);
  if (retval_50 != 0)
    goto <bb 61> (bad_fork_cleanup_perf);
  else
    goto <bb 20>;

  <bb 20>:
  _51 = &p_10->sysvshm.shm_clist;
  MEM[(struct list_head *)p_10 + 1488B].next = _51;
  MEM[(struct list_head *)p_10 + 1488B].prev = _51;
  retval_52 = copy_semundo (17, p_10);
  if (retval_52 != 0)
    goto <bb 59> (bad_fork_cleanup_audit);
  else
    goto <bb 21>;

  <bb 21>:
  retval_53 = copy_files (17, p_10);
  if (retval_53 != 0)
    goto <bb 58> (bad_fork_cleanup_semundo);
  else
    goto <bb 22>;

  <bb 22>:
  retval_54 = copy_fs (17, p_10);
  if (retval_54 != 0)
    goto <bb 57> (bad_fork_cleanup_files);
  else
    goto <bb 23>;

  <bb 23>:
  retval_55 = copy_sighand (17, p_10);
  if (retval_55 != 0)
    goto <bb 56> (bad_fork_cleanup_fs);
  else
    goto <bb 24>;

  <bb 24>:
  retval_56 = copy_signal (17, p_10);
  if (retval_56 != 0)
    goto <bb 55> (bad_fork_cleanup_sighand);
  else
    goto <bb 25>;

  <bb 25>:
  retval_57 = copy_mm (17, p_10);
  if (retval_57 != 0)
    goto <bb 54> (bad_fork_cleanup_signal);
  else
    goto <bb 26>;

  <bb 26>:
  retval_58 = copy_namespaces (17, p_10);
  if (retval_58 != 0)
    goto <bb 52> (bad_fork_cleanup_mm);
  else
    goto <bb 27>;

  <bb 27>:
  retval_59 = copy_io (17, p_10);
  if (retval_59 != 0)
    goto <bb 51> (bad_fork_cleanup_namespaces);
  else
    goto <bb 28>;

  <bb 28>:
  retval_60 = copy_thread_tls (17, 0, 0, p_10, 0);
  if (retval_60 != 0)
    goto <bb 49> (bad_fork_cleanup_io);
  else
    goto <bb 29>;

  <bb 29>:
  if (&init_struct_pid != 0B)
    goto <bb 30>;
  else
    goto <bb 81>;

  <bb 30>:
  _61 = p_10->nsproxy;
  _62 = _61->pid_ns_for_children;
  pid_63 = alloc_pid (_62);
  ptr.74_64 = (long unsigned int) pid_63;
  if (ptr.74_64 > 18446744073709547520)
    goto <bb 31>;
  else
    goto <bb 32>;

  <bb 31>:
  _68 = (long int) pid_63;
  retval_69 = (int) _68;
  goto <bb 49> (bad_fork_cleanup_io);

  <bb 32>:
  p_10->set_child_tid = 0B;
  p_10->clear_child_tid = 0B;
  p_10->plug = 0B;
  p_10->robust_list = 0B;
  p_10->compat_robust_list = 0B;
  _71 = &p_10->pi_state_list;
  MEM[(struct list_head *)p_10 + 1928B].next = _71;
  MEM[(struct list_head *)p_10 + 1928B].prev = _71;
  p_10->pi_state_cache = 0B;
  user_disable_single_step (p_10);
  clear_tsk_thread_flag (p_10, 0);
  clear_tsk_thread_flag (p_10, 6);
  if (pid_63 != 0B)
    goto <bb 33>;
  else
    goto <bb 34>;

  <bb 33>:
  nr_353 = pid_63->numbers[0].nr;

  <bb 34>:
  # nr_354 = PHI <0(81), nr_353(33), 0(32)>
  # pid_149 = PHI <0B(81), pid_63(33), pid_63(32)>
  p_10->pid = nr_354;
  p_10->exit_signal = 17;
  p_10->group_leader = p_10;
  p_10->tgid = nr_354;
  p_10->nr_dirtied = 0;
  p_10->nr_dirtied_pause = 32;
  p_10->dirty_paused_when = 0;
  p_10->pdeath_signal = 0;
  _74 = &p_10->thread_group;
  MEM[(struct list_head *)p_10 + 1200B].next = _74;
  MEM[(struct list_head *)p_10 + 1200B].prev = _74;
  p_10->task_works = 0B;
  retval_75 = cgroup_can_fork (p_10, &cgrp_ss_priv);
  if (retval_75 != 0)
    goto <bb 47> (bad_fork_free_pid);
  else
    goto <bb 35>;

  <bb 35>:
  _raw_write_lock_irq (&tasklist_lock);
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___76 : "p" &current_task);
  p_10->real_parent = pfo_ret___76;
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___77 : "p" &current_task);
  _78 = pfo_ret___77->self_exec_id;
  p_10->parent_exec_id = _78;
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___79 : "p" &current_task);
  _80 = pfo_ret___79->sighand;
  _81 = &MEM[(struct spinlock_t *)_80 + 2056B].D.5408.rlock;
  _raw_spin_lock (_81);
  copy_seccomp (p_10);
  recalc_sigpending ();
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___82 : "p" &current_task);
  _83 = signal_pending (pfo_ret___82);
  if (_83 != 0)
    goto <bb 36>;
  else
    goto <bb 37>;

  <bb 36>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___84 : "p" &current_task);
  _85 = pfo_ret___84->sighand;
  __asm__ __volatile__("" :  :  : "memory");
  MEM[(volatile __u8 *)_85 + 2056B] ={v} 0;
  __asm__ __volatile__("" :  :  : "memory");
  __asm__ __volatile__("" :  :  : "memory");
  MEM[(volatile __u8 *)&tasklist_lock] ={v} 0;
  __asm__ __volatile__("sti" :  :  : "memory");
  __asm__ __volatile__("" :  :  : "memory");
  cgroup_cancel_fork (p_10, &cgrp_ss_priv);
  goto <bb 47> (bad_fork_free_pid);

  <bb 37>:
  _87 = p_10->pid;
  if (_87 != 0)
    goto <bb 38>;
  else
    goto <bb 46>;

  <bb 38>:
  ptrace_init_task (p_10, _89);
  p_10->pids[0].pid = pid_149;
  _355 = p_10->exit_signal;
  if (_355 >= 0)
    goto <bb 39>;
  else
    goto <bb 44>;

  <bb 39>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___95 : "p" &current_task);
  _357 = pfo_ret___95->group_leader;
  _358 = _357->pids[1].pid;
  p_10->pids[1].pid = _358;
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___97 : "p" &current_task);
  _359 = pfo_ret___97->group_leader;
  _360 = _359->pids[2].pid;
  p_10->pids[2].pid = _360;
  _361 = pid_149->level;
  _362 = pid_149->numbers[_361].nr;
  if (_362 == 1)
    goto <bb 40>;
  else
    goto <bb 43>;

  <bb 40>:
  if (pid_149 != 0B)
    goto <bb 41>;
  else
    goto <bb 42>;

  <bb 41>:
  ns_365 = pid_149->numbers[_361].ns;

  <bb 42>:
  # ns_366 = PHI <0B(40), ns_365(41)>
  ns_366->child_reaper = p_10;
  _101 = p_10->signal;
  _102 = _101->flags;
  _103 = _102 | 64;
  _101->flags = _103;

  <bb 43>:
  _104 = p_10->signal;
  _104->leader_pid = pid_149;
  _105 = p_10->signal;
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___106 : "p" &current_task);
  _107 = pfo_ret___106->signal;
  _108 = _107->tty;
  _109 = tty_kref_get (_108);
  _105->tty = _109;
  _110 = p_10->real_parent;
  _111 = &_110->children;
  _367 = MEM[(struct list_head *)_110 + 1056B].prev;
  MEM[(struct list_head *)_110 + 1056B].prev = _30;
  MEM[(struct list_head *)p_10 + 1072B].next = _111;
  MEM[(struct list_head *)p_10 + 1072B].prev = _367;
  _367->next = _30;
  _112 = &p_10->tasks;
  _368 = MEM[(struct list_head *)&init_task + 792B].prev;
  MEM[(struct list_head *)p_10 + 792B].next = &init_task.tasks;
  MEM[(struct list_head *)p_10 + 792B].prev = _368;
  __asm__ __volatile__("" :  :  : "memory");
  _369 = (long long unsigned int) _112;
  MEM[(volatile __u64 *)_368] ={v} _369;
  MEM[(struct list_head *)&init_task + 792B].prev = _112;
  attach_pid (p_10, 1);
  attach_pid (p_10, 2);
  __asm__("incq %%gs:%0" : "=m" process_counts : "m" process_counts);
  goto <bb 45>;

  <bb 44>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___113 : "p" &current_task);
  _114 = pfo_ret___113->signal;
  _115 = _114->nr_threads;
  _116 = _115 + 1;
  _114->nr_threads = _116;
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___117 : "p" &current_task);
  _118 = pfo_ret___117->signal;
  _119 = &_118->live;
  __asm__ __volatile__(".pushsection .smp_locks,"a"
.balign 4
.long 671f - .
.popsection
671:
	lock; incl %0" : "=m" _119->counter : "m" _119->counter);
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___120 : "p" &current_task);
  _121 = pfo_ret___120->signal;
  _122 = &_121->sigcnt;
  __asm__ __volatile__(".pushsection .smp_locks,"a"
.balign 4
.long 671f - .
.popsection
671:
	lock; incl %0" : "=m" _122->counter : "m" _122->counter);
  _123 = p_10->group_leader;
  _124 = &_123->thread_group;
  _370 = MEM[(struct list_head *)_123 + 1200B].prev;
  MEM[(struct list_head *)p_10 + 1200B].next = _124;
  MEM[(struct list_head *)p_10 + 1200B].prev = _370;
  __asm__ __volatile__("" :  :  : "memory");
  _371 = (long long unsigned int) _74;
  MEM[(volatile __u64 *)_370] ={v} _371;
  MEM[(struct list_head *)_123 + 1200B].prev = _74;
  _125 = p_10->signal;
  _126 = &_125->thread_head;
  _127 = &p_10->thread_node;
  _372 = MEM[(struct list_head *)_125 + 16B].prev;
  MEM[(struct list_head *)p_10 + 1216B].next = _126;
  MEM[(struct list_head *)p_10 + 1216B].prev = _372;
  __asm__ __volatile__("" :  :  : "memory");
  _373 = (long long unsigned int) _127;
  MEM[(volatile __u64 *)_372] ={v} _373;
  MEM[(struct list_head *)_125 + 16B].prev = _127;

  <bb 45>:
  attach_pid (p_10, 0);
  nr_threads.42_128 = nr_threads;
  nr_threads.47_129 = nr_threads.42_128 + 1;
  nr_threads = nr_threads.47_129;

  <bb 46>:
  total_forks.48_130 = total_forks;
  total_forks.49_131 = total_forks.48_130 + 1;
  total_forks = total_forks.49_131;
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___132 : "p" &current_task);
  _133 = pfo_ret___132->sighand;
  __asm__ __volatile__("" :  :  : "memory");
  MEM[(volatile __u8 *)_133 + 2056B] ={v} 0;
  __asm__ __volatile__("" :  :  : "memory");
  syscall_tracepoint_update (p_10);
  __asm__ __volatile__("" :  :  : "memory");
  MEM[(volatile __u8 *)&tasklist_lock] ={v} 0;
  __asm__ __volatile__("sti" :  :  : "memory");
  __asm__ __volatile__("" :  :  : "memory");
  proc_fork_connector (p_10);
  cgroup_post_fork (p_10, &cgrp_ss_priv);
  perf_event_fork (p_10);
  trace_task_newtask (p_10, 17);
  pretmp_529 = (long unsigned int) p_10;
  goto <bb 70>;

  # retval_160 = PHI <retval_75(34), -513(36)>
bad_fork_free_pid:
  if (pid_149 != &init_struct_pid)
    goto <bb 48>;
  else
    goto <bb 49> (bad_fork_cleanup_io);

  <bb 48>:
  free_pid (pid_149);

  # retval_161 = PHI <retval_60(28), retval_69(31), retval_160(47), retval_160(48)>
bad_fork_cleanup_io:
  _135 = p_10->io_context;
  if (_135 != 0B)
    goto <bb 50>;
  else
    goto <bb 51> (bad_fork_cleanup_namespaces);

  <bb 50>:
  exit_io_context (p_10);

  # retval_162 = PHI <retval_59(27), retval_161(49), retval_161(50)>
bad_fork_cleanup_namespaces:
  exit_task_namespaces (p_10);

  # retval_163 = PHI <retval_58(26), retval_162(51)>
bad_fork_cleanup_mm:
  _136 = p_10->mm;
  if (_136 != 0B)
    goto <bb 53>;
  else
    goto <bb 54> (bad_fork_cleanup_signal);

  <bb 53>:
  mmput (_136);

  # retval_164 = PHI <retval_57(25), retval_163(52), retval_163(53)>
bad_fork_cleanup_signal:
  _137 = p_10->signal;
  free_signal_struct (_137);

  # retval_165 = PHI <retval_56(24), retval_164(54)>
bad_fork_cleanup_sighand:
  _138 = p_10->sighand;
  __cleanup_sighand (_138);

  # retval_166 = PHI <retval_55(23), retval_165(55)>
bad_fork_cleanup_fs:
  exit_fs (p_10);

  # retval_167 = PHI <retval_54(22), retval_166(56)>
bad_fork_cleanup_files:
  exit_files (p_10);

  # retval_168 = PHI <retval_53(21), retval_167(57)>
bad_fork_cleanup_semundo:
  exit_sem (p_10);

  # retval_169 = PHI <retval_52(20), retval_168(58)>
bad_fork_cleanup_audit:
  _374 = p_10->audit_context;
  if (_374 != 0B)
    goto <bb 60>;
  else
    goto <bb 61> (bad_fork_cleanup_perf);

  <bb 60>:
  __audit_free (p_10);

  # retval_170 = PHI <retval_50(19), retval_169(60), retval_169(59)>
bad_fork_cleanup_perf:
  perf_event_free_task (p_10);

  # retval_171 = PHI <retval_48(17), retval_49(18), retval_170(61)>
bad_fork_cleanup_policy:
  _139 = p_10->mempolicy;
  if (_139 != 0B)
    goto <bb 63>;
  else
    goto <bb 64> (bad_fork_cleanup_threadgroup_lock);

  <bb 63>:
  __mpol_put (_139);

  # retval_172 = PHI <retval_46(16), retval_171(63), retval_171(62)>
bad_fork_cleanup_threadgroup_lock:
  _378 = p_10->delays;
  if (_378 != 0B)
    goto <bb 65>;
  else
    goto <bb 66>;

  <bb 65>:
  delayacct_cache.20_379 = delayacct_cache;
  kmem_cache_free (delayacct_cache.20_379, _378);

  <bb 66>:
  p_10->delays = 0B;
  pretmp_523 = (long int) retval_172;
  pretmp_525 = (void *) pretmp_523;
  pretmp_527 = (long unsigned int) retval_172;

  # prephitmp_526 = PHI <-11B(11), pretmp_525(66)>
  # prephitmp_528 = PHI <18446744073709551605(11), pretmp_527(66)>
bad_fork_cleanup_count:
  _140 = p_10->cred;
  _141 = _140->user;
  _142 = &_141->processes;
  __asm__ __volatile__(".pushsection .smp_locks,"a"
.balign 4
.long 671f - .
.popsection
671:
	lock; decl %0" : "=m" _142->counter : "m" _142->counter);
  exit_creds (p_10);

  # prephitmp_519 = PHI <-11B(9), pretmp_517(10), prephitmp_526(67)>
  # prephitmp_522 = PHI <18446744073709551605(9), pretmp_520(10), prephitmp_528(67)>
bad_fork_free:
  free_task (p_10);

  # prephitmp_510 = PHI <pretmp_508(3), -12B(4), prephitmp_519(68)>
  # prephitmp_513 = PHI <pretmp_511(3), 18446744073709551604(4), prephitmp_522(68)>
fork_out:

  <bb 70>:
  # _146 = PHI <prephitmp_510(69), p_10(46)>
  # prephitmp_530 = PHI <prephitmp_513(69), pretmp_529(46)>
  cgrp_ss_priv ={v} {CLOBBER};
  if (prephitmp_530 <= 18446744073709547520)
    goto <bb 71>;
  else
    goto <bb 79>;

  <bb 71>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___151 : "p" &current_task);
  __asm__ __volatile__ goto("1:.byte 0x0f,0x1f,0x44,0x00,0
	.pushsection __jump_table,  "aw" 
	 .balign 8 
	 .quad 1b, %l2, %c0 + %c1 
	.popsection 
	" :  : "i" &__tracepoint_sched_process_fork.key, "i" 0 :  : "l_yes" <L19>);

  <bb 72>:
  __asm__ __volatile__("");
  goto <bb 76>;

  <bb 73>:

  <bb 74>:
  # it_func_ptr_383 = PHI <it_func_ptr_382(83), it_func_ptr_387(73)>
  # prephitmp_504 = PHI <pretmp_503(83), _388(73)>
  __data_385 = MEM[base: it_func_ptr_383, offset: 8B];
  it_func.78_386 = (void (*<T6b5e>) (void *, struct task_struct *, struct task_struct *)) prephitmp_504;
  it_func.78_386 (__data_385, pfo_ret___151, _146);
  it_func_ptr_387 = it_func_ptr_383 + 16;
  _388 = MEM[base: it_func_ptr_387, offset: 0B];
  if (_388 != 0B)
    goto <bb 73>;
  else
    goto <bb 75>;

  <bb 75>:
  __asm__ __volatile__("" :  :  : "memory");

  <bb 76>:
  pid_152 = get_task_pid (_146, 0);
  _153 = pid_vnr (pid_152);
  nr_154 = (long int) _153;
  wake_up_new_task (_146);
  if (_89 != 0)
    goto <bb 77>;
  else
    goto <bb 78>;

  <bb 77>:
  ptrace_event_pid (1, pid_152);

  <bb 78>:
  put_pid (pid_152);
  goto <bb 80>;

  <bb 79>:
  nr_158 = (long int) _146;

  <bb 80>:
  # nr_159 = PHI <nr_154(78), nr_158(79)>
  return nr_159;

  <bb 81>:
  p_10->set_child_tid = 0B;
  p_10->clear_child_tid = 0B;
  p_10->plug = 0B;
  p_10->robust_list = 0B;
  p_10->compat_robust_list = 0B;
  _94 = &p_10->pi_state_list;
  MEM[(struct list_head *)p_10 + 1928B].next = _94;
  MEM[(struct list_head *)p_10 + 1928B].prev = _94;
  p_10->pi_state_cache = 0B;
  user_disable_single_step (p_10);
  clear_tsk_thread_flag (p_10, 0);
  clear_tsk_thread_flag (p_10, 6);
  goto <bb 34>;

<L19>:
  __asm__ __volatile__("" :  :  : "memory");
  _381 ={v} MEM[(volatile __u64 *)&__tracepoint_sched_process_fork + 48B];
  it_func_ptr_382 = (struct tracepoint_func *) _381;
  if (it_func_ptr_382 != 0B)
    goto <bb 83>;
  else
    goto <bb 75>;

  <bb 83>:
  pretmp_503 = it_func_ptr_382->func;
  goto <bb 74>;

}



;; Function sys_vfork (sys_vfork, funcdef_no=3662, decl_uid=35616, cgraph_uid=3663)

sys_vfork ()
{
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * ________p1;
  struct pid_namespace * ns;
  long unsigned int message;
  static struct lock_class_key __key;
  void (*<T6b5e>) (void *, struct task_struct *, struct task_struct *) it_func.78;
  struct tracepoint_func * it_func_ptr;
  void * __data;
  struct kmem_cache * delayacct_cache.20;
  struct pid_namespace * ns;
  pid_t nr;
  struct mempolicy * pol;
  union ktime_t D.56131;
  s64 SR.313;
  union ktime D.56128;
  int delayacct_on.53;
  int trace;
  long int nr;
  struct completion vfork;
  struct pid * pid;
  struct task_struct * pfo_ret__;
  struct pid * pid;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  long unsigned int ptr.74;
  long unsigned int ptr.74;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  void * cgrp_ss_priv[0:];
  struct task_struct * p;
  int retval;
  long unsigned int total_forks.49;
  long unsigned int total_forks.48;
  int nr_threads.47;
  int max_threads.43;
  int nr_threads.42;
  struct task_struct * pfo_ret__;
  const struct cred * _11;
  struct user_struct * _12;
  int _13;
  long unsigned int _14;
  _Bool _18;
  _Bool _19;
  unsigned int _21;
  unsigned int _22;
  unsigned int _26;
  unsigned int _27;
  unsigned int _28;
  struct list_head * _29;
  struct list_head * _30;
  struct task_rss_stat * _33;
  long unsigned int _35;
  struct task_io_accounting * _36;
  long int _45;
  struct list_head * _51;
  struct nsproxy * _61;
  struct pid_namespace * _62;
  long int _68;
  struct list_head * _71;
  struct list_head * _74;
  unsigned int _78;
  struct sighand_struct * _80;
  struct raw_spinlock * _81;
  int _83;
  struct sighand_struct * _85;
  int _87;
  struct list_head * _94;
  struct signal_struct * _101;
  unsigned int _102;
  unsigned int _103;
  struct signal_struct * _104;
  struct signal_struct * _105;
  struct signal_struct * _107;
  struct tty_struct * _108;
  struct tty_struct * _109;
  struct task_struct * _110;
  struct list_head * _111;
  struct list_head * _112;
  struct signal_struct * _114;
  int _115;
  int _116;
  struct signal_struct * _118;
  struct atomic_t * _119;
  struct signal_struct * _121;
  struct atomic_t * _122;
  struct task_struct * _123;
  struct list_head * _124;
  struct signal_struct * _125;
  struct list_head * _126;
  struct list_head * _127;
  struct sighand_struct * _133;
  struct io_context * _135;
  struct mm_struct * _136;
  struct signal_struct * _137;
  struct sighand_struct * _138;
  struct mempolicy * _139;
  const struct cred * _140;
  struct user_struct * _141;
  struct atomic_t * _142;
  struct task_struct * _146;
  int _148;
  int _153;
  struct atomic_t * _155;
  int _159;
  unsigned int _346;
  unsigned int _350;
  struct signal_struct * _352;
  long long unsigned int _353;
  struct list_head * _355;
  long long int _356;
  u64 _357;
  u64 _359;
  _Bool _361;
  int _364;
  struct task_struct * _366;
  struct pid * _367;
  struct task_struct * _368;
  struct pid * _369;
  unsigned int _370;
  int _371;
  struct list_head * _376;
  struct list_head * _377;
  long long unsigned int _378;
  struct list_head * _379;
  long long unsigned int _380;
  struct list_head * _381;
  long long unsigned int _382;
  struct audit_context * _383;
  struct task_delay_info * _387;
  long long unsigned int _390;
  void * _397;
  long long unsigned int _401;
  int _404;
  unsigned int _408;
  unsigned int _412;
  void * pretmp_531;
  void * prephitmp_532;
  long int pretmp_533;
  void * pretmp_536;
  void * prephitmp_538;
  long unsigned int pretmp_539;
  long unsigned int prephitmp_541;
  long int pretmp_542;
  void * pretmp_545;
  void * prephitmp_547;
  long unsigned int pretmp_548;
  long unsigned int prephitmp_550;
  long int pretmp_551;
  void * pretmp_553;
  void * prephitmp_554;
  long unsigned int pretmp_555;
  long unsigned int prephitmp_556;
  long unsigned int pretmp_557;
  long unsigned int prephitmp_558;

  <bb 2>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___3 : "p" &current_task);
  _346 = pfo_ret___3->ptrace;
  _350 = _346 & 32;
  if (_350 == 0)
    goto <bb 4>;
  else
    goto <bb 3>;

  <bb 3>:

  <bb 4>:
  # trace_91 = PHI <0(2), 2(3)>
  cgrp_ss_priv = {};
  retval_8 = security_task_create (16657);
  if (retval_8 != 0)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  pretmp_533 = (long int) retval_8;
  pretmp_536 = (void *) pretmp_533;
  pretmp_539 = (long unsigned int) retval_8;
  goto <bb 71> (fork_out);

  <bb 6>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___9 : "p" &current_task);
  p_10 = dup_task_struct (pfo_ret___9);
  if (p_10 == 0B)
    goto <bb 71> (fork_out);
  else
    goto <bb 7>;

  <bb 7>:
  p_10->pi_lock.raw_lock.val.counter = 0;
  p_10->pi_waiters.rb_node = 0B;
  p_10->pi_waiters_leftmost = 0B;
  p_10->pi_blocked_on = 0B;
  _11 = p_10->real_cred;
  _12 = _11->user;
  _13 ={v} MEM[(const int *)_12 + 4B];
  _14 = (long unsigned int) _13;
  _352 = MEM[(const struct task_struct *)p_10].signal;
  _353 ={v} MEM[(volatile __u64 *)_352].rlim[6].rlim_cur;
  if (_14 >= _353)
    goto <bb 9>;
  else
    goto <bb 8>;

  <bb 8>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___20 : "p" &current_task);
  _21 = pfo_ret___20->flags;
  _22 = _21 & 4294963199;
  pfo_ret___20->flags = _22;
  retval_23 = copy_creds (p_10, 16657);
  if (retval_23 < 0)
    goto <bb 12>;
  else
    goto <bb 13>;

  <bb 9>:
  if (_12 != &root_user)
    goto <bb 10>;
  else
    goto <bb 8>;

  <bb 10>:
  _18 = capable (24);
  if (_18 != 0)
    goto <bb 8>;
  else
    goto <bb 11>;

  <bb 11>:
  _19 = capable (21);
  if (_19 != 0)
    goto <bb 8>;
  else
    goto <bb 70> (bad_fork_free);

  <bb 12>:
  pretmp_542 = (long int) retval_23;
  pretmp_545 = (void *) pretmp_542;
  pretmp_548 = (long unsigned int) retval_23;
  goto <bb 70> (bad_fork_free);

  <bb 13>:
  nr_threads.42_24 = nr_threads;
  max_threads.43_25 = max_threads;
  if (nr_threads.42_24 >= max_threads.43_25)
    goto <bb 69> (bad_fork_cleanup_count);
  else
    goto <bb 14>;

  <bb 14>:
  p_10->delays = 0B;
  delayacct_on.53_354 = delayacct_on;
  if (delayacct_on.53_354 != 0)
    goto <bb 15>;
  else
    goto <bb 16>;

  <bb 15>:
  __delayacct_tsk_init (p_10);

  <bb 16>:
  _26 = p_10->flags;
  _27 = _26 & 4294967007;
  _28 = _27 | 64;
  p_10->flags = _28;
  _29 = &p_10->children;
  MEM[(struct list_head *)p_10 + 1056B].next = _29;
  MEM[(struct list_head *)p_10 + 1056B].prev = _29;
  _30 = &p_10->sibling;
  MEM[(struct list_head *)p_10 + 1072B].next = _30;
  MEM[(struct list_head *)p_10 + 1072B].prev = _30;
  p_10->vfork_done = 0B;
  p_10->alloc_lock.D.5408.rlock.raw_lock.val.counter = 0;
  MEM[(struct sigset_t *)p_10 + 1584B].sig[0] = 0;
  _355 = &MEM[(struct sigpending *)p_10 + 1568B].list;
  MEM[(struct list_head *)p_10 + 1568B].next = _355;
  MEM[(struct list_head *)p_10 + 1568B].prev = _355;
  p_10->gtime = 0;
  p_10->stime = 0;
  p_10->utime = 0;
  p_10->stimescaled = 0;
  p_10->utimescaled = 0;
  MEM[(struct prev_cputime *)p_10 + 1296B].stime = 0;
  MEM[(struct prev_cputime *)p_10 + 1296B].utime = 0;
  MEM[(struct prev_cputime *)p_10 + 1296B].lock.raw_lock.val.counter = 0;
  _33 = &p_10->rss_stat;
  memset (_33, 0, 16);
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___34 : "p" &current_task);
  _35 = pfo_ret___34->timer_slack_ns;
  p_10->default_timer_slack_ns = _35;
  _36 = &p_10->ioac;
  memset (_36, 0, 56);
  acct_clear_integrals (p_10);
  posix_cpu_timers_init (p_10);
  D.56128 = ktime_get ();
  _356 = D.56128.tv64;
  _357 = (u64) _356;
  p_10->start_time = _357;
  D.56131 = ktime_get_with_offset (1);
  SR.313_358 = MEM[(union ktime *)&D.56131];
  _359 = (u64) SR.313_358;
  p_10->real_start_time = _359;
  p_10->io_context = 0B;
  p_10->audit_context = 0B;
  cgroup_fork (p_10);
  pol_39 = p_10->mempolicy;
  if (pol_39 != 0B)
    goto <bb 17>;
  else
    goto <bb 19>;

  <bb 17>:
  pol_360 = __mpol_dup (pol_39);
  p_10->mempolicy = pol_360;
  ptr.74_41 = (long unsigned int) pol_360;
  if (ptr.74_41 > 18446744073709547520)
    goto <bb 18>;
  else
    goto <bb 19>;

  <bb 18>:
  _45 = (long int) pol_360;
  retval_46 = (int) _45;
  p_10->mempolicy = 0B;
  goto <bb 66> (bad_fork_cleanup_threadgroup_lock);

  <bb 19>:
  p_10->cpuset_mem_spread_rotor = -1;
  p_10->cpuset_slab_spread_rotor = -1;
  MEM[(struct seqcount_t *)p_10 + 1872B].sequence = 0;
  p_10->pagefault_disabled = 0;
  retval_48 = sched_fork (16657, p_10);
  if (retval_48 != 0)
    goto <bb 64> (bad_fork_cleanup_policy);
  else
    goto <bb 20>;

  <bb 20>:
  retval_49 = perf_event_init_task (p_10);
  if (retval_49 != 0)
    goto <bb 64> (bad_fork_cleanup_policy);
  else
    goto <bb 21>;

  <bb 21>:
  retval_50 = audit_alloc (p_10);
  if (retval_50 != 0)
    goto <bb 63> (bad_fork_cleanup_perf);
  else
    goto <bb 22>;

  <bb 22>:
  _51 = &p_10->sysvshm.shm_clist;
  MEM[(struct list_head *)p_10 + 1488B].next = _51;
  MEM[(struct list_head *)p_10 + 1488B].prev = _51;
  retval_52 = copy_semundo (16657, p_10);
  if (retval_52 != 0)
    goto <bb 61> (bad_fork_cleanup_audit);
  else
    goto <bb 23>;

  <bb 23>:
  retval_53 = copy_files (16657, p_10);
  if (retval_53 != 0)
    goto <bb 60> (bad_fork_cleanup_semundo);
  else
    goto <bb 24>;

  <bb 24>:
  retval_54 = copy_fs (16657, p_10);
  if (retval_54 != 0)
    goto <bb 59> (bad_fork_cleanup_files);
  else
    goto <bb 25>;

  <bb 25>:
  retval_55 = copy_sighand (16657, p_10);
  if (retval_55 != 0)
    goto <bb 58> (bad_fork_cleanup_fs);
  else
    goto <bb 26>;

  <bb 26>:
  retval_56 = copy_signal (16657, p_10);
  if (retval_56 != 0)
    goto <bb 57> (bad_fork_cleanup_sighand);
  else
    goto <bb 27>;

  <bb 27>:
  retval_57 = copy_mm (16657, p_10);
  if (retval_57 != 0)
    goto <bb 56> (bad_fork_cleanup_signal);
  else
    goto <bb 28>;

  <bb 28>:
  retval_58 = copy_namespaces (16657, p_10);
  if (retval_58 != 0)
    goto <bb 54> (bad_fork_cleanup_mm);
  else
    goto <bb 29>;

  <bb 29>:
  retval_59 = copy_io (16657, p_10);
  if (retval_59 != 0)
    goto <bb 53> (bad_fork_cleanup_namespaces);
  else
    goto <bb 30>;

  <bb 30>:
  retval_60 = copy_thread_tls (16657, 0, 0, p_10, 0);
  if (retval_60 != 0)
    goto <bb 51> (bad_fork_cleanup_io);
  else
    goto <bb 31>;

  <bb 31>:
  if (&init_struct_pid != 0B)
    goto <bb 32>;
  else
    goto <bb 89>;

  <bb 32>:
  _61 = p_10->nsproxy;
  _62 = _61->pid_ns_for_children;
  pid_63 = alloc_pid (_62);
  ptr.74_64 = (long unsigned int) pid_63;
  if (ptr.74_64 > 18446744073709547520)
    goto <bb 33>;
  else
    goto <bb 34>;

  <bb 33>:
  _68 = (long int) pid_63;
  retval_69 = (int) _68;
  goto <bb 51> (bad_fork_cleanup_io);

  <bb 34>:
  p_10->set_child_tid = 0B;
  p_10->clear_child_tid = 0B;
  p_10->plug = 0B;
  p_10->robust_list = 0B;
  p_10->compat_robust_list = 0B;
  _71 = &p_10->pi_state_list;
  MEM[(struct list_head *)p_10 + 1928B].next = _71;
  MEM[(struct list_head *)p_10 + 1928B].prev = _71;
  p_10->pi_state_cache = 0B;
  user_disable_single_step (p_10);
  clear_tsk_thread_flag (p_10, 0);
  clear_tsk_thread_flag (p_10, 6);
  if (pid_63 != 0B)
    goto <bb 35>;
  else
    goto <bb 36>;

  <bb 35>:
  nr_362 = pid_63->numbers[0].nr;

  <bb 36>:
  # nr_363 = PHI <0(89), nr_362(35), 0(34)>
  # pid_158 = PHI <0B(89), pid_63(35), pid_63(34)>
  p_10->pid = nr_363;
  p_10->exit_signal = 17;
  p_10->group_leader = p_10;
  p_10->tgid = nr_363;
  p_10->nr_dirtied = 0;
  p_10->nr_dirtied_pause = 32;
  p_10->dirty_paused_when = 0;
  p_10->pdeath_signal = 0;
  _74 = &p_10->thread_group;
  MEM[(struct list_head *)p_10 + 1200B].next = _74;
  MEM[(struct list_head *)p_10 + 1200B].prev = _74;
  p_10->task_works = 0B;
  retval_75 = cgroup_can_fork (p_10, &cgrp_ss_priv);
  if (retval_75 != 0)
    goto <bb 49> (bad_fork_free_pid);
  else
    goto <bb 37>;

  <bb 37>:
  _raw_write_lock_irq (&tasklist_lock);
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___76 : "p" &current_task);
  p_10->real_parent = pfo_ret___76;
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___77 : "p" &current_task);
  _78 = pfo_ret___77->self_exec_id;
  p_10->parent_exec_id = _78;
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___79 : "p" &current_task);
  _80 = pfo_ret___79->sighand;
  _81 = &MEM[(struct spinlock_t *)_80 + 2056B].D.5408.rlock;
  _raw_spin_lock (_81);
  copy_seccomp (p_10);
  recalc_sigpending ();
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___82 : "p" &current_task);
  _83 = signal_pending (pfo_ret___82);
  if (_83 != 0)
    goto <bb 38>;
  else
    goto <bb 39>;

  <bb 38>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___84 : "p" &current_task);
  _85 = pfo_ret___84->sighand;
  __asm__ __volatile__("" :  :  : "memory");
  MEM[(volatile __u8 *)_85 + 2056B] ={v} 0;
  __asm__ __volatile__("" :  :  : "memory");
  __asm__ __volatile__("" :  :  : "memory");
  MEM[(volatile __u8 *)&tasklist_lock] ={v} 0;
  __asm__ __volatile__("sti" :  :  : "memory");
  __asm__ __volatile__("" :  :  : "memory");
  cgroup_cancel_fork (p_10, &cgrp_ss_priv);
  goto <bb 49> (bad_fork_free_pid);

  <bb 39>:
  _87 = p_10->pid;
  if (_87 != 0)
    goto <bb 40>;
  else
    goto <bb 48>;

  <bb 40>:
  _361 = trace_91 != 0;
  _148 = (int) _361;
  ptrace_init_task (p_10, _148);
  p_10->pids[0].pid = pid_158;
  _364 = p_10->exit_signal;
  if (_364 >= 0)
    goto <bb 41>;
  else
    goto <bb 46>;

  <bb 41>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___95 : "p" &current_task);
  _366 = pfo_ret___95->group_leader;
  _367 = _366->pids[1].pid;
  p_10->pids[1].pid = _367;
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___97 : "p" &current_task);
  _368 = pfo_ret___97->group_leader;
  _369 = _368->pids[2].pid;
  p_10->pids[2].pid = _369;
  _370 = pid_158->level;
  _371 = pid_158->numbers[_370].nr;
  if (_371 == 1)
    goto <bb 42>;
  else
    goto <bb 45>;

  <bb 42>:
  if (pid_158 != 0B)
    goto <bb 43>;
  else
    goto <bb 44>;

  <bb 43>:
  ns_374 = pid_158->numbers[_370].ns;

  <bb 44>:
  # ns_375 = PHI <0B(42), ns_374(43)>
  ns_375->child_reaper = p_10;
  _101 = p_10->signal;
  _102 = _101->flags;
  _103 = _102 | 64;
  _101->flags = _103;

  <bb 45>:
  _104 = p_10->signal;
  _104->leader_pid = pid_158;
  _105 = p_10->signal;
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___106 : "p" &current_task);
  _107 = pfo_ret___106->signal;
  _108 = _107->tty;
  _109 = tty_kref_get (_108);
  _105->tty = _109;
  _110 = p_10->real_parent;
  _111 = &_110->children;
  _376 = MEM[(struct list_head *)_110 + 1056B].prev;
  MEM[(struct list_head *)_110 + 1056B].prev = _30;
  MEM[(struct list_head *)p_10 + 1072B].next = _111;
  MEM[(struct list_head *)p_10 + 1072B].prev = _376;
  _376->next = _30;
  _112 = &p_10->tasks;
  _377 = MEM[(struct list_head *)&init_task + 792B].prev;
  MEM[(struct list_head *)p_10 + 792B].next = &init_task.tasks;
  MEM[(struct list_head *)p_10 + 792B].prev = _377;
  __asm__ __volatile__("" :  :  : "memory");
  _378 = (long long unsigned int) _112;
  MEM[(volatile __u64 *)_377] ={v} _378;
  MEM[(struct list_head *)&init_task + 792B].prev = _112;
  attach_pid (p_10, 1);
  attach_pid (p_10, 2);
  __asm__("incq %%gs:%0" : "=m" process_counts : "m" process_counts);
  goto <bb 47>;

  <bb 46>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___113 : "p" &current_task);
  _114 = pfo_ret___113->signal;
  _115 = _114->nr_threads;
  _116 = _115 + 1;
  _114->nr_threads = _116;
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___117 : "p" &current_task);
  _118 = pfo_ret___117->signal;
  _119 = &_118->live;
  __asm__ __volatile__(".pushsection .smp_locks,"a"
.balign 4
.long 671f - .
.popsection
671:
	lock; incl %0" : "=m" _119->counter : "m" _119->counter);
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___120 : "p" &current_task);
  _121 = pfo_ret___120->signal;
  _122 = &_121->sigcnt;
  __asm__ __volatile__(".pushsection .smp_locks,"a"
.balign 4
.long 671f - .
.popsection
671:
	lock; incl %0" : "=m" _122->counter : "m" _122->counter);
  _123 = p_10->group_leader;
  _124 = &_123->thread_group;
  _379 = MEM[(struct list_head *)_123 + 1200B].prev;
  MEM[(struct list_head *)p_10 + 1200B].next = _124;
  MEM[(struct list_head *)p_10 + 1200B].prev = _379;
  __asm__ __volatile__("" :  :  : "memory");
  _380 = (long long unsigned int) _74;
  MEM[(volatile __u64 *)_379] ={v} _380;
  MEM[(struct list_head *)_123 + 1200B].prev = _74;
  _125 = p_10->signal;
  _126 = &_125->thread_head;
  _127 = &p_10->thread_node;
  _381 = MEM[(struct list_head *)_125 + 16B].prev;
  MEM[(struct list_head *)p_10 + 1216B].next = _126;
  MEM[(struct list_head *)p_10 + 1216B].prev = _381;
  __asm__ __volatile__("" :  :  : "memory");
  _382 = (long long unsigned int) _127;
  MEM[(volatile __u64 *)_381] ={v} _382;
  MEM[(struct list_head *)_125 + 16B].prev = _127;

  <bb 47>:
  attach_pid (p_10, 0);
  nr_threads.42_128 = nr_threads;
  nr_threads.47_129 = nr_threads.42_128 + 1;
  nr_threads = nr_threads.47_129;

  <bb 48>:
  total_forks.48_130 = total_forks;
  total_forks.49_131 = total_forks.48_130 + 1;
  total_forks = total_forks.49_131;
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___132 : "p" &current_task);
  _133 = pfo_ret___132->sighand;
  __asm__ __volatile__("" :  :  : "memory");
  MEM[(volatile __u8 *)_133 + 2056B] ={v} 0;
  __asm__ __volatile__("" :  :  : "memory");
  syscall_tracepoint_update (p_10);
  __asm__ __volatile__("" :  :  : "memory");
  MEM[(volatile __u8 *)&tasklist_lock] ={v} 0;
  __asm__ __volatile__("sti" :  :  : "memory");
  __asm__ __volatile__("" :  :  : "memory");
  proc_fork_connector (p_10);
  cgroup_post_fork (p_10, &cgrp_ss_priv);
  perf_event_fork (p_10);
  trace_task_newtask (p_10, 16657);
  pretmp_557 = (long unsigned int) p_10;
  goto <bb 72>;

  # retval_162 = PHI <retval_75(36), -513(38)>
bad_fork_free_pid:
  if (pid_158 != &init_struct_pid)
    goto <bb 50>;
  else
    goto <bb 51> (bad_fork_cleanup_io);

  <bb 50>:
  free_pid (pid_158);

  # retval_163 = PHI <retval_60(30), retval_69(33), retval_162(49), retval_162(50)>
bad_fork_cleanup_io:
  _135 = p_10->io_context;
  if (_135 != 0B)
    goto <bb 52>;
  else
    goto <bb 53> (bad_fork_cleanup_namespaces);

  <bb 52>:
  exit_io_context (p_10);

  # retval_164 = PHI <retval_59(29), retval_163(51), retval_163(52)>
bad_fork_cleanup_namespaces:
  exit_task_namespaces (p_10);

  # retval_165 = PHI <retval_58(28), retval_164(53)>
bad_fork_cleanup_mm:
  _136 = p_10->mm;
  if (_136 != 0B)
    goto <bb 55>;
  else
    goto <bb 56> (bad_fork_cleanup_signal);

  <bb 55>:
  mmput (_136);

  # retval_166 = PHI <retval_57(27), retval_165(54), retval_165(55)>
bad_fork_cleanup_signal:
  _137 = p_10->signal;
  free_signal_struct (_137);

  # retval_167 = PHI <retval_56(26), retval_166(56)>
bad_fork_cleanup_sighand:
  _138 = p_10->sighand;
  __cleanup_sighand (_138);

  # retval_168 = PHI <retval_55(25), retval_167(57)>
bad_fork_cleanup_fs:
  exit_fs (p_10);

  # retval_169 = PHI <retval_54(24), retval_168(58)>
bad_fork_cleanup_files:
  exit_files (p_10);

  # retval_170 = PHI <retval_53(23), retval_169(59)>
bad_fork_cleanup_semundo:
  exit_sem (p_10);

  # retval_171 = PHI <retval_52(22), retval_170(60)>
bad_fork_cleanup_audit:
  _383 = p_10->audit_context;
  if (_383 != 0B)
    goto <bb 62>;
  else
    goto <bb 63> (bad_fork_cleanup_perf);

  <bb 62>:
  __audit_free (p_10);

  # retval_172 = PHI <retval_50(21), retval_171(62), retval_171(61)>
bad_fork_cleanup_perf:
  perf_event_free_task (p_10);

  # retval_173 = PHI <retval_48(19), retval_49(20), retval_172(63)>
bad_fork_cleanup_policy:
  _139 = p_10->mempolicy;
  if (_139 != 0B)
    goto <bb 65>;
  else
    goto <bb 66> (bad_fork_cleanup_threadgroup_lock);

  <bb 65>:
  __mpol_put (_139);

  # retval_174 = PHI <retval_46(18), retval_173(65), retval_173(64)>
bad_fork_cleanup_threadgroup_lock:
  _387 = p_10->delays;
  if (_387 != 0B)
    goto <bb 67>;
  else
    goto <bb 68>;

  <bb 67>:
  delayacct_cache.20_388 = delayacct_cache;
  kmem_cache_free (delayacct_cache.20_388, _387);

  <bb 68>:
  p_10->delays = 0B;
  pretmp_551 = (long int) retval_174;
  pretmp_553 = (void *) pretmp_551;
  pretmp_555 = (long unsigned int) retval_174;

  # prephitmp_554 = PHI <-11B(13), pretmp_553(68)>
  # prephitmp_556 = PHI <18446744073709551605(13), pretmp_555(68)>
bad_fork_cleanup_count:
  _140 = p_10->cred;
  _141 = _140->user;
  _142 = &_141->processes;
  __asm__ __volatile__(".pushsection .smp_locks,"a"
.balign 4
.long 671f - .
.popsection
671:
	lock; decl %0" : "=m" _142->counter : "m" _142->counter);
  exit_creds (p_10);

  # prephitmp_547 = PHI <-11B(11), pretmp_545(12), prephitmp_554(69)>
  # prephitmp_550 = PHI <18446744073709551605(11), pretmp_548(12), prephitmp_556(69)>
bad_fork_free:
  free_task (p_10);

  # prephitmp_538 = PHI <pretmp_536(5), -12B(6), prephitmp_547(70)>
  # prephitmp_541 = PHI <pretmp_539(5), 18446744073709551604(6), prephitmp_550(70)>
fork_out:

  <bb 72>:
  # _146 = PHI <prephitmp_538(71), p_10(48)>
  # prephitmp_558 = PHI <prephitmp_541(71), pretmp_557(48)>
  cgrp_ss_priv ={v} {CLOBBER};
  if (prephitmp_558 <= 18446744073709547520)
    goto <bb 73>;
  else
    goto <bb 87>;

  <bb 73>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___151 : "p" &current_task);
  __asm__ __volatile__ goto("1:.byte 0x0f,0x1f,0x44,0x00,0
	.pushsection __jump_table,  "aw" 
	 .balign 8 
	 .quad 1b, %l2, %c0 + %c1 
	.popsection 
	" :  : "i" &__tracepoint_sched_process_fork.key, "i" 0 :  : "l_yes" <L19>);

  <bb 74>:
  __asm__ __volatile__("");
  goto <bb 78>;

  <bb 75>:

  <bb 76>:
  # it_func_ptr_392 = PHI <it_func_ptr_391(91), it_func_ptr_396(75)>
  # prephitmp_532 = PHI <pretmp_531(91), _397(75)>
  __data_394 = MEM[base: it_func_ptr_392, offset: 8B];
  it_func.78_395 = (void (*<T6b5e>) (void *, struct task_struct *, struct task_struct *)) prephitmp_532;
  it_func.78_395 (__data_394, pfo_ret___151, _146);
  it_func_ptr_396 = it_func_ptr_392 + 16;
  _397 = MEM[base: it_func_ptr_396, offset: 0B];
  if (_397 != 0B)
    goto <bb 75>;
  else
    goto <bb 77>;

  <bb 77>:
  __asm__ __volatile__("" :  :  : "memory");

  <bb 78>:
  pid_152 = get_task_pid (_146, 0);
  _153 = pid_vnr (pid_152);
  nr_154 = (long int) _153;
  _146->vfork_done = &vfork;
  vfork.done = 0;
  __init_waitqueue_head (&vfork.wait, "&x->wait", &__key);
  _155 = &_146->usage;
  __asm__ __volatile__(".pushsection .smp_locks,"a"
.balign 4
.long 671f - .
.popsection
671:
	lock; incl %0" : "=m" _155->counter : "m" _155->counter);
  wake_up_new_task (_146);
  if (trace_91 != 0)
    goto <bb 79>;
  else
    goto <bb 80>;

  <bb 79>:
  ptrace_event_pid (trace_91, pid_152);

  <bb 80>:
  _159 = wait_for_vfork_done (_146, &vfork);
  if (_159 == 0)
    goto <bb 82>;
  else
    goto <bb 81>;

  <bb 81>:
  goto <bb 86>;

  <bb 82>:
  __asm__ __volatile__("" :  :  : "memory");
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___400 : "p" &current_task);
  _401 ={v} MEM[(volatile __u64 *)pfo_ret___400 + 1048B];
  ________p1_402 = (struct task_struct *) _401;
  ns_403 = task_active_pid_ns (________p1_402);
  if (ns_403 != 0B)
    goto <bb 83>;
  else
    goto <bb 84>;

  <bb 83>:
  _404 = pid_nr_ns (pid_152, ns_403);
  message_405 = (long unsigned int) _404;

  <bb 84>:
  # message_406 = PHI <0(82), message_405(83)>
  __asm__ __volatile__("" :  :  : "memory");
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___407 : "p" &current_task);
  _408 = pfo_ret___407->ptrace;
  _412 = _408 & 256;
  if (_412 != 0)
    goto <bb 85>;
  else
    goto <bb 81>;

  <bb 85>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___416 : "p" &current_task);
  pfo_ret___416->ptrace_message = message_406;
  ptrace_notify (1285);

  <bb 86>:
  put_pid (pid_152);
  vfork ={v} {CLOBBER};
  goto <bb 88>;

  <bb 87>:
  nr_160 = (long int) _146;

  <bb 88>:
  # nr_161 = PHI <nr_154(86), nr_160(87)>
  return nr_161;

  <bb 89>:
  p_10->set_child_tid = 0B;
  p_10->clear_child_tid = 0B;
  p_10->plug = 0B;
  p_10->robust_list = 0B;
  p_10->compat_robust_list = 0B;
  _94 = &p_10->pi_state_list;
  MEM[(struct list_head *)p_10 + 1928B].next = _94;
  MEM[(struct list_head *)p_10 + 1928B].prev = _94;
  p_10->pi_state_cache = 0B;
  user_disable_single_step (p_10);
  clear_tsk_thread_flag (p_10, 0);
  clear_tsk_thread_flag (p_10, 6);
  goto <bb 36>;

<L19>:
  __asm__ __volatile__("" :  :  : "memory");
  _390 ={v} MEM[(volatile __u64 *)&__tracepoint_sched_process_fork + 48B];
  it_func_ptr_391 = (struct tracepoint_func *) _390;
  if (it_func_ptr_391 != 0B)
    goto <bb 91>;
  else
    goto <bb 77>;

  <bb 91>:
  pretmp_531 = it_func_ptr_391->func;
  goto <bb 76>;

}



;; Function SyS_clone (SyS_clone, funcdef_no=3663, decl_uid=51096, cgraph_uid=3665)

SyS_clone (long int clone_flags, long int newsp, long int parent_tidptr, long int child_tidptr, long int tls)
{
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * ________p1;
  struct pid_namespace * ns;
  long unsigned int message;
  static struct lock_class_key __key;
  void (*<T6b5e>) (void *, struct task_struct *, struct task_struct *) it_func.78;
  struct tracepoint_func * it_func_ptr;
  void * __data;
  struct kmem_cache * delayacct_cache.20;
  struct pid_namespace * ns;
  pid_t nr;
  struct mempolicy * pol;
  union ktime_t D.56355;
  s64 SR.313;
  union ktime D.56352;
  int delayacct_on.53;
  struct task_struct * pfo_ret__;
  int nr_threads.42;
  int max_threads.43;
  int * iftmp.44;
  int * iftmp.45;
  int iftmp.46;
  int nr_threads.47;
  long unsigned int total_forks.48;
  long unsigned int total_forks.49;
  int retval;
  struct task_struct * p;
  void * cgrp_ss_priv[0:];
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  long unsigned int ptr.74;
  long unsigned int ptr.74;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct pid * pid;
  struct task_struct * pfo_ret__;
  int __ret_pu;
  struct pid * pid;
  struct completion vfork;
  int trace;
  long int ret;
  long unsigned int clone_flags.89;
  long unsigned int newsp.88;
  int * parent_tidptr.87;
  int * child_tidptr.86;
  long unsigned int tls.85;
  long unsigned int _14;
  long unsigned int _15;
  long unsigned int _16;
  long unsigned int _23;
  long unsigned int _24;
  long unsigned int _25;
  long unsigned int _26;
  long unsigned int _27;
  struct signal_struct * _29;
  unsigned int _30;
  unsigned int _31;
  long unsigned int _32;
  long unsigned int _33;
  struct pid_namespace * _35;
  struct nsproxy * _37;
  struct pid_namespace * _38;
  const struct cred * _42;
  struct user_struct * _43;
  int _44;
  long unsigned int _45;
  _Bool _49;
  _Bool _50;
  unsigned int _52;
  unsigned int _53;
  unsigned int _57;
  unsigned int _58;
  unsigned int _59;
  struct list_head * _60;
  struct list_head * _61;
  struct task_rss_stat * _64;
  long unsigned int _66;
  struct task_io_accounting * _67;
  long int _77;
  struct list_head * _83;
  struct nsproxy * _93;
  struct pid_namespace * _94;
  long int _100;
  long unsigned int _102;
  long unsigned int _104;
  struct list_head * _106;
  long unsigned int _107;
  struct task_struct * _111;
  int _113;
  struct task_struct * _115;
  int _116;
  int _117;
  int _118;
  struct list_head * _119;
  long unsigned int _121;
  struct task_struct * _123;
  unsigned int _125;
  unsigned int _128;
  struct sighand_struct * _130;
  struct raw_spinlock * _131;
  int _133;
  struct sighand_struct * _135;
  int _137;
  long unsigned int _141;
  struct signal_struct * _152;
  unsigned int _153;
  unsigned int _154;
  struct signal_struct * _155;
  struct signal_struct * _156;
  struct signal_struct * _158;
  struct tty_struct * _159;
  struct tty_struct * _160;
  struct task_struct * _161;
  struct list_head * _162;
  struct list_head * _163;
  struct signal_struct * _165;
  int _166;
  int _167;
  struct signal_struct * _169;
  struct atomic_t * _170;
  struct signal_struct * _172;
  struct atomic_t * _173;
  struct task_struct * _174;
  struct list_head * _175;
  struct signal_struct * _176;
  struct list_head * _177;
  struct list_head * _178;
  struct sighand_struct * _184;
  struct io_context * _187;
  struct mm_struct * _188;
  struct signal_struct * _189;
  struct sighand_struct * _190;
  struct mempolicy * _191;
  const struct cred * _193;
  struct user_struct * _194;
  struct atomic_t * _195;
  struct task_struct * _199;
  int _206;
  long unsigned int _208;
  long unsigned int _210;
  struct atomic_t * _211;
  int _215;
  unsigned int _233;
  unsigned int _237;
  struct signal_struct * _239;
  long long unsigned int _240;
  struct list_head * _242;
  long long int _243;
  u64 _244;
  u64 _246;
  _Bool _248;
  int _251;
  struct task_struct * _253;
  struct pid * _254;
  struct task_struct * _255;
  struct pid * _256;
  unsigned int _257;
  int _258;
  struct list_head * _263;
  struct list_head * _264;
  long long unsigned int _265;
  struct list_head * _266;
  long long unsigned int _267;
  struct list_head * _268;
  long long unsigned int _269;
  struct task_delay_info * _270;
  long long unsigned int _273;
  void * _280;
  long long unsigned int _284;
  int _287;
  unsigned int _291;
  unsigned int _295;
  unsigned int prephitmp_352;
  int _471;
  long unsigned int prephitmp_571;
  long unsigned int prephitmp_572;
  long unsigned int pretmp_600;
  long unsigned int pretmp_601;
  void * pretmp_610;
  void * prephitmp_611;
  long int pretmp_613;
  long unsigned int prephitmp_614;
  long unsigned int pretmp_616;
  void * prephitmp_617;
  void * pretmp_619;
  long int pretmp_622;
  long unsigned int prephitmp_623;
  long unsigned int pretmp_625;
  void * prephitmp_626;
  void * pretmp_628;
  long int pretmp_631;
  void * prephitmp_632;
  void * pretmp_633;
  long int pretmp_635;

  <bb 2>:
  clone_flags.89_10 = (long unsigned int) clone_flags_9(D);
  _14 = clone_flags.89_10 & 8388608;
  if (_14 == 0)
    goto <bb 3>;
  else
    goto <bb 8>;

  <bb 3>:
  _15 = clone_flags.89_10 & 16384;
  if (_15 != 0)
    goto <bb 6>;
  else
    goto <bb 4>;

  <bb 4>:
  _16 = clone_flags.89_10 & 255;
  if (_16 != 17)
    goto <bb 6>;
  else
    goto <bb 5>;

  <bb 5>:

  <bb 6>:
  # trace_18 = PHI <2(3), 3(4), 1(5)>
  # prephitmp_352 = PHI <32(3), 64(4), 16(5)>
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___17 : "p" &current_task);
  _233 = pfo_ret___17->ptrace;
  _237 = prephitmp_352 & _233;
  if (_237 == 0)
    goto <bb 8>;
  else
    goto <bb 7>;

  <bb 7>:

  <bb 8>:
  # trace_142 = PHI <0(2), trace_18(7), 0(6)>
  cgrp_ss_priv = {};
  _23 = clone_flags.89_10 & 131584;
  if (_23 == 131584)
    goto <bb 131>;
  else
    goto <bb 9>;

  <bb 9>:
  _24 = clone_flags.89_10 & 268435968;
  if (_24 == 268435968)
    goto <bb 131>;
  else
    goto <bb 10>;

  <bb 10>:
  _25 = clone_flags.89_10 & 67584;
  if (_25 == 65536)
    goto <bb 131>;
  else
    goto <bb 11>;

  <bb 11>:
  _26 = clone_flags.89_10 & 2304;
  if (_26 == 2048)
    goto <bb 131>;
  else
    goto <bb 12>;

  <bb 12>:
  _27 = clone_flags.89_10 & 32768;
  if (_27 != 0)
    goto <bb 13>;
  else
    goto <bb 14>;

  <bb 13>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___28 : "p" &current_task);
  _29 = pfo_ret___28->signal;
  _30 = _29->flags;
  _31 = _30 & 64;
  if (_31 != 0)
    goto <bb 131>;
  else
    goto <bb 14>;

  <bb 14>:
  _32 = clone_flags.89_10 & 65536;
  if (_32 != 0)
    goto <bb 16>;
  else
    goto <bb 15>;

  <bb 15>:
  retval_39 = security_task_create (clone_flags.89_10);
  if (retval_39 != 0)
    goto <bb 18>;
  else
    goto <bb 19>;

  <bb 16>:
  _33 = clone_flags.89_10 & 805306368;
  if (_33 != 0)
    goto <bb 131>;
  else
    goto <bb 17>;

  <bb 17>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___34 : "p" &current_task);
  _35 = task_active_pid_ns (pfo_ret___34);
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___36 : "p" &current_task);
  _37 = pfo_ret___36->nsproxy;
  _38 = _37->pid_ns_for_children;
  if (_35 != _38)
    goto <bb 131>;
  else
    goto <bb 15>;

  <bb 18>:
  pretmp_631 = (long int) retval_39;
  pretmp_628 = (void *) pretmp_631;
  pretmp_625 = (long unsigned int) retval_39;
  goto <bb 107> (fork_out);

  <bb 19>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___40 : "p" &current_task);
  p_41 = dup_task_struct (pfo_ret___40);
  if (p_41 == 0B)
    goto <bb 107> (fork_out);
  else
    goto <bb 20>;

  <bb 20>:
  p_41->pi_lock.raw_lock.val.counter = 0;
  p_41->pi_waiters.rb_node = 0B;
  p_41->pi_waiters_leftmost = 0B;
  p_41->pi_blocked_on = 0B;
  _42 = p_41->real_cred;
  _43 = _42->user;
  _44 ={v} MEM[(const int *)_43 + 4B];
  _45 = (long unsigned int) _44;
  _239 = MEM[(const struct task_struct *)p_41].signal;
  _240 ={v} MEM[(volatile __u64 *)_239].rlim[6].rlim_cur;
  if (_45 >= _240)
    goto <bb 22>;
  else
    goto <bb 21>;

  <bb 21>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___51 : "p" &current_task);
  _52 = pfo_ret___51->flags;
  _53 = _52 & 4294963199;
  pfo_ret___51->flags = _53;
  retval_54 = copy_creds (p_41, clone_flags.89_10);
  if (retval_54 < 0)
    goto <bb 25>;
  else
    goto <bb 26>;

  <bb 22>:
  if (_43 != &root_user)
    goto <bb 23>;
  else
    goto <bb 21>;

  <bb 23>:
  _49 = capable (24);
  if (_49 != 0)
    goto <bb 21>;
  else
    goto <bb 24>;

  <bb 24>:
  _50 = capable (21);
  if (_50 != 0)
    goto <bb 21>;
  else
    goto <bb 106> (bad_fork_free);

  <bb 25>:
  pretmp_622 = (long int) retval_54;
  pretmp_619 = (void *) pretmp_622;
  pretmp_616 = (long unsigned int) retval_54;
  goto <bb 106> (bad_fork_free);

  <bb 26>:
  nr_threads.42_55 = nr_threads;
  max_threads.43_56 = max_threads;
  if (nr_threads.42_55 >= max_threads.43_56)
    goto <bb 105> (bad_fork_cleanup_count);
  else
    goto <bb 27>;

  <bb 27>:
  p_41->delays = 0B;
  delayacct_on.53_241 = delayacct_on;
  if (delayacct_on.53_241 != 0)
    goto <bb 28>;
  else
    goto <bb 29>;

  <bb 28>:
  __delayacct_tsk_init (p_41);

  <bb 29>:
  _57 = p_41->flags;
  _58 = _57 & 4294967007;
  _59 = _58 | 64;
  p_41->flags = _59;
  _60 = &p_41->children;
  MEM[(struct list_head *)p_41 + 1056B].next = _60;
  MEM[(struct list_head *)p_41 + 1056B].prev = _60;
  _61 = &p_41->sibling;
  MEM[(struct list_head *)p_41 + 1072B].next = _61;
  MEM[(struct list_head *)p_41 + 1072B].prev = _61;
  p_41->vfork_done = 0B;
  p_41->alloc_lock.D.5408.rlock.raw_lock.val.counter = 0;
  MEM[(struct sigset_t *)p_41 + 1584B].sig[0] = 0;
  _242 = &MEM[(struct sigpending *)p_41 + 1568B].list;
  MEM[(struct list_head *)p_41 + 1568B].next = _242;
  MEM[(struct list_head *)p_41 + 1568B].prev = _242;
  p_41->gtime = 0;
  p_41->stime = 0;
  p_41->utime = 0;
  p_41->stimescaled = 0;
  p_41->utimescaled = 0;
  MEM[(struct prev_cputime *)p_41 + 1296B].stime = 0;
  MEM[(struct prev_cputime *)p_41 + 1296B].utime = 0;
  MEM[(struct prev_cputime *)p_41 + 1296B].lock.raw_lock.val.counter = 0;
  _64 = &p_41->rss_stat;
  memset (_64, 0, 16);
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___65 : "p" &current_task);
  _66 = pfo_ret___65->timer_slack_ns;
  p_41->default_timer_slack_ns = _66;
  _67 = &p_41->ioac;
  memset (_67, 0, 56);
  acct_clear_integrals (p_41);
  posix_cpu_timers_init (p_41);
  D.56352 = ktime_get ();
  _243 = D.56352.tv64;
  _244 = (u64) _243;
  p_41->start_time = _244;
  D.56355 = ktime_get_with_offset (1);
  SR.313_245 = MEM[(union ktime *)&D.56355];
  _246 = (u64) SR.313_245;
  p_41->real_start_time = _246;
  p_41->io_context = 0B;
  p_41->audit_context = 0B;
  if (_32 != 0)
    goto <bb 30>;
  else
    goto <bb 31>;

  <bb 30>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___70 : "p" &current_task);
  _cond_resched ();
  cgroup_threadgroup_change_begin (pfo_ret___70);

  <bb 31>:
  cgroup_fork (p_41);
  pol_71 = p_41->mempolicy;
  if (pol_71 != 0B)
    goto <bb 32>;
  else
    goto <bb 34>;

  <bb 32>:
  pol_247 = __mpol_dup (pol_71);
  p_41->mempolicy = pol_247;
  ptr.74_73 = (long unsigned int) pol_247;
  if (ptr.74_73 > 18446744073709547520)
    goto <bb 33>;
  else
    goto <bb 34>;

  <bb 33>:
  _77 = (long int) pol_247;
  retval_78 = (int) _77;
  p_41->mempolicy = 0B;
  goto <bb 100> (bad_fork_cleanup_threadgroup_lock);

  <bb 34>:
  p_41->cpuset_mem_spread_rotor = -1;
  p_41->cpuset_slab_spread_rotor = -1;
  MEM[(struct seqcount_t *)p_41 + 1872B].sequence = 0;
  p_41->pagefault_disabled = 0;
  retval_80 = sched_fork (clone_flags.89_10, p_41);
  if (retval_80 != 0)
    goto <bb 98> (bad_fork_cleanup_policy);
  else
    goto <bb 35>;

  <bb 35>:
  retval_81 = perf_event_init_task (p_41);
  if (retval_81 != 0)
    goto <bb 98> (bad_fork_cleanup_policy);
  else
    goto <bb 36>;

  <bb 36>:
  retval_82 = audit_alloc (p_41);
  if (retval_82 != 0)
    goto <bb 97> (bad_fork_cleanup_perf);
  else
    goto <bb 37>;

  <bb 37>:
  _83 = &p_41->sysvshm.shm_clist;
  MEM[(struct list_head *)p_41 + 1488B].next = _83;
  MEM[(struct list_head *)p_41 + 1488B].prev = _83;
  retval_84 = copy_semundo (clone_flags.89_10, p_41);
  if (retval_84 != 0)
    goto <bb 96> (bad_fork_cleanup_audit);
  else
    goto <bb 38>;

  <bb 38>:
  retval_85 = copy_files (clone_flags.89_10, p_41);
  if (retval_85 != 0)
    goto <bb 95> (bad_fork_cleanup_semundo);
  else
    goto <bb 39>;

  <bb 39>:
  retval_86 = copy_fs (clone_flags.89_10, p_41);
  if (retval_86 != 0)
    goto <bb 94> (bad_fork_cleanup_files);
  else
    goto <bb 40>;

  <bb 40>:
  retval_87 = copy_sighand (clone_flags.89_10, p_41);
  if (retval_87 != 0)
    goto <bb 93> (bad_fork_cleanup_fs);
  else
    goto <bb 41>;

  <bb 41>:
  retval_88 = copy_signal (clone_flags.89_10, p_41);
  if (retval_88 != 0)
    goto <bb 92> (bad_fork_cleanup_sighand);
  else
    goto <bb 42>;

  <bb 42>:
  retval_89 = copy_mm (clone_flags.89_10, p_41);
  if (retval_89 != 0)
    goto <bb 90> (bad_fork_cleanup_signal);
  else
    goto <bb 43>;

  <bb 43>:
  retval_90 = copy_namespaces (clone_flags.89_10, p_41);
  if (retval_90 != 0)
    goto <bb 88> (bad_fork_cleanup_mm);
  else
    goto <bb 44>;

  <bb 44>:
  retval_91 = copy_io (clone_flags.89_10, p_41);
  if (retval_91 != 0)
    goto <bb 87> (bad_fork_cleanup_namespaces);
  else
    goto <bb 45>;

  <bb 45>:
  newsp.88_8 = (long unsigned int) newsp_7(D);
  tls.85_2 = (long unsigned int) tls_1(D);
  retval_92 = copy_thread_tls (clone_flags.89_10, newsp.88_8, 0, p_41, tls.85_2);
  if (retval_92 != 0)
    goto <bb 85> (bad_fork_cleanup_io);
  else
    goto <bb 46>;

  <bb 46>:
  if (&init_struct_pid != 0B)
    goto <bb 47>;
  else
    goto <bb 49>;

  <bb 47>:
  _93 = p_41->nsproxy;
  _94 = _93->pid_ns_for_children;
  pid_95 = alloc_pid (_94);
  ptr.74_96 = (long unsigned int) pid_95;
  if (ptr.74_96 > 18446744073709547520)
    goto <bb 48>;
  else
    goto <bb 49>;

  <bb 48>:
  _100 = (long int) pid_95;
  retval_101 = (int) _100;
  goto <bb 85> (bad_fork_cleanup_io);

  <bb 49>:
  # pid_108 = PHI <0B(46), pid_95(47)>
  child_tidptr.86_4 = (int *) child_tidptr_3(D);
  _102 = clone_flags.89_10 & 16777216;
  if (_102 != 0)
    goto <bb 51>;
  else
    goto <bb 50>;

  <bb 50>:

  <bb 51>:
  # iftmp.44_103 = PHI <0B(50), child_tidptr.86_4(49)>
  p_41->set_child_tid = iftmp.44_103;
  _104 = clone_flags.89_10 & 2097152;
  if (_104 != 0)
    goto <bb 53>;
  else
    goto <bb 52>;

  <bb 52>:

  <bb 53>:
  # iftmp.45_105 = PHI <0B(52), child_tidptr.86_4(51)>
  p_41->clear_child_tid = iftmp.45_105;
  p_41->plug = 0B;
  p_41->robust_list = 0B;
  p_41->compat_robust_list = 0B;
  _106 = &p_41->pi_state_list;
  MEM[(struct list_head *)p_41 + 1928B].next = _106;
  MEM[(struct list_head *)p_41 + 1928B].prev = _106;
  p_41->pi_state_cache = 0B;
  _107 = clone_flags.89_10 & 16640;
  if (_107 == 256)
    goto <bb 54>;
  else
    goto <bb 55>;

  <bb 54>:
  p_41->sas_ss_size = 0;
  p_41->sas_ss_sp = 0;

  <bb 55>:
  user_disable_single_step (p_41);
  clear_tsk_thread_flag (p_41, 0);
  clear_tsk_thread_flag (p_41, 6);
  if (pid_108 != 0B)
    goto <bb 56>;
  else
    goto <bb 57>;

  <bb 56>:
  nr_249 = pid_108->numbers[0].nr;

  <bb 57>:
  # nr_250 = PHI <0(55), nr_249(56)>
  p_41->pid = nr_250;
  if (_32 != 0)
    goto <bb 58>;
  else
    goto <bb 59>;

  <bb 58>:
  p_41->exit_signal = -1;
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___110 : "p" &current_task);
  _111 = pfo_ret___110->group_leader;
  p_41->group_leader = _111;
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___112 : "p" &current_task);
  _113 = pfo_ret___112->tgid;
  p_41->tgid = _113;
  goto <bb 63>;

  <bb 59>:
  if (_27 != 0)
    goto <bb 60>;
  else
    goto <bb 61>;

  <bb 60>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___114 : "p" &current_task);
  _115 = pfo_ret___114->group_leader;
  _116 = _115->exit_signal;
  p_41->exit_signal = _116;
  goto <bb 62>;

  <bb 61>:
  _117 = (int) clone_flags_9(D);
  _118 = _117 & 255;
  p_41->exit_signal = _118;

  <bb 62>:
  p_41->group_leader = p_41;
  p_41->tgid = nr_250;

  <bb 63>:
  p_41->nr_dirtied = 0;
  p_41->nr_dirtied_pause = 32;
  p_41->dirty_paused_when = 0;
  p_41->pdeath_signal = 0;
  _119 = &p_41->thread_group;
  MEM[(struct list_head *)p_41 + 1200B].next = _119;
  MEM[(struct list_head *)p_41 + 1200B].prev = _119;
  p_41->task_works = 0B;
  retval_120 = cgroup_can_fork (p_41, &cgrp_ss_priv);
  if (retval_120 != 0)
    goto <bb 83> (bad_fork_free_pid);
  else
    goto <bb 64>;

  <bb 64>:
  _raw_write_lock_irq (&tasklist_lock);
  _121 = clone_flags.89_10 & 98304;
  if (_121 != 0)
    goto <bb 65>;
  else
    goto <bb 66>;

  <bb 65>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___122 : "p" &current_task);
  _123 = pfo_ret___122->real_parent;
  p_41->real_parent = _123;
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___124 : "p" &current_task);
  _125 = pfo_ret___124->parent_exec_id;
  p_41->parent_exec_id = _125;
  goto <bb 67>;

  <bb 66>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___126 : "p" &current_task);
  p_41->real_parent = pfo_ret___126;
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___127 : "p" &current_task);
  _128 = pfo_ret___127->self_exec_id;
  p_41->parent_exec_id = _128;

  <bb 67>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___129 : "p" &current_task);
  _130 = pfo_ret___129->sighand;
  _131 = &MEM[(struct spinlock_t *)_130 + 2056B].D.5408.rlock;
  _raw_spin_lock (_131);
  copy_seccomp (p_41);
  recalc_sigpending ();
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___132 : "p" &current_task);
  _133 = signal_pending (pfo_ret___132);
  if (_133 != 0)
    goto <bb 68>;
  else
    goto <bb 69>;

  <bb 68>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___134 : "p" &current_task);
  _135 = pfo_ret___134->sighand;
  __asm__ __volatile__("" :  :  : "memory");
  MEM[(volatile __u8 *)_135 + 2056B] ={v} 0;
  __asm__ __volatile__("" :  :  : "memory");
  __asm__ __volatile__("" :  :  : "memory");
  MEM[(volatile __u8 *)&tasklist_lock] ={v} 0;
  __asm__ __volatile__("sti" :  :  : "memory");
  __asm__ __volatile__("" :  :  : "memory");
  cgroup_cancel_fork (p_41, &cgrp_ss_priv);
  goto <bb 83> (bad_fork_free_pid);

  <bb 69>:
  _137 = p_41->pid;
  if (_137 != 0)
    goto <bb 70>;
  else
    goto <bb 80>;

  <bb 70>:
  _141 = clone_flags.89_10 & 8192;
  if (_141 != 0)
    goto <bb 72>;
  else
    goto <bb 71>;

  <bb 71>:
  _248 = trace_142 != 0;
  _471 = (int) _248;

  <bb 72>:
  # iftmp.46_143 = PHI <1(70), _471(71)>
  ptrace_init_task (p_41, iftmp.46_143);
  p_41->pids[0].pid = pid_108;
  _251 = p_41->exit_signal;
  if (_251 >= 0)
    goto <bb 73>;
  else
    goto <bb 78>;

  <bb 73>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___146 : "p" &current_task);
  _253 = pfo_ret___146->group_leader;
  _254 = _253->pids[1].pid;
  p_41->pids[1].pid = _254;
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___148 : "p" &current_task);
  _255 = pfo_ret___148->group_leader;
  _256 = _255->pids[2].pid;
  p_41->pids[2].pid = _256;
  _257 = pid_108->level;
  _258 = pid_108->numbers[_257].nr;
  if (_258 == 1)
    goto <bb 74>;
  else
    goto <bb 77>;

  <bb 74>:
  if (pid_108 != 0B)
    goto <bb 75>;
  else
    goto <bb 76>;

  <bb 75>:
  ns_261 = pid_108->numbers[_257].ns;

  <bb 76>:
  # ns_262 = PHI <0B(74), ns_261(75)>
  ns_262->child_reaper = p_41;
  _152 = p_41->signal;
  _153 = _152->flags;
  _154 = _153 | 64;
  _152->flags = _154;

  <bb 77>:
  _155 = p_41->signal;
  _155->leader_pid = pid_108;
  _156 = p_41->signal;
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___157 : "p" &current_task);
  _158 = pfo_ret___157->signal;
  _159 = _158->tty;
  _160 = tty_kref_get (_159);
  _156->tty = _160;
  _161 = p_41->real_parent;
  _162 = &_161->children;
  _263 = MEM[(struct list_head *)_161 + 1056B].prev;
  MEM[(struct list_head *)_161 + 1056B].prev = _61;
  MEM[(struct list_head *)p_41 + 1072B].next = _162;
  MEM[(struct list_head *)p_41 + 1072B].prev = _263;
  _263->next = _61;
  _163 = &p_41->tasks;
  _264 = MEM[(struct list_head *)&init_task + 792B].prev;
  MEM[(struct list_head *)p_41 + 792B].next = &init_task.tasks;
  MEM[(struct list_head *)p_41 + 792B].prev = _264;
  __asm__ __volatile__("" :  :  : "memory");
  _265 = (long long unsigned int) _163;
  MEM[(volatile __u64 *)_264] ={v} _265;
  MEM[(struct list_head *)&init_task + 792B].prev = _163;
  attach_pid (p_41, 1);
  attach_pid (p_41, 2);
  __asm__("incq %%gs:%0" : "=m" process_counts : "m" process_counts);
  goto <bb 79>;

  <bb 78>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___164 : "p" &current_task);
  _165 = pfo_ret___164->signal;
  _166 = _165->nr_threads;
  _167 = _166 + 1;
  _165->nr_threads = _167;
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___168 : "p" &current_task);
  _169 = pfo_ret___168->signal;
  _170 = &_169->live;
  __asm__ __volatile__(".pushsection .smp_locks,"a"
.balign 4
.long 671f - .
.popsection
671:
	lock; incl %0" : "=m" _170->counter : "m" _170->counter);
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___171 : "p" &current_task);
  _172 = pfo_ret___171->signal;
  _173 = &_172->sigcnt;
  __asm__ __volatile__(".pushsection .smp_locks,"a"
.balign 4
.long 671f - .
.popsection
671:
	lock; incl %0" : "=m" _173->counter : "m" _173->counter);
  _174 = p_41->group_leader;
  _175 = &_174->thread_group;
  _266 = MEM[(struct list_head *)_174 + 1200B].prev;
  MEM[(struct list_head *)p_41 + 1200B].next = _175;
  MEM[(struct list_head *)p_41 + 1200B].prev = _266;
  __asm__ __volatile__("" :  :  : "memory");
  _267 = (long long unsigned int) _119;
  MEM[(volatile __u64 *)_266] ={v} _267;
  MEM[(struct list_head *)_174 + 1200B].prev = _119;
  _176 = p_41->signal;
  _177 = &_176->thread_head;
  _178 = &p_41->thread_node;
  _268 = MEM[(struct list_head *)_176 + 16B].prev;
  MEM[(struct list_head *)p_41 + 1216B].next = _177;
  MEM[(struct list_head *)p_41 + 1216B].prev = _268;
  __asm__ __volatile__("" :  :  : "memory");
  _269 = (long long unsigned int) _178;
  MEM[(volatile __u64 *)_268] ={v} _269;
  MEM[(struct list_head *)_176 + 16B].prev = _178;

  <bb 79>:
  attach_pid (p_41, 0);
  nr_threads.42_179 = nr_threads;
  nr_threads.47_180 = nr_threads.42_179 + 1;
  nr_threads = nr_threads.47_180;

  <bb 80>:
  total_forks.48_181 = total_forks;
  total_forks.49_182 = total_forks.48_181 + 1;
  total_forks = total_forks.49_182;
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___183 : "p" &current_task);
  _184 = pfo_ret___183->sighand;
  __asm__ __volatile__("" :  :  : "memory");
  MEM[(volatile __u8 *)_184 + 2056B] ={v} 0;
  __asm__ __volatile__("" :  :  : "memory");
  syscall_tracepoint_update (p_41);
  __asm__ __volatile__("" :  :  : "memory");
  MEM[(volatile __u8 *)&tasklist_lock] ={v} 0;
  __asm__ __volatile__("sti" :  :  : "memory");
  __asm__ __volatile__("" :  :  : "memory");
  proc_fork_connector (p_41);
  cgroup_post_fork (p_41, &cgrp_ss_priv);
  if (_32 != 0)
    goto <bb 81>;
  else
    goto <bb 82>;

  <bb 81>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___186 : "p" &current_task);
  cgroup_threadgroup_change_end (pfo_ret___186);

  <bb 82>:
  perf_event_fork (p_41);
  trace_task_newtask (p_41, clone_flags.89_10);
  pretmp_601 = (long unsigned int) p_41;
  goto <bb 108>;

  # retval_218 = PHI <retval_120(63), -513(68)>
bad_fork_free_pid:
  if (pid_108 != &init_struct_pid)
    goto <bb 84>;
  else
    goto <bb 85> (bad_fork_cleanup_io);

  <bb 84>:
  free_pid (pid_108);

  # retval_219 = PHI <retval_92(45), retval_101(48), retval_218(83), retval_218(84)>
bad_fork_cleanup_io:
  _187 = p_41->io_context;
  if (_187 != 0B)
    goto <bb 86>;
  else
    goto <bb 87> (bad_fork_cleanup_namespaces);

  <bb 86>:
  exit_io_context (p_41);

  # retval_220 = PHI <retval_91(44), retval_219(85), retval_219(86)>
bad_fork_cleanup_namespaces:
  exit_task_namespaces (p_41);

  # retval_221 = PHI <retval_90(43), retval_220(87)>
bad_fork_cleanup_mm:
  _188 = p_41->mm;
  if (_188 != 0B)
    goto <bb 89>;
  else
    goto <bb 90> (bad_fork_cleanup_signal);

  <bb 89>:
  mmput (_188);

  # retval_222 = PHI <retval_89(42), retval_221(88), retval_221(89)>
bad_fork_cleanup_signal:
  if (_32 == 0)
    goto <bb 91>;
  else
    goto <bb 92> (bad_fork_cleanup_sighand);

  <bb 91>:
  _189 = p_41->signal;
  free_signal_struct (_189);

  # retval_223 = PHI <retval_88(41), retval_222(90), retval_222(91)>
bad_fork_cleanup_sighand:
  _190 = p_41->sighand;
  __cleanup_sighand (_190);

  # retval_224 = PHI <retval_87(40), retval_223(92)>
bad_fork_cleanup_fs:
  exit_fs (p_41);

  # retval_225 = PHI <retval_86(39), retval_224(93)>
bad_fork_cleanup_files:
  exit_files (p_41);

  # retval_226 = PHI <retval_85(38), retval_225(94)>
bad_fork_cleanup_semundo:
  exit_sem (p_41);

  # retval_227 = PHI <retval_84(37), retval_226(95)>
bad_fork_cleanup_audit:
  audit_free (p_41);

  # retval_228 = PHI <retval_82(36), retval_227(96)>
bad_fork_cleanup_perf:
  perf_event_free_task (p_41);

  # retval_229 = PHI <retval_80(34), retval_81(35), retval_228(97)>
bad_fork_cleanup_policy:
  _191 = p_41->mempolicy;
  if (_191 != 0B)
    goto <bb 99>;
  else
    goto <bb 100> (bad_fork_cleanup_threadgroup_lock);

  <bb 99>:
  __mpol_put (_191);

  # retval_230 = PHI <retval_78(33), retval_229(99), retval_229(98)>
bad_fork_cleanup_threadgroup_lock:
  if (_32 != 0)
    goto <bb 101>;
  else
    goto <bb 102>;

  <bb 101>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___192 : "p" &current_task);
  cgroup_threadgroup_change_end (pfo_ret___192);

  <bb 102>:
  _270 = p_41->delays;
  if (_270 != 0B)
    goto <bb 103>;
  else
    goto <bb 104>;

  <bb 103>:
  delayacct_cache.20_271 = delayacct_cache;
  kmem_cache_free (delayacct_cache.20_271, _270);

  <bb 104>:
  p_41->delays = 0B;
  pretmp_613 = (long int) retval_230;
  pretmp_610 = (void *) pretmp_613;
  pretmp_600 = (long unsigned int) retval_230;

  # prephitmp_611 = PHI <-11B(26), pretmp_610(104)>
  # prephitmp_571 = PHI <18446744073709551605(26), pretmp_600(104)>
bad_fork_cleanup_count:
  _193 = p_41->cred;
  _194 = _193->user;
  _195 = &_194->processes;
  __asm__ __volatile__(".pushsection .smp_locks,"a"
.balign 4
.long 671f - .
.popsection
671:
	lock; decl %0" : "=m" _195->counter : "m" _195->counter);
  exit_creds (p_41);

  # prephitmp_617 = PHI <-11B(24), pretmp_619(25), prephitmp_611(105)>
  # prephitmp_614 = PHI <18446744073709551605(24), pretmp_616(25), prephitmp_571(105)>
bad_fork_free:
  free_task (p_41);

  # prephitmp_626 = PHI <pretmp_628(18), -12B(19), prephitmp_617(106)>
  # prephitmp_623 = PHI <pretmp_625(18), 18446744073709551604(19), prephitmp_614(106)>
fork_out:

  <bb 108>:
  # _199 = PHI <prephitmp_626(107), p_41(82)>
  # prephitmp_572 = PHI <prephitmp_623(107), pretmp_601(82)>
  cgrp_ss_priv ={v} {CLOBBER};
  if (prephitmp_572 <= 18446744073709547520)
    goto <bb 109>;
  else
    goto <bb 128>;

  <bb 109>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___204 : "p" &current_task);
  __asm__ __volatile__ goto("1:.byte 0x0f,0x1f,0x44,0x00,0
	.pushsection __jump_table,  "aw" 
	 .balign 8 
	 .quad 1b, %l2, %c0 + %c1 
	.popsection 
	" :  : "i" &__tracepoint_sched_process_fork.key, "i" 0 :  : "l_yes" <L19>);

  <bb 110>:
  __asm__ __volatile__("");
  goto <bb 114>;

  <bb 111>:

  <bb 112>:
  # it_func_ptr_275 = PHI <it_func_ptr_274(133), it_func_ptr_279(111)>
  # prephitmp_632 = PHI <pretmp_633(133), _280(111)>
  __data_277 = MEM[base: it_func_ptr_275, offset: 8B];
  it_func.78_278 = (void (*<T6b5e>) (void *, struct task_struct *, struct task_struct *)) prephitmp_632;
  it_func.78_278 (__data_277, pfo_ret___204, _199);
  it_func_ptr_279 = it_func_ptr_275 + 16;
  _280 = MEM[base: it_func_ptr_279, offset: 0B];
  if (_280 != 0B)
    goto <bb 111>;
  else
    goto <bb 113>;

  <bb 113>:
  __asm__ __volatile__("" :  :  : "memory");

  <bb 114>:
  pid_205 = get_task_pid (_199, 0);
  _206 = pid_vnr (pid_205);
  ret_207 = (long int) _206;
  _208 = clone_flags.89_10 & 1048576;
  if (_208 != 0)
    goto <bb 115>;
  else
    goto <bb 116>;

  <bb 115>:
  parent_tidptr.87_6 = (int *) parent_tidptr_5(D);
  __asm__ __volatile__("call __put_user_4" : "=a" __ret_pu_209 : "0" _206, "c" parent_tidptr.87_6 : "ebx");

  <bb 116>:
  _210 = clone_flags.89_10 & 16384;
  if (_210 != 0)
    goto <bb 117>;
  else
    goto <bb 118>;

  <bb 117>:
  _199->vfork_done = &vfork;
  vfork.done = 0;
  __init_waitqueue_head (&vfork.wait, "&x->wait", &__key);
  _211 = &_199->usage;
  __asm__ __volatile__(".pushsection .smp_locks,"a"
.balign 4
.long 671f - .
.popsection
671:
	lock; incl %0" : "=m" _211->counter : "m" _211->counter);

  <bb 118>:
  wake_up_new_task (_199);
  if (trace_142 != 0)
    goto <bb 119>;
  else
    goto <bb 120>;

  <bb 119>:
  ptrace_event_pid (trace_142, pid_205);

  <bb 120>:
  if (_210 != 0)
    goto <bb 122>;
  else
    goto <bb 121>;

  <bb 121>:
  goto <bb 127>;

  <bb 122>:
  _215 = wait_for_vfork_done (_199, &vfork);
  if (_215 == 0)
    goto <bb 123>;
  else
    goto <bb 121>;

  <bb 123>:
  __asm__ __volatile__("" :  :  : "memory");
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___283 : "p" &current_task);
  _284 ={v} MEM[(volatile __u64 *)pfo_ret___283 + 1048B];
  ________p1_285 = (struct task_struct *) _284;
  ns_286 = task_active_pid_ns (________p1_285);
  if (ns_286 != 0B)
    goto <bb 124>;
  else
    goto <bb 125>;

  <bb 124>:
  _287 = pid_nr_ns (pid_205, ns_286);
  message_288 = (long unsigned int) _287;

  <bb 125>:
  # message_289 = PHI <0(123), message_288(124)>
  __asm__ __volatile__("" :  :  : "memory");
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___290 : "p" &current_task);
  _291 = pfo_ret___290->ptrace;
  _295 = _291 & 256;
  if (_295 != 0)
    goto <bb 126>;
  else
    goto <bb 121>;

  <bb 126>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___299 : "p" &current_task);
  pfo_ret___299->ptrace_message = message_289;
  ptrace_notify (1285);

  <bb 127>:
  put_pid (pid_205);
  vfork ={v} {CLOBBER};
  goto <bb 130>;

  <bb 128>:
  pretmp_635 = (long int) _199;

  <bb 129>:
  # ret_634 = PHI <pretmp_635(128), -22(131)>

  <bb 130>:
  # ret_217 = PHI <ret_207(127), ret_634(129)>
  return ret_217;

  <bb 131>:
  cgrp_ss_priv ={v} {CLOBBER};
  goto <bb 129>;

<L19>:
  __asm__ __volatile__("" :  :  : "memory");
  _273 ={v} MEM[(volatile __u64 *)&__tracepoint_sched_process_fork + 48B];
  it_func_ptr_274 = (struct tracepoint_func *) _273;
  if (it_func_ptr_274 != 0B)
    goto <bb 133>;
  else
    goto <bb 113>;

  <bb 133>:
  pretmp_633 = it_func_ptr_274->func;
  goto <bb 112>;

}



;; Function proc_caches_init (proc_caches_init, funcdef_no=3666, decl_uid=24735, cgraph_uid=3668) (unlikely executed)

proc_caches_init ()
{
  struct kmem_cache * vm_area_cachep.95;
  struct kmem_cache * mm_cachep.94;
  struct kmem_cache * fs_cachep.93;
  struct kmem_cache * files_cachep.92;
  struct kmem_cache * signal_cachep.91;
  struct kmem_cache * sighand_cachep.90;

  <bb 2>:
  sighand_cachep.90_3 = kmem_cache_create ("sighand_cache", 2088, 0, 794624, sighand_ctor);
  sighand_cachep = sighand_cachep.90_3;
  signal_cachep.91_6 = kmem_cache_create ("signal_cache", 1104, 0, 270336, 0B);
  signal_cachep = signal_cachep.91_6;
  files_cachep.92_9 = kmem_cache_create ("files_cache", 704, 0, 270336, 0B);
  files_cachep = files_cachep.92_9;
  fs_cachep.93_12 = kmem_cache_create ("fs_cache", 56, 0, 270336, 0B);
  fs_cachep = fs_cachep.93_12;
  mm_cachep.94_15 = kmem_cache_create ("mm_struct", 848, 0, 270336, 0B);
  mm_cachep = mm_cachep.94_15;
  vm_area_cachep.95_18 = kmem_cache_create ("vm_area_struct", 184, 8, 262144, 0B);
  vm_area_cachep = vm_area_cachep.95_18;
  mmap_init ();
  nsproxy_cache_init ();
  return;

}



;; Function SyS_unshare (SyS_unshare, funcdef_no=3670, decl_uid=51155, cgraph_uid=3673)

SyS_unshare (long int unshare_flags)
{
  struct fs_struct * fs;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct files_struct * new_fd.99;
  struct nsproxy * new_nsproxy.100;
  struct fs_struct * new_fs;
  struct files_struct * fd;
  struct files_struct * new_fd;
  struct nsproxy * new_nsproxy;
  int err;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  long unsigned int unshare_flags;
  long unsigned int _6;
  long unsigned int _9;
  long unsigned int _12;
  long unsigned int _15;
  long unsigned int _19;
  long unsigned int _22;
  long int prephitmp_28;
  long unsigned int _31;
  struct list_head * _34;
  struct raw_spinlock * _38;
  struct raw_spinlock * _42;
  int _45;
  int _46;
  long unsigned int _59;
  long unsigned int _60;
  struct list_head * _62;
  struct list_head * _63;
  long unsigned int _64;
  struct sighand_struct * _66;
  int _67;
  long unsigned int _68;
  _Bool _69;
  long unsigned int _73;
  int _74;
  long int pretmp_131;
  _Bool _152;
  long int pretmp_156;
  long int prephitmp_157;
  long int prephitmp_169;
  int _171;

  <bb 2>:
  unshare_flags_2 = (long unsigned int) unshare_flags_1(D);
  new_fd = 0B;
  new_nsproxy = 0B;
  _6 = unshare_flags_2 & 268435456;
  if (_6 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  unshare_flags_7 = unshare_flags_2 | 66048;

  <bb 4>:
  # unshare_flags_8 = PHI <unshare_flags_2(2), unshare_flags_7(3)>
  _9 = unshare_flags_8 & 256;
  if (_9 != 0)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  unshare_flags_10 = unshare_flags_8 | 2048;

  <bb 6>:
  # unshare_flags_11 = PHI <unshare_flags_8(4), unshare_flags_10(5)>
  _12 = unshare_flags_11 & 2048;
  if (_12 != 0)
    goto <bb 7>;
  else
    goto <bb 8>;

  <bb 7>:
  unshare_flags_13 = unshare_flags_11 | 65536;

  <bb 8>:
  # unshare_flags_14 = PHI <unshare_flags_11(6), unshare_flags_13(7)>
  _15 = unshare_flags_14 & 131072;
  if (_15 != 0)
    goto <bb 9>;
  else
    goto <bb 10>;

  <bb 9>:
  unshare_flags_16 = unshare_flags_14 | 512;

  <bb 10>:
  # unshare_flags_17 = PHI <unshare_flags_14(8), unshare_flags_16(9)>
  _59 = unshare_flags_17 & 18446744071628714239;
  if (_59 != 0)
    goto <bb 44>;
  else
    goto <bb 11>;

  <bb 11>:
  _60 = unshare_flags_17 & 67840;
  if (_60 != 0)
    goto <bb 12>;
  else
    goto <bb 13>;

  <bb 12>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___61 : "p" &current_task);
  _62 = &pfo_ret___61->thread_group;
  _63 = MEM[(const struct list_head *)pfo_ret___61 + 1200B].next;
  if (_62 != _63)
    goto <bb 44>;
  else
    goto <bb 13>;

  <bb 13>:
  _64 = unshare_flags_17 & 2304;
  if (_64 != 0)
    goto <bb 14>;
  else
    goto <bb 15>;

  <bb 14>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___65 : "p" &current_task);
  _66 = pfo_ret___65->sighand;
  _67 ={v} MEM[(const int *)_66];
  if (_67 > 1)
    goto <bb 44>;
  else
    goto <bb 15>;

  <bb 15>:
  _68 = unshare_flags_17 & 256;
  if (_68 != 0)
    goto <bb 16>;
  else
    goto <bb 43>;

  <bb 16>:
  _69 = current_is_single_threaded ();
  if (_69 != 0)
    goto <bb 43>;
  else
    goto <bb 44>;

  <bb 17>:
  if (fs_72 == 0B)
    goto <bb 45>;
  else
    goto <bb 18>;

  <bb 18>:
  _74 = fs_72->users;
  if (_74 == 1)
    goto <bb 45>;
  else
    goto <bb 19>;

  <bb 19>:
  new_fs_75 = copy_fs_struct (fs_72);
  if (new_fs_75 == 0B)
    goto <bb 42> (bad_unshare_out);
  else
    goto <bb 45>;

  <bb 20>:
  _22 = unshare_flags_17 & 268435456;
  if (_22 != 0)
    goto <bb 38> (bad_unshare_cleanup_fd);
  else
    goto <bb 47>;

  <bb 21>:
  _19 = unshare_flags_17 & 134479872;
  _152 = _19 != 0;
  _171 = (int) _152;
  if (new_fs_154 != 0B)
    goto <bb 25>;
  else
    goto <bb 22>;

  <bb 22>:
  new_fd.99_27 = new_fd;
  if (new_fd.99_27 != 0B)
    goto <bb 25>;
  else
    goto <bb 23>;

  <bb 23>:
  if (_171 != 0)
    goto <bb 26>;
  else
    goto <bb 24>;

  <bb 24>:
  new_nsproxy.100_29 = new_nsproxy;
  if (new_nsproxy.100_29 != 0B)
    goto <bb 27>;
  else
    goto <bb 42> (bad_unshare_out);

  <bb 25>:
  if (_171 != 0)
    goto <bb 26>;
  else
    goto <bb 27>;

  <bb 26>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___30 : "p" &current_task);
  exit_sem (pfo_ret___30);

  <bb 27>:
  _31 = unshare_flags_17 & 134217728;
  if (_31 != 0)
    goto <bb 28>;
  else
    goto <bb 29>;

  <bb 28>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___32 : "p" &current_task);
  exit_shm (pfo_ret___32);
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___33 : "p" &current_task);
  _34 = &pfo_ret___33->sysvshm.shm_clist;
  MEM[(struct list_head *)pfo_ret___33 + 1488B].next = _34;
  MEM[(struct list_head *)pfo_ret___33 + 1488B].prev = _34;

  <bb 29>:
  new_nsproxy.100_35 = new_nsproxy;
  if (new_nsproxy.100_35 != 0B)
    goto <bb 30>;
  else
    goto <bb 31>;

  <bb 30>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___36 : "p" &current_task);
  switch_task_namespaces (pfo_ret___36, new_nsproxy.100_35);

  <bb 31>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___37 : "p" &current_task);
  _38 = &MEM[(struct spinlock_t *)pfo_ret___37 + 1680B].D.5408.rlock;
  _raw_spin_lock (_38);
  if (new_fs_154 != 0B)
    goto <bb 32>;
  else
    goto <bb 35>;

  <bb 32>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___40 : "p" &current_task);
  new_fs_41 = pfo_ret___40->fs;
  _42 = &MEM[(struct spinlock_t *)new_fs_41 + 4B].D.5408.rlock;
  _raw_spin_lock (_42);
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___43 : "p" &current_task);
  pfo_ret___43->fs = new_fs_154;
  _45 = new_fs_41->users;
  _46 = _45 + -1;
  new_fs_41->users = _46;
  if (_46 != 0)
    goto <bb 33>;
  else
    goto <bb 34>;

  <bb 33>:

  <bb 34>:
  # new_fs_108 = PHI <new_fs_41(32), 0B(33)>
  __asm__ __volatile__("" :  :  : "memory");
  MEM[(volatile __u8 *)new_fs_41 + 4B] ={v} 0;
  __asm__ __volatile__("" :  :  : "memory");

  <bb 35>:
  # new_fs_107 = PHI <new_fs_154(31), new_fs_108(34)>
  new_fd.99_47 = new_fd;
  if (new_fd.99_47 != 0B)
    goto <bb 36>;
  else
    goto <bb 37>;

  <bb 36>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___48 : "p" &current_task);
  fd_49 = pfo_ret___48->files;
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___50 : "p" &current_task);
  pfo_ret___50->files = new_fd.99_47;
  new_fd = fd_49;

  <bb 37>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___51 : "p" &current_task);
  __asm__ __volatile__("" :  :  : "memory");
  MEM[(volatile __u8 *)pfo_ret___51 + 1680B] ={v} 0;
  __asm__ __volatile__("" :  :  : "memory");

  # new_fs_94 = PHI <new_fs_154(20), new_fs_154(48), new_fs_107(37)>
  # prephitmp_28 = PHI <-22(20), pretmp_156(48), 0(37)>
bad_unshare_cleanup_fd:
  new_fd.99_53 = new_fd;
  if (new_fd.99_53 != 0B)
    goto <bb 39>;
  else
    goto <bb 40> (bad_unshare_cleanup_fs);

  <bb 39>:
  put_files_struct (new_fd.99_53);

  # new_fs_88 = PHI <new_fs_154(46), new_fs_94(38), new_fs_94(39)>
  # prephitmp_169 = PHI <pretmp_131(46), prephitmp_28(38), prephitmp_28(39)>
bad_unshare_cleanup_fs:
  if (new_fs_88 != 0B)
    goto <bb 41>;
  else
    goto <bb 42> (bad_unshare_out);

  <bb 41>:
  free_fs_struct (new_fs_88);

  # prephitmp_157 = PHI <-22(44), -12(19), prephitmp_169(40), prephitmp_169(41), 0(24)>
bad_unshare_out:
  new_fd ={v} {CLOBBER};
  new_nsproxy ={v} {CLOBBER};
  return prephitmp_157;

  <bb 43>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___71 : "p" &current_task);
  fs_72 = pfo_ret___71->fs;
  _73 = unshare_flags_17 & 512;
  if (_73 == 0)
    goto <bb 45>;
  else
    goto <bb 17>;

  <bb 44>:
  goto <bb 42> (bad_unshare_out);

  <bb 45>:
  # new_fs_154 = PHI <new_fs_75(19), 0B(18), 0B(17), 0B(43)>
  err_21 = unshare_fd (unshare_flags_17, &new_fd);
  if (err_21 != 0)
    goto <bb 46>;
  else
    goto <bb 20>;

  <bb 46>:
  pretmp_131 = (long int) err_21;
  goto <bb 40> (bad_unshare_cleanup_fs);

  <bb 47>:
  err_25 = unshare_nsproxy_namespaces (unshare_flags_17, &new_nsproxy, 0B, new_fs_154);
  if (err_25 != 0)
    goto <bb 48>;
  else
    goto <bb 21>;

  <bb 48>:
  pretmp_156 = (long int) err_25;
  goto <bb 38> (bad_unshare_cleanup_fd);

}



;; Function unshare_files (unshare_files, funcdef_no=3672, decl_uid=27406, cgraph_uid=3675)

unshare_files (struct files_struct * * displaced)
{
  int error;
  struct files_struct * copy;
  struct task_struct * task;
  struct files_struct * copy.101;
  int _1;
  struct files_struct * _8;
  struct raw_spinlock * _18;

  <bb 2>:
  __asm__("movq %%gs:%P1,%0" : "=r" task_17 : "p" &current_task);
  copy = 0B;
  error_6 = unshare_fd (1024, &copy);
  if (error_6 != 0)
    goto <bb 4>;
  else
    goto <bb 3>;

  <bb 3>:
  copy.101_7 = copy;
  if (copy.101_7 == 0B)
    goto <bb 4>;
  else
    goto <bb 5>;

  <bb 4>:
  *displaced_9(D) = 0B;
  goto <bb 6>;

  <bb 5>:
  _8 = task_17->files;
  *displaced_9(D) = _8;
  _18 = &MEM[(struct spinlock_t *)task_17 + 1680B].D.5408.rlock;
  _raw_spin_lock (_18);
  copy.101_12 = copy;
  task_17->files = copy.101_12;
  __asm__ __volatile__("" :  :  : "memory");
  MEM[(volatile __u8 *)task_17 + 1680B] ={v} 0;
  __asm__ __volatile__("" :  :  : "memory");

  <bb 6>:
  # _1 = PHI <error_6(4), 0(5)>
  copy ={v} {CLOBBER};
  return _1;

}



;; Function sysctl_max_threads (sysctl_max_threads, funcdef_no=3673, decl_uid=8610, cgraph_uid=3676)

sysctl_max_threads (struct ctl_table * table, int write, void * buffer, size_t * lenp, loff_t * ppos)
{
  int max;
  int min;
  int threads;
  int ret;
  struct ctl_table t;
  unsigned int threads.104;
  int threads.103;
  int max_threads.102;
  int _1;
  _Bool _19;
  _Bool _20;
  _Bool _21;

  <bb 2>:
  max_threads.102_4 = max_threads;
  threads = max_threads.102_4;
  min = 20;
  max = 1073741823;
  t = *table_8(D);
  t.data = &threads;
  t.extra1 = &min;
  t.extra2 = &max;
  ret_18 = proc_dointvec_minmax (&t, write_13(D), buffer_14(D), lenp_15(D), ppos_16(D));
  _19 = ret_18 != 0;
  _20 = write_13(D) == 0;
  _21 = _19 | _20;
  if (_21 != 0)
    goto <bb 4>;
  else
    goto <bb 3>;

  <bb 3>:
  threads.103_22 = threads;
  threads.104_23 = (unsigned int) threads.103_22;
  set_max_threads (threads.104_23);

  <bb 4>:
  # _1 = PHI <ret_18(2), 0(3)>
  t ={v} {CLOBBER};
  threads ={v} {CLOBBER};
  min ={v} {CLOBBER};
  max ={v} {CLOBBER};
  return _1;

}



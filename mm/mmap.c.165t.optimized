
;; Function mapping_unmap_writable (mapping_unmap_writable, funcdef_no=1207, decl_uid=14754, cgraph_uid=1207)

mapping_unmap_writable (struct address_space * mapping)
{
  struct atomic_t * _2;

  <bb 2>:
  _2 = &mapping_1(D)->i_mmap_writable;
  __asm__ __volatile__(".pushsection .smp_locks,"a"
.balign 4
.long 671f - .
.popsection
671:
	lock; decl %0" : "=m" _2->counter : "m" _2->counter);
  return;

}



;; Function get_file (get_file, funcdef_no=1220, decl_uid=14911, cgraph_uid=1220)

get_file (struct file * f)
{
  struct atomic_long_t * _2;

  <bb 2>:
  _2 = &f_1(D)->f_count;
  __asm__ __volatile__(".pushsection .smp_locks,"a"
.balign 4
.long 671f - .
.popsection
671:
	lock; incq %0" : "=m" MEM[(struct atomic64_t *)_2].counter : "m" MEM[(struct atomic64_t *)_2].counter);
  return f_1(D);

}



;; Function allow_write_access (allow_write_access, funcdef_no=1258, decl_uid=16214, cgraph_uid=1258)

allow_write_access (struct file * file)
{
  struct inode * _4;
  struct atomic_t * _5;

  <bb 2>:
  if (file_2(D) != 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _4 = MEM[(const struct file *)file_2(D) + 32B];
  _5 = &_4->i_writecount;
  __asm__ __volatile__(".pushsection .smp_locks,"a"
.balign 4
.long 671f - .
.popsection
671:
	lock; incl %0" : "=m" _5->counter : "m" _5->counter);

  <bb 4>:
  return;

}



;; Function vm_get_page_prot (vm_get_page_prot, funcdef_no=2984, decl_uid=25294, cgraph_uid=2984)

vm_get_page_prot (long unsigned int vm_flags)
{
  struct pgprot_t D.40693;
  long unsigned int _2;
  long unsigned int _4;

  <bb 2>:
  _2 = vm_flags_1(D) & 15;
  _4 = protection_map[_2].pgprot;
  D.40693.pgprot = _4;
  return D.40693;

}



;; Function vm_memory_committed (vm_memory_committed, funcdef_no=2987, decl_uid=30983, cgraph_uid=2987)

vm_memory_committed ()
{
  s64 ret;
  long unsigned int _4;
  s64 _7;

  <bb 2>:
  ret_2 = MEM[(struct percpu_counter *)&vm_committed_as + 8B];
  __asm__ __volatile__("" :  :  : "memory");
  _7 = MAX_EXPR <ret_2, 0>;
  _4 = (long unsigned int) _7;
  return _4;

}



;; Function vma_compute_subtree_gap (vma_compute_subtree_gap, funcdef_no=2994, decl_uid=39793, cgraph_uid=2995)

vma_compute_subtree_gap (struct vm_area_struct * vma)
{
  long unsigned int max;
  struct vm_area_struct * _7;
  long unsigned int _8;
  struct rb_node * _10;
  struct rb_node * _12;
  long int _14;

  <bb 2>:
  max_6 = vma_5(D)->vm_start;
  _7 = vma_5(D)->vm_prev;
  if (_7 != 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _8 = _7->vm_end;
  max_9 = max_6 - _8;

  <bb 4>:
  # max_1 = PHI <max_6(2), max_9(3)>
  _10 = vma_5(D)->vm_rb.rb_left;
  if (_10 != 0B)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  max_11 = MEM[(struct vm_area_struct *)_10 + -32B].rb_subtree_gap;
  max_17 = MAX_EXPR <max_1, max_11>;

  <bb 6>:
  # max_2 = PHI <max_1(4), max_17(5)>
  _12 = vma_5(D)->vm_rb.rb_right;
  if (_12 != 0B)
    goto <bb 7>;
  else
    goto <bb 8>;

  <bb 7>:
  max_13 = MEM[(struct vm_area_struct *)_12 + -32B].rb_subtree_gap;
  max_24 = MAX_EXPR <max_2, max_13>;

  <bb 8>:
  # max_3 = PHI <max_2(6), max_24(7)>
  _14 = (long int) max_3;
  return _14;

}



;; Function vma_gap_callbacks_rotate (vma_gap_callbacks_rotate, funcdef_no=2997, decl_uid=39824, cgraph_uid=2998)

vma_gap_callbacks_rotate (struct rb_node * rb_old, struct rb_node * rb_new)
{
  struct vm_area_struct * old;
  long unsigned int _5;
  long int _7;
  long unsigned int _8;

  <bb 2>:
  old_2 = &MEM[(void *)rb_old_1(D) + -32B];
  _5 = MEM[(struct vm_area_struct *)rb_old_1(D) + -32B].rb_subtree_gap;
  MEM[(struct vm_area_struct *)rb_new_3(D) + -32B].rb_subtree_gap = _5;
  _7 = vma_compute_subtree_gap (old_2);
  _8 = (long unsigned int) _7;
  MEM[(struct vm_area_struct *)rb_old_1(D) + -32B].rb_subtree_gap = _8;
  return;

}



;; Function find_vma_links (find_vma_links, funcdef_no=3003, decl_uid=39872, cgraph_uid=3004)

find_vma_links (struct mm_struct * mm, long unsigned int addr, long unsigned int end, struct vm_area_struct * * pprev, struct rb_node * * * rb_link, struct rb_node * * rb_parent)
{
  const struct rb_node * __mptr;
  struct rb_node * * __rb_link;
  int _4;
  long unsigned int _11;
  long unsigned int _13;
  struct vm_area_struct * _21;

  <bb 2>:
  __rb_link_8 = &mm_7(D)->mm_rb.rb_node;
  goto <bb 8>;

  <bb 3>:
  _11 = MEM[(struct vm_area_struct *)__mptr_10 + -32B].vm_end;
  if (_11 > addr_12(D))
    goto <bb 4>;
  else
    goto <bb 6>;

  <bb 4>:
  _13 = MEM[(struct vm_area_struct *)__mptr_10 + -32B].vm_start;
  if (_13 < end_14(D))
    goto <bb 13>;
  else
    goto <bb 5>;

  <bb 5>:
  __rb_link_16 = &MEM[(struct rb_node *)__mptr_10].rb_left;
  goto <bb 7>;

  <bb 6>:
  __rb_link_17 = &MEM[(struct rb_node *)__mptr_10].rb_right;

  <bb 7>:
  # __rb_link_15 = PHI <__rb_link_16(5), __rb_link_17(6)>
  # __mptr_20 = PHI <__mptr_3(5), __mptr_10(6)>

  <bb 8>:
  # __rb_link_1 = PHI <__rb_link_15(7), __rb_link_8(2)>
  # __mptr_2 = PHI <__mptr_10(7), 0B(2)>
  # __mptr_3 = PHI <__mptr_20(7), 0B(2)>
  __mptr_10 = *__rb_link_1;
  if (__mptr_10 != 0B)
    goto <bb 3>;
  else
    goto <bb 9>;

  <bb 9>:
  # __rb_link_30 = PHI <__rb_link_1(8)>
  # __mptr_29 = PHI <__mptr_2(8)>
  # __mptr_28 = PHI <__mptr_3(8)>
  if (__mptr_28 != 0B)
    goto <bb 11>;
  else
    goto <bb 10>;

  <bb 10>:
  *pprev_18(D) = 0B;
  goto <bb 12>;

  <bb 11>:
  _21 = __mptr_28 + 18446744073709551584;
  *pprev_18(D) = _21;

  <bb 12>:
  *rb_link_23(D) = __rb_link_30;
  *rb_parent_25(D) = __mptr_29;

  <bb 13>:
  # _4 = PHI <-12(4), 0(12)>
  return _4;

}



;; Function special_mapping_close (special_mapping_close, funcdef_no=3057, decl_uid=40560, cgraph_uid=3061)

special_mapping_close (struct vm_area_struct * vma)
{
  <bb 2>:
  return;

}



;; Function special_mapping_name (special_mapping_name, funcdef_no=3058, decl_uid=40563, cgraph_uid=3062)

special_mapping_name (struct vm_area_struct * vma)
{
  void * _3;
  const char * _4;

  <bb 2>:
  _3 = vma_2(D)->vm_private_data;
  _4 = MEM[(struct vm_special_mapping *)_3].name;
  return _4;

}



;; Function init_user_reserve (init_user_reserve, funcdef_no=3070, decl_uid=40660, cgraph_uid=3074)

init_user_reserve ()
{
  long int x;
  long unsigned int _min1;
  long unsigned int free_kbytes;
  long unsigned int sysctl_user_reserve_kbytes.135;
  long unsigned int _9;

  <bb 2>:
  x_7 ={v} MEM[(const long int *)&vm_stat];
  x_10 = MAX_EXPR <x_7, 0>;
  _9 = (long unsigned int) x_10;
  free_kbytes_3 = _9 << 2;
  _min1_4 = free_kbytes_3 >> 5;
  sysctl_user_reserve_kbytes.135_5 = MIN_EXPR <_min1_4, 131072>;
  sysctl_user_reserve_kbytes = sysctl_user_reserve_kbytes.135_5;
  return 0;

}



;; Function init_admin_reserve (init_admin_reserve, funcdef_no=3071, decl_uid=40668, cgraph_uid=3075)

init_admin_reserve ()
{
  long int x;
  long unsigned int _min1;
  long unsigned int free_kbytes;
  long unsigned int sysctl_admin_reserve_kbytes.139;
  long unsigned int _9;

  <bb 2>:
  x_7 ={v} MEM[(const long int *)&vm_stat];
  x_10 = MAX_EXPR <x_7, 0>;
  _9 = (long unsigned int) x_10;
  free_kbytes_3 = _9 << 2;
  _min1_4 = free_kbytes_3 >> 5;
  sysctl_admin_reserve_kbytes.139_5 = MIN_EXPR <_min1_4, 8192>;
  sysctl_admin_reserve_kbytes = sysctl_admin_reserve_kbytes.139_5;
  return 0;

}



;; Function init_reserve_notifier (init_reserve_notifier, funcdef_no=3073, decl_uid=40688, cgraph_uid=3077) (unlikely executed)

init_reserve_notifier ()
{
  <bb 2>:
  return 0;

}



;; Function vm_unacct_memory (vm_unacct_memory, funcdef_no=2507, decl_uid=30988, cgraph_uid=2507)

vm_unacct_memory (long int pages)
{
  int vm_committed_as_batch.6;
  long int _2;

  <bb 2>:
  _2 = -pages_1(D);
  vm_committed_as_batch.6_5 = vm_committed_as_batch;
  __percpu_counter_add (&vm_committed_as, _2, vm_committed_as_batch.6_5);
  return;

}



;; Function __remove_shared_vm_struct (__remove_shared_vm_struct, funcdef_no=2989, decl_uid=39754, cgraph_uid=2989)

__remove_shared_vm_struct (struct vm_area_struct * vma, struct file * file, struct address_space * mapping)
{
  long unsigned int _5;
  long unsigned int _6;
  struct inode * _8;
  struct atomic_t * _9;
  long unsigned int _12;
  struct rb_root * _15;
  struct atomic_t * _17;
  long unsigned int pretmp_21;
  long unsigned int prephitmp_22;

  <bb 2>:
  _5 = vma_4(D)->vm_flags;
  _6 = _5 & 2048;
  if (_6 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _8 = MEM[(const struct file *)file_7(D) + 32B];
  _9 = &_8->i_writecount;
  __asm__ __volatile__(".pushsection .smp_locks,"a"
.balign 4
.long 671f - .
.popsection
671:
	lock; incl %0" : "=m" _9->counter : "m" _9->counter);
  pretmp_21 = vma_4(D)->vm_flags;

  <bb 4>:
  # prephitmp_22 = PHI <_5(2), pretmp_21(3)>
  _12 = prephitmp_22 & 8;
  if (_12 != 0)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  _17 = &mapping_13(D)->i_mmap_writable;
  __asm__ __volatile__(".pushsection .smp_locks,"a"
.balign 4
.long 671f - .
.popsection
671:
	lock; decl %0" : "=m" _17->counter : "m" _17->counter);

  <bb 6>:
  _15 = &mapping_13(D)->i_mmap;
  vma_interval_tree_remove (vma_4(D), _15);
  return;

}



;; Function __vma_link_file (__vma_link_file, funcdef_no=3006, decl_uid=39912, cgraph_uid=3007)

__vma_link_file (struct vm_area_struct * vma)
{
  struct address_space * mapping;
  struct file * file;
  long unsigned int _8;
  long unsigned int _9;
  struct inode * _10;
  struct atomic_t * _11;
  long unsigned int _14;
  struct atomic_t * _15;
  struct rb_root * _17;
  long unsigned int pretmp_22;
  long unsigned int prephitmp_23;

  <bb 2>:
  file_6 = vma_5(D)->vm_file;
  if (file_6 != 0B)
    goto <bb 3>;
  else
    goto <bb 8>;

  <bb 3>:
  mapping_7 = file_6->f_mapping;
  _8 = vma_5(D)->vm_flags;
  _9 = _8 & 2048;
  if (_9 != 0)
    goto <bb 4>;
  else
    goto <bb 5>;

  <bb 4>:
  _10 = MEM[(const struct file *)file_6 + 32B];
  _11 = &_10->i_writecount;
  __asm__ __volatile__(".pushsection .smp_locks,"a"
.balign 4
.long 671f - .
.popsection
671:
	lock; decl %0" : "=m" _11->counter : "m" _11->counter);
  pretmp_22 = vma_5(D)->vm_flags;

  <bb 5>:
  # prephitmp_23 = PHI <_8(3), pretmp_22(4)>
  _14 = prephitmp_23 & 8;
  if (_14 != 0)
    goto <bb 6>;
  else
    goto <bb 7>;

  <bb 6>:
  _15 = &mapping_7->i_mmap_writable;
  __asm__ __volatile__(".pushsection .smp_locks,"a"
.balign 4
.long 671f - .
.popsection
671:
	lock; incl %0" : "=m" _15->counter : "m" _15->counter);

  <bb 7>:
  _17 = &mapping_7->i_mmap;
  vma_interval_tree_insert (vma_5(D), _17);

  <bb 8>:
  return;

}



;; Function deny_write_access (deny_write_access, funcdef_no=1256, decl_uid=16207, cgraph_uid=1256)

deny_write_access (struct file * file)
{
  int v;
  volatile u32 * __ptr;
  int iftmp.71;
  struct inode * _4;
  int _7;

  <bb 2>:
  _4 = MEM[(const struct file *)file_3(D) + 32B];

  <bb 3>:
  # v_20 = PHI <v_9(5), 0(2)>
  _7 = v_20 + -1;
  __ptr_8 = &MEM[(struct atomic_t *)_4 + 320B].counter;
  __asm__ __volatile__(".pushsection .smp_locks,"a"
.balign 4
.long 671f - .
.popsection
671:
	lock; cmpxchgl %2,%1" : "=a" v_9, "=m" *__ptr_8 : "r" _7, "0" v_20, "m" *__ptr_8 : "memory");
  if (v_20 == v_9)
    goto <bb 6>;
  else
    goto <bb 4>;

  <bb 4>:
  if (v_9 <= 0)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  goto <bb 3>;

  <bb 6>:
  # iftmp.71_1 = PHI <0(3), -26(4)>
  return iftmp.71_1;

}



;; Function mapping_map_writable (mapping_map_writable, funcdef_no=1206, decl_uid=14751, cgraph_uid=1206)

mapping_map_writable (struct address_space * mapping)
{
  int v;
  volatile u32 * __ptr;
  int iftmp.72;
  int _6;

  <bb 2>:

  <bb 3>:
  # v_19 = PHI <v_8(5), 0(2)>
  _6 = v_19 + 1;
  __ptr_7 = &MEM[(struct atomic_t *)mapping_2(D) + 28B].counter;
  __asm__ __volatile__(".pushsection .smp_locks,"a"
.balign 4
.long 671f - .
.popsection
671:
	lock; cmpxchgl %2,%1" : "=a" v_8, "=m" *__ptr_7 : "r" _6, "0" v_19, "m" *__ptr_7 : "memory");
  if (v_19 == v_8)
    goto <bb 6>;
  else
    goto <bb 4>;

  <bb 4>:
  if (v_8 >= 0)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  goto <bb 3>;

  <bb 6>:
  # iftmp.72_1 = PHI <0(3), -1(4)>
  return iftmp.72_1;

}



;; Function reusable_anon_vma (reusable_anon_vma, funcdef_no=3018, decl_uid=40016, cgraph_uid=3019)

reusable_anon_vma (struct vm_area_struct * old, struct vm_area_struct * a, struct vm_area_struct * b)
{
  struct anon_vma * anon_vma;
  struct anon_vma * _1;
  struct list_head * _10;
  long long unsigned int _11;
  struct list_head * _12;
  struct list_head * _13;
  long unsigned int _15;
  long unsigned int _16;
  struct mempolicy * _17;
  struct mempolicy * _18;
  bool _19;
  struct file * _21;
  struct file * _22;
  long unsigned int _23;
  long unsigned int _24;
  long unsigned int _25;
  long unsigned int _26;
  long unsigned int _27;
  long unsigned int _28;
  long unsigned int _29;
  long unsigned int _30;
  long unsigned int _31;
  long unsigned int _32;
  long unsigned int _33;

  <bb 2>:
  _15 = a_3(D)->vm_end;
  _16 = b_4(D)->vm_start;
  if (_15 == _16)
    goto <bb 3>;
  else
    goto <bb 11>;

  <bb 3>:
  _17 = b_4(D)->vm_policy;
  _18 = a_3(D)->vm_policy;
  if (_17 == _18)
    goto <bb 4>;
  else
    goto <bb 5>;

  <bb 4>:
  _21 = a_3(D)->vm_file;
  _22 = b_4(D)->vm_file;
  if (_21 == _22)
    goto <bb 6>;
  else
    goto <bb 11>;

  <bb 5>:
  _19 = __mpol_equal (_18, _17);
  if (_19 != 0)
    goto <bb 4>;
  else
    goto <bb 11>;

  <bb 6>:
  _23 = a_3(D)->vm_flags;
  _24 = b_4(D)->vm_flags;
  _25 = _24 ^ _23;
  _26 = _25 & 18446744073709551608;
  if (_26 == 0)
    goto <bb 7>;
  else
    goto <bb 11>;

  <bb 7>:
  _27 = b_4(D)->vm_pgoff;
  _28 = a_3(D)->vm_pgoff;
  _29 = b_4(D)->vm_start;
  _30 = a_3(D)->vm_start;
  _31 = _29 - _30;
  _32 = _31 >> 12;
  _33 = _32 + _28;
  if (_27 == _33)
    goto <bb 12>;
  else
    goto <bb 11>;

  <bb 8>:
  _10 = &old_7(D)->anon_vma_chain;
  _12 = MEM[(const struct list_head *)old_7(D) + 120B].next;
  if (_10 != _12)
    goto <bb 9>;
  else
    goto <bb 11>;

  <bb 9>:
  _13 = MEM[(const struct list_head *)old_7(D) + 120B].prev;
  if (_12 == _13)
    goto <bb 10>;
  else
    goto <bb 11>;

  <bb 10>:
  # _1 = PHI <anon_vma_9(9), 0B(12), 0B(11)>
  return _1;

  <bb 11>:
  goto <bb 10>;

  <bb 12>:
  _11 ={v} MEM[(volatile __u64 *)old_7(D) + 136B];
  anon_vma_9 = (struct anon_vma *) _11;
  if (anon_vma_9 != 0B)
    goto <bb 8>;
  else
    goto <bb 10>;

}



;; Function locks_verify_locked (locks_verify_locked, funcdef_no=1239, decl_uid=15860, cgraph_uid=1239) (unlikely executed)

locks_verify_locked (struct file * file)
{
  int _1;
  struct inode * _5;
  int _7;
  struct super_block * _8;
  long unsigned int _9;
  long unsigned int _10;
  short unsigned int _11;
  short unsigned int _12;

  <bb 2>:
  _5 = MEM[(const struct file *)file_4(D) + 32B];
  _8 = _5->i_sb;
  _9 = _8->s_flags;
  _10 = _9 & 64;
  if (_10 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _11 = MEM[(struct inode *)_5];
  _12 = _11 & 1032;
  if (_12 == 1024)
    goto <bb 5>;
  else
    goto <bb 4>;

  <bb 4>:
  # _1 = PHI <_7(5), 0(3), 0(2)>
  return _1;

  <bb 5>:
  _7 = locks_mandatory_locked (file_4(D));
  goto <bb 4>;

}



;; Function is_file_hugepages (is_file_hugepages, funcdef_no=2712, decl_uid=36954, cgraph_uid=2712) (unlikely executed)

is_file_hugepages (struct file * file)
{
  int _1;
  const struct file_operations * _5;
  int _7;
  _Bool _8;
  int _9;

  <bb 2>:
  _5 = file_4(D)->f_op;
  if (_5 == &hugetlbfs_file_operations)
    goto <bb 4>;
  else
    goto <bb 3>;

  <bb 3>:
  _7 = is_file_shm_hugepages (file_4(D));
  _8 = _7 != 0;
  _9 = (int) _8;

  <bb 4>:
  # _1 = PHI <1(2), _9(3)>
  return _1;

}



;; Function accountable_mapping (accountable_mapping, funcdef_no=3028, decl_uid=40148, cgraph_uid=3030)

accountable_mapping (struct file * file, vm_flags_t vm_flags)
{
  int _1;
  long unsigned int _8;
  _Bool _9;
  int _10;
  const struct file_operations * _11;
  int _12;

  <bb 2>:
  if (file_4(D) != 0B)
    goto <bb 4>;
  else
    goto <bb 3>;

  <bb 3>:
  _8 = vm_flags_7(D) & 2097162;
  _9 = _8 == 2;
  _10 = (int) _9;
  goto <bb 6>;

  <bb 4>:
  _11 = file_4(D)->f_op;
  if (_11 == &hugetlbfs_file_operations)
    goto <bb 7>;
  else
    goto <bb 5>;

  <bb 5>:
  _12 = is_file_shm_hugepages (file_4(D));
  if (_12 != 0)
    goto <bb 7>;
  else
    goto <bb 3>;

  <bb 6>:
  # _1 = PHI <0(7), _10(3)>
  return _1;

  <bb 7>:
  goto <bb 6>;

}



;; Function unmap_region (unmap_region, funcdef_no=3040, decl_uid=39689, cgraph_uid=3042)

unmap_region (struct mm_struct * mm, struct vm_area_struct * vma, struct vm_area_struct * prev, long unsigned int start, long unsigned int end)
{
  long int val;
  long int val;
  struct mmu_gather tlb;
  struct vm_area_struct * next;
  long unsigned int iftmp.75;
  long unsigned int iftmp.74;
  long unsigned int _23;
  long unsigned int _26;
  long unsigned int _27;
  long unsigned int _28;

  <bb 2>:
  if (prev_4(D) != 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  next_6 = prev_4(D)->vm_next;
  goto <bb 5>;

  <bb 4>:
  next_8 = mm_7(D)->mmap;

  <bb 5>:
  # next_1 = PHI <next_6(3), next_8(4)>
  lru_add_drain ();
  tlb_gather_mmu (&tlb, mm_7(D), start_10(D), end_11(D));
  val_21 ={v} MEM[(const long int *)mm_7(D) + 688B];
  val_31 = MAX_EXPR <val_21, 0>;
  _23 = (long unsigned int) val_31;
  val_24 ={v} MEM[(const long int *)mm_7(D) + 696B];
  val_32 = MAX_EXPR <val_24, 0>;
  _26 = (long unsigned int) val_32;
  _27 = _26 + _23;
  _28 = mm_7(D)->hiwater_rss;
  if (_27 > _28)
    goto <bb 6>;
  else
    goto <bb 7>;

  <bb 6>:
  mm_7(D)->hiwater_rss = _27;

  <bb 7>:
  unmap_vmas (&tlb, vma_14(D), start_10(D), end_11(D));
  if (next_1 != 0B)
    goto <bb 8>;
  else
    goto <bb 9>;

  <bb 8>:
  iftmp.74_16 = next_1->vm_start;

  <bb 9>:
  # iftmp.74_2 = PHI <iftmp.74_16(8), 0(7)>
  if (prev_4(D) != 0B)
    goto <bb 10>;
  else
    goto <bb 11>;

  <bb 10>:
  iftmp.75_17 = prev_4(D)->vm_end;

  <bb 11>:
  # iftmp.75_3 = PHI <iftmp.75_17(10), 0(9)>
  free_pgtables (&tlb, vma_14(D), iftmp.75_3, iftmp.74_2);
  tlb_finish_mmu (&tlb, start_10(D), end_11(D));
  tlb ={v} {CLOBBER};
  return;

}



;; Function remove_vma (remove_vma, funcdef_no=2991, decl_uid=39762, cgraph_uid=2991)

remove_vma (struct vm_area_struct * vma)
{
  struct vm_area_struct * next;
  struct kmem_cache * vm_area_cachep.108;
  const struct vm_operations_struct * _7;
  void (*<T38f8>) (struct vm_area_struct *) _8;
  struct file * _10;
  struct mempolicy * _12;

  <bb 2>:
  next_5 = vma_4(D)->vm_next;
  _cond_resched ();
  _7 = vma_4(D)->vm_ops;
  if (_7 != 0B)
    goto <bb 3>;
  else
    goto <bb 5>;

  <bb 3>:
  _8 = _7->close;
  if (_8 != 0B)
    goto <bb 4>;
  else
    goto <bb 5>;

  <bb 4>:
  _8 (vma_4(D));

  <bb 5>:
  _10 = vma_4(D)->vm_file;
  if (_10 != 0B)
    goto <bb 6>;
  else
    goto <bb 7>;

  <bb 6>:
  fput (_10);

  <bb 7>:
  _12 = vma_4(D)->vm_policy;
  if (_12 != 0B)
    goto <bb 8>;
  else
    goto <bb 9>;

  <bb 8>:
  __mpol_put (_12);

  <bb 9>:
  vm_area_cachep.108_14 = vm_area_cachep;
  kmem_cache_free (vm_area_cachep.108_14, vma_4(D));
  return next_5;

}



;; Function special_mapping_fault (special_mapping_fault, funcdef_no=3059, decl_uid=40558, cgraph_uid=3063)

special_mapping_fault (struct vm_area_struct * vma, struct vm_fault * vmf)
{
  struct page * * pages;
  long unsigned int pgoff;
  int _4;
  const struct vm_operations_struct * _8;
  void * _10;
  struct page * _14;
  struct page * _17;
  long unsigned int _20;
  long unsigned int _21;
  long unsigned int _22;
  struct page * _24;
  _Bool _26;
  struct atomic_t * _29;

  <bb 2>:
  _8 = vma_7(D)->vm_ops;
  if (_8 == &legacy_special_mapping_vmops)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  pages_9 = vma_7(D)->vm_private_data;
  goto <bb 5>;

  <bb 4>:
  _10 = vma_7(D)->vm_private_data;
  pages_11 = MEM[(struct vm_special_mapping *)_10].pages;

  <bb 5>:
  # pages_2 = PHI <pages_9(3), pages_11(4)>
  pgoff_13 = vmf_12(D)->pgoff;
  if (pgoff_13 != 0)
    goto <bb 6>;
  else
    goto <bb 11>;

  <bb 6>:
  _24 = *pages_2;
  if (_24 != 0B)
    goto <bb 7>;
  else
    goto <bb 16>;

  <bb 7>:

  <bb 8>:
  # pgoff_25 = PHI <pgoff_15(10), pgoff_13(7)>
  # pages_34 = PHI <pages_16(10), pages_2(7)>
  pgoff_15 = pgoff_25 + 18446744073709551615;
  pages_16 = pages_34 + 8;
  if (pgoff_15 != 0)
    goto <bb 9>;
  else
    goto <bb 11>;

  <bb 9>:
  _14 = MEM[base: pages_16, offset: 0B];
  if (_14 != 0B)
    goto <bb 10>;
  else
    goto <bb 16>;

  <bb 10>:
  goto <bb 8>;

  <bb 11>:
  # pages_27 = PHI <pages_16(8), pages_2(5)>
  _17 = *pages_27;
  if (_17 != 0B)
    goto <bb 12>;
  else
    goto <bb 16>;

  <bb 12>:
  _20 ={v} MEM[(const long unsigned int *)_17];
  _21 = _20 >> 15;
  _22 = _21 & 1;
  if (_22 != 0)
    goto <bb 14>;
  else
    goto <bb 13>;

  <bb 13>:
  _29 = &_17->D.17081.D.17080.D.17078._count;
  __asm__ __volatile__(".pushsection .smp_locks,"a"
.balign 4
.long 671f - .
.popsection
671:
	lock; incl %0" : "=m" _29->counter : "m" _29->counter);
  goto <bb 15>;

  <bb 14>:
  _26 = __get_page_tail (_17);
  if (_26 != 0)
    goto <bb 15>;
  else
    goto <bb 13>;

  <bb 15>:
  vmf_12(D)->page = _17;

  <bb 16>:
  # _4 = PHI <0(15), 2(9), 2(6), 2(11)>
  return _4;

}



;; Function get_unmapped_area (get_unmapped_area, funcdef_no=3032, decl_uid=25158, cgraph_uid=3034)

get_unmapped_area (struct file * file, long unsigned int addr, long unsigned int len, long unsigned int pgoff, long unsigned int flags)
{
  struct task_struct * pfo_ret__;
  u64 pfo_ret__;
  struct task_struct * pfo_ret__;
  long unsigned int error;
  long unsigned int (*<T2664>) (struct file *, long unsigned int, long unsigned int, long unsigned int, long unsigned int) get_area;
  long unsigned int iftmp.89;
  long unsigned int addr;
  struct task_struct * pfo_ret__;
  u64 pfo_ret__;
  long unsigned int iftmp.87;
  long unsigned int _1;
  unsigned int _7;
  unsigned int _8;
  long unsigned int _17;
  struct thread_info * _18;
  long unsigned int _19;
  long unsigned int _20;
  long unsigned int _21;
  struct mm_struct * _25;
  const struct file_operations * _27;
  long unsigned int _35;
  struct thread_info * _36;
  long unsigned int _37;
  long unsigned int _38;
  long unsigned int _39;
  unsigned int _41;
  unsigned int _42;
  long unsigned int _44;
  long unsigned int _45;
  int _46;
  long unsigned int _48;

  <bb 2>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___16 : "p" &cpu_tss.x86_tss.sp0);
  _17 = pfo_ret___16 + 18446744073709535232;
  _18 = (struct thread_info *) _17;
  _19 ={v} MEM[(const long unsigned int *)_18 + 8B];
  _20 = _19 >> 29;
  _21 = _20 & 1;
  if (_21 != 0)
    goto <bb 3>;
  else
    goto <bb 5>;

  <bb 3>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___22 : "p" &current_task);
  _7 = pfo_ret___22->personality;
  _8 = _7 & 134217728;
  if (_8 != 0)
    goto <bb 4>;
  else
    goto <bb 5>;

  <bb 4>:

  <bb 5>:
  # iftmp.87_2 = PHI <4294959104(3), 140737488351232(2), 3221225472(4)>
  if (iftmp.87_2 < len_9(D))
    goto <bb 18>;
  else
    goto <bb 6>;

  <bb 6>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___24 : "p" &current_task);
  _25 = pfo_ret___24->mm;
  get_area_26 = _25->get_unmapped_area;
  if (file_11(D) != 0B)
    goto <bb 7>;
  else
    goto <bb 9>;

  <bb 7>:
  _27 = file_11(D)->f_op;
  get_area_28 = _27->get_unmapped_area;
  if (get_area_28 != 0B)
    goto <bb 9>;
  else
    goto <bb 8>;

  <bb 8>:

  <bb 9>:
  # get_area_29 = PHI <get_area_26(6), get_area_26(8), get_area_28(7)>
  addr_30 = get_area_29 (file_11(D), addr_12(D), len_9(D), pgoff_13(D), flags_14(D));
  if (addr_30 > 18446744073709547520)
    goto <bb 17>;
  else
    goto <bb 10>;

  <bb 10>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___34 : "p" &cpu_tss.x86_tss.sp0);
  _35 = pfo_ret___34 + 18446744073709535232;
  _36 = (struct thread_info *) _35;
  _37 ={v} MEM[(const long unsigned int *)_36 + 8B];
  _38 = _37 >> 29;
  _39 = _38 & 1;
  if (_39 != 0)
    goto <bb 11>;
  else
    goto <bb 13>;

  <bb 11>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___40 : "p" &current_task);
  _41 = pfo_ret___40->personality;
  _42 = _41 & 134217728;
  if (_42 != 0)
    goto <bb 12>;
  else
    goto <bb 13>;

  <bb 12>:

  <bb 13>:
  # iftmp.89_43 = PHI <140737488351232(10), 4294959104(11), 3221225472(12)>
  _44 = iftmp.89_43 - len_9(D);
  if (addr_30 > _44)
    goto <bb 17>;
  else
    goto <bb 14>;

  <bb 14>:
  _45 = addr_30 & 4095;
  if (_45 != 0)
    goto <bb 17>;
  else
    goto <bb 15>;

  <bb 15>:
  _46 = security_mmap_addr (addr_30);
  error_47 = (long unsigned int) _46;
  if (error_47 != 0)
    goto <bb 16>;
  else
    goto <bb 17>;

  <bb 16>:

  <bb 17>:
  # _48 = PHI <addr_30(9), 18446744073709551604(13), 18446744073709551594(14), addr_30(15), error_47(16)>

  <bb 18>:
  # _1 = PHI <_48(17), 18446744073709551604(5)>
  return _1;

}



;; Function find_vma (find_vma, funcdef_no=3033, decl_uid=25273, cgraph_uid=3035)

find_vma (struct mm_struct * mm, long unsigned int addr)
{
  const struct rb_node * __mptr;
  struct vm_area_struct * vma;
  struct vm_area_struct * vma;
  struct vm_area_struct * _1;
  long unsigned int _16;
  long unsigned int _17;

  <bb 2>:
  vma_7 = vmacache_find (mm_4(D), addr_5(D));
  if (vma_7 != 0B)
    goto <bb 14>;
  else
    goto <bb 3>;

  <bb 3>:
  __mptr_13 = mm_4(D)->mm_rb.rb_node;
  if (__mptr_13 != 0B)
    goto <bb 4>;
  else
    goto <bb 13>;

  <bb 4>:

  <bb 5>:
  # __mptr_10 = PHI <__mptr_23(10), __mptr_13(4)>
  # vma_9 = PHI <vma_22(10), 0B(4)>
  _16 = MEM[(struct vm_area_struct *)__mptr_10 + -32B].vm_end;
  if (addr_5(D) < _16)
    goto <bb 6>;
  else
    goto <bb 8>;

  <bb 6>:
  vma_15 = &MEM[(void *)__mptr_10 + -32B];
  _17 = MEM[(struct vm_area_struct *)__mptr_10 + -32B].vm_start;
  if (addr_5(D) >= _17)
    goto <bb 12>;
  else
    goto <bb 7>;

  <bb 7>:
  __mptr_18 = MEM[(struct rb_node *)__mptr_10].rb_left;
  goto <bb 9>;

  <bb 8>:
  __mptr_19 = MEM[(struct rb_node *)__mptr_10].rb_right;

  <bb 9>:
  # __mptr_23 = PHI <__mptr_18(7), __mptr_19(8)>
  # vma_22 = PHI <vma_15(7), vma_9(8)>
  if (__mptr_23 != 0B)
    goto <bb 10>;
  else
    goto <bb 11>;

  <bb 10>:
  goto <bb 5>;

  <bb 11>:
  # vma_20 = PHI <vma_22(9)>
  if (vma_20 != 0B)
    goto <bb 12>;
  else
    goto <bb 13>;

  <bb 12>:
  # vma_29 = PHI <vma_22(11), vma_15(6)>
  vmacache_update (addr_5(D), vma_29);

  <bb 13>:
  # vma_27 = PHI <vma_29(12), vma_20(11), 0B(3)>

  <bb 14>:
  # _1 = PHI <vma_7(2), vma_27(13)>
  return _1;

}



;; Function count_vma_pages_range (count_vma_pages_range, funcdef_no=3004, decl_uid=39888, cgraph_uid=3005)

count_vma_pages_range (struct mm_struct * mm, long unsigned int addr, long unsigned int end)
{
  long unsigned int _min2;
  long unsigned int overlap_len;
  long unsigned int _min2;
  struct vm_area_struct * vma;
  long unsigned int nr_pages;
  long unsigned int _max2.66;
  long unsigned int _3;
  long unsigned int _12;
  long unsigned int _14;
  long unsigned int _15;
  long unsigned int _20;
  long unsigned int _22;
  long unsigned int _26;

  <bb 2>:
  vma_25 = find_vma (mm_7(D), addr_8(D));
  if (vma_25 != 0B)
    goto <bb 3>;
  else
    goto <bb 7>;

  <bb 3>:
  _26 = vma_25->vm_start;
  if (end_9(D) <= _26)
    goto <bb 7>;
  else
    goto <bb 8>;

  <bb 4>:
  _max2.66_18 = vma_24->vm_start;
  if (end_9(D) < _max2.66_18)
    goto <bb 7>;
  else
    goto <bb 5>;

  <bb 5>:

  <bb 6>:
  # nr_pages_31 = PHI <nr_pages_23(5), nr_pages_16(10)>
  # vma_32 = PHI <vma_24(5), vma_17(10)>
  # _max2.66_35 = PHI <_max2.66_18(5), _max2.66_36(10)>
  _min2_19 = vma_32->vm_end;
  _20 = MIN_EXPR <end_9(D), _min2_19>;
  overlap_len_21 = _20 - _max2.66_35;
  _22 = overlap_len_21 >> 12;
  nr_pages_23 = nr_pages_31 + _22;
  vma_24 = vma_32->vm_next;
  if (vma_24 != 0B)
    goto <bb 4>;
  else
    goto <bb 7>;

  <bb 7>:
  # _3 = PHI <0(3), nr_pages_23(6), nr_pages_23(4), nr_pages_16(9), nr_pages_16(8), 0(2)>
  return _3;

  <bb 8>:
  _min2_11 = vma_25->vm_end;
  _12 = MIN_EXPR <end_9(D), _min2_11>;
  _14 = MAX_EXPR <addr_8(D), _26>;
  _15 = _12 - _14;
  nr_pages_16 = _15 >> 12;
  vma_17 = vma_25->vm_next;
  if (vma_17 != 0B)
    goto <bb 9>;
  else
    goto <bb 7>;

  <bb 9>:
  _max2.66_36 = vma_17->vm_start;
  if (end_9(D) < _max2.66_36)
    goto <bb 7>;
  else
    goto <bb 10>;

  <bb 10>:
  goto <bb 6>;

}



;; Function vma_rb_erase (vma_rb_erase, funcdef_no=3000, decl_uid=39842, cgraph_uid=3001)

vma_rb_erase (struct vm_area_struct * vma, struct rb_root * root)
{
  struct vm_area_struct * node;
  long unsigned int augmented;
  struct rb_node * rb;
  long unsigned int p.30;
  struct vm_area_struct * node;
  long unsigned int augmented;
  long unsigned int p.29;
  struct rb_node * tmp;
  long unsigned int pc;
  struct rb_node * child2;
  long unsigned int pc2;
  struct rb_node * _2;
  long unsigned int _9;
  long unsigned int _11;
  long unsigned int _13;
  long long unsigned int _20;
  long long unsigned int _22;
  long long unsigned int _24;
  long unsigned int _27;
  long unsigned int _32;
  struct rb_node * _58;
  long long unsigned int _59;
  long long unsigned int _60;
  long long unsigned int _61;
  struct rb_node * _62;
  long long unsigned int _63;
  long long unsigned int _64;
  long long unsigned int _65;
  long unsigned int _66;
  long unsigned int _67;
  long unsigned int _68;
  long unsigned int _70;
  long unsigned int _71;
  long int _74;
  long unsigned int _76;
  long unsigned int _77;
  long unsigned int _78;
  long unsigned int _80;
  long unsigned int _81;
  long unsigned int _83;
  struct rb_node * _84;
  long unsigned int _90;
  long int _93;
  long unsigned int _95;
  long unsigned int _96;
  long unsigned int _97;
  long unsigned int pretmp_140;
  long unsigned int prephitmp_141;

  <bb 2>:
  _2 = &vma_1(D)->vm_rb;
  rb_6 = MEM[(struct rb_node *)vma_1(D) + 32B].rb_right;
  tmp_7 = MEM[(struct rb_node *)vma_1(D) + 32B].rb_left;
  if (tmp_7 == 0B)
    goto <bb 3>;
  else
    goto <bb 12>;

  <bb 3>:
  pc_8 = MEM[(struct rb_node *)vma_1(D) + 32B].__rb_parent_color;
  _9 = pc_8 & 18446744073709551612;
  rb_10 = (struct rb_node *) _9;
  if (rb_10 != 0B)
    goto <bb 4>;
  else
    goto <bb 7>;

  <bb 4>:
  _58 = rb_10->rb_left;
  if (_2 == _58)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  _59 = (long long unsigned int) rb_6;
  MEM[(volatile __u64 *)rb_10 + 16B] ={v} _59;
  goto <bb 8>;

  <bb 6>:
  _60 = (long long unsigned int) rb_6;
  MEM[(volatile __u64 *)rb_10 + 8B] ={v} _60;
  goto <bb 8>;

  <bb 7>:
  _61 = (long long unsigned int) rb_6;
  MEM[(volatile __u64 *)root_4(D)] ={v} _61;

  <bb 8>:
  if (rb_6 != 0B)
    goto <bb 9>;
  else
    goto <bb 10>;

  <bb 9>:
  rb_6->__rb_parent_color = pc_8;
  goto <bb 37>;

  <bb 10>:
  _11 = pc_8 & 1;
  if (_11 != 0)
    goto <bb 11>;
  else
    goto <bb 37>;

  <bb 11>:
  goto <bb 37>;

  <bb 12>:
  if (rb_6 == 0B)
    goto <bb 13>;
  else
    goto <bb 18>;

  <bb 13>:
  pc_12 = MEM[(struct rb_node *)vma_1(D) + 32B].__rb_parent_color;
  tmp_7->__rb_parent_color = pc_12;
  _13 = pc_12 & 18446744073709551612;
  rb_14 = (struct rb_node *) _13;
  if (rb_14 != 0B)
    goto <bb 14>;
  else
    goto <bb 17>;

  <bb 14>:
  _62 = rb_14->rb_left;
  if (_2 == _62)
    goto <bb 15>;
  else
    goto <bb 16>;

  <bb 15>:
  _63 = (long long unsigned int) tmp_7;
  MEM[(volatile __u64 *)rb_14 + 16B] ={v} _63;
  goto <bb 44>;

  <bb 16>:
  _64 = (long long unsigned int) tmp_7;
  MEM[(volatile __u64 *)rb_14 + 8B] ={v} _64;
  goto <bb 44>;

  <bb 17>:
  _65 = (long long unsigned int) tmp_7;
  MEM[(volatile __u64 *)root_4(D)] ={v} _65;
  goto <bb 43>;

  <bb 18>:
  rb_15 = rb_6->rb_left;
  if (rb_15 == 0B)
    goto <bb 19>;
  else
    goto <bb 20>;

  <bb 19>:
  child2_16 = rb_6->rb_right;
  _66 = vma_1(D)->rb_subtree_gap;
  MEM[(struct vm_area_struct *)rb_6 + -32B].rb_subtree_gap = _66;
  pretmp_140 = (long unsigned int) rb_6;
  goto <bb 28>;

  <bb 20>:

  <bb 21>:
  # rb_17 = PHI <rb_15(20), rb_18(22)>
  # rb_21 = PHI <rb_6(20), rb_17(22)>
  rb_18 = rb_17->rb_left;
  if (rb_18 != 0B)
    goto <bb 22>;
  else
    goto <bb 23>;

  <bb 22>:
  goto <bb 21>;

  <bb 23>:
  # rb_139 = PHI <rb_17(21)>
  # rb_138 = PHI <rb_21(21)>
  child2_19 = rb_139->rb_right;
  _20 = (long long unsigned int) child2_19;
  MEM[(volatile __u64 *)rb_138 + 16B] ={v} _20;
  _22 = (long long unsigned int) rb_6;
  MEM[(volatile __u64 *)rb_139 + 8B] ={v} _22;
  _67 = MEM[(long unsigned int *)rb_6];
  _68 = _67 & 1;
  p.29_69 = (long unsigned int) rb_139;
  _70 = p.29_69 | _68;
  MEM[(long unsigned int *)rb_6] = _70;
  _71 = vma_1(D)->rb_subtree_gap;
  MEM[(struct vm_area_struct *)rb_139 + -32B].rb_subtree_gap = _71;
  if (rb_139 != rb_138)
    goto <bb 24>;
  else
    goto <bb 28>;

  <bb 24>:

  <bb 25>:
  # rb_126 = PHI <rb_79(27), rb_21(24)>
  node_73 = &MEM[(void *)rb_126 + -32B];
  _74 = vma_compute_subtree_gap (node_73);
  augmented_75 = (long unsigned int) _74;
  _76 = MEM[(struct vm_area_struct *)rb_126 + -32B].rb_subtree_gap;
  if (augmented_75 == _76)
    goto <bb 28>;
  else
    goto <bb 26>;

  <bb 26>:
  MEM[(struct vm_area_struct *)rb_126 + -32B].rb_subtree_gap = augmented_75;
  _77 = MEM[(struct vm_area_struct *)rb_126 + -32B].vm_rb.__rb_parent_color;
  _78 = _77 & 18446744073709551612;
  rb_79 = (struct rb_node *) _78;
  if (rb_139 != rb_79)
    goto <bb 27>;
  else
    goto <bb 28>;

  <bb 27>:
  goto <bb 25>;

  <bb 28>:
  # rb_30 = PHI <rb_6(19), rb_21(26), rb_21(25), rb_21(23)>
  # rb_25 = PHI <rb_6(19), rb_17(26), rb_17(25), rb_17(23)>
  # child2_29 = PHI <child2_16(19), child2_19(26), child2_19(25), child2_19(23)>
  # prephitmp_141 = PHI <pretmp_140(19), p.29_69(26), p.29_69(25), p.29_69(23)>
  tmp_23 = MEM[(struct rb_node *)vma_1(D) + 32B].rb_left;
  _24 = (long long unsigned int) tmp_23;
  MEM[(volatile __u64 *)rb_25 + 16B] ={v} _24;
  _80 = MEM[(long unsigned int *)tmp_23];
  _81 = _80 & 1;
  _83 = prephitmp_141 | _81;
  MEM[(long unsigned int *)tmp_23] = _83;
  pc_26 = MEM[(struct rb_node *)vma_1(D) + 32B].__rb_parent_color;
  _27 = pc_26 & 18446744073709551612;
  tmp_28 = (struct rb_node *) _27;
  if (tmp_28 != 0B)
    goto <bb 29>;
  else
    goto <bb 32>;

  <bb 29>:
  _84 = tmp_28->rb_left;
  if (_2 == _84)
    goto <bb 30>;
  else
    goto <bb 31>;

  <bb 30>:
  MEM[(volatile __u64 *)tmp_28 + 16B] ={v} prephitmp_141;
  goto <bb 33>;

  <bb 31>:
  MEM[(volatile __u64 *)tmp_28 + 8B] ={v} prephitmp_141;
  goto <bb 33>;

  <bb 32>:
  MEM[(volatile __u64 *)root_4(D)] ={v} prephitmp_141;

  <bb 33>:
  if (child2_29 != 0B)
    goto <bb 34>;
  else
    goto <bb 35>;

  <bb 34>:
  rb_25->__rb_parent_color = pc_26;
  p.30_89 = (long unsigned int) rb_30;
  _90 = p.30_89 | 1;
  MEM[(long unsigned int *)child2_29] = _90;
  goto <bb 37>;

  <bb 35>:
  pc2_31 = rb_25->__rb_parent_color;
  rb_25->__rb_parent_color = pc_26;
  _32 = pc2_31 & 1;
  if (_32 != 0)
    goto <bb 37>;
  else
    goto <bb 36>;

  <bb 36>:

  <bb 37>:
  # rb_33 = PHI <rb_10(9), rb_10(10), rb_10(11), rb_25(35), rb_25(34), rb_25(36)>
  # rb_34 = PHI <0B(9), rb_6(10), rb_10(11), rb_30(35), 0B(34), 0B(36)>
  if (rb_33 != 0B)
    goto <bb 45>;
  else
    goto <bb 41>;

  <bb 38>:
  # rb_132 = PHI <rb_91(45), rb_98(40)>
  node_92 = &MEM[(void *)rb_132 + -32B];
  _93 = vma_compute_subtree_gap (node_92);
  augmented_94 = (long unsigned int) _93;
  _95 = MEM[(struct vm_area_struct *)rb_132 + -32B].rb_subtree_gap;
  if (augmented_94 == _95)
    goto <bb 41>;
  else
    goto <bb 39>;

  <bb 39>:
  MEM[(struct vm_area_struct *)rb_132 + -32B].rb_subtree_gap = augmented_94;
  _96 = MEM[(struct vm_area_struct *)rb_132 + -32B].vm_rb.__rb_parent_color;
  _97 = _96 & 18446744073709551612;
  rb_98 = (struct rb_node *) _97;
  if (rb_98 != 0B)
    goto <bb 40>;
  else
    goto <bb 41>;

  <bb 40>:
  goto <bb 38>;

  <bb 41>:
  # rb_133 = PHI <rb_72(39), rb_72(38), rb_34(37)>
  if (rb_133 != 0B)
    goto <bb 42>;
  else
    goto <bb 43>;

  <bb 42>:
  __rb_erase_color (rb_133, root_4(D), vma_gap_callbacks_rotate);

  <bb 43>:
  return;

  <bb 44>:

  <bb 45>:
  # rb_91 = PHI <rb_14(44), rb_33(37)>
  # rb_72 = PHI <rb_6(44), rb_34(37)>
  goto <bb 38>;

}



;; Function can_vma_merge_before (can_vma_merge_before, funcdef_no=3014, decl_uid=39982, cgraph_uid=3015)

can_vma_merge_before (struct vm_area_struct * vma, long unsigned int vm_flags, struct anon_vma * anon_vma, struct file * file, long unsigned int vm_pgoff, struct vm_userfaultfd_ctx vm_userfaultfd_ctx)
{
  int _1;
  struct anon_vma * _6;
  long unsigned int _8;
  long unsigned int _10;
  struct file * _11;
  _Bool _13;
  _Bool _14;
  _Bool _15;
  _Bool _16;
  struct list_head * _17;
  struct list_head * _18;
  struct list_head * _19;
  int _23;
  const struct vm_operations_struct * _24;
  void (*<T38f8>) (struct vm_area_struct *) _25;

  <bb 2>:
  _10 = vma_3(D)->vm_flags;
  if (vm_flags_5(D) != _10)
    goto <bb 11>;
  else
    goto <bb 3>;

  <bb 3>:
  _11 = vma_3(D)->vm_file;
  if (file_4(D) != _11)
    goto <bb 11>;
  else
    goto <bb 4>;

  <bb 4>:
  _24 = vma_3(D)->vm_ops;
  if (_24 != 0B)
    goto <bb 5>;
  else
    goto <bb 12>;

  <bb 5>:
  _25 = _24->close;
  if (_25 != 0B)
    goto <bb 11>;
  else
    goto <bb 12>;

  <bb 6>:
  if (vma_3(D) == 0B)
    goto <bb 10>;
  else
    goto <bb 7>;

  <bb 7>:
  _17 = &vma_3(D)->anon_vma_chain;
  _18 = MEM[(const struct list_head *)vma_3(D) + 120B].next;
  if (_17 != _18)
    goto <bb 8>;
  else
    goto <bb 9>;

  <bb 8>:
  _19 = MEM[(const struct list_head *)vma_3(D) + 120B].prev;
  if (_18 == _19)
    goto <bb 10>;
  else
    goto <bb 9>;

  <bb 9>:
  if (_6 == anon_vma_7(D))
    goto <bb 10>;
  else
    goto <bb 11>;

  <bb 10>:
  _8 = vma_3(D)->vm_pgoff;
  _13 = _8 == vm_pgoff_9(D);
  _23 = (int) _13;

  <bb 11>:
  # _1 = PHI <_23(10), 0(3), 0(2), 0(5), 0(9)>
  return _1;

  <bb 12>:
  _6 = vma_3(D)->anon_vma;
  _14 = anon_vma_7(D) == 0B;
  _15 = _6 == 0B;
  _16 = _14 | _15;
  if (_16 != 0)
    goto <bb 6>;
  else
    goto <bb 9>;

}



;; Function __vm_enough_memory (__vm_enough_memory, funcdef_no=2988, decl_uid=25079, cgraph_uid=2988)

__vm_enough_memory (struct mm_struct * mm, long int pages, int cap_sys_admin)
{
  int vm_committed_as_batch.6;
  s64 ret;
  long int x;
  long int x;
  long int x;
  long int x;
  int vm_committed_as_batch.6;
  long int __min2;
  long int __min1;
  long int allowed;
  long int free;
  long unsigned int sysctl_user_reserve_kbytes.5;
  long unsigned int sysctl_admin_reserve_kbytes.3;
  long unsigned int totalreserve_pages.2;
  long unsigned int free.1;
  int sysctl_overcommit_memory.0;
  int _4;
  long unsigned int _13;
  long unsigned int _15;
  long unsigned int _21;
  long unsigned int _23;
  long unsigned int _27;
  long unsigned int _28;
  long unsigned int _31;
  long unsigned int _34;
  long unsigned int _35;
  long unsigned int _39;
  long unsigned int _41;
  long unsigned int _42;
  long int _44;
  long unsigned int _52;
  long unsigned int _55;
  long unsigned int _58;
  long int _59;
  long unsigned int _62;
  long int _64;
  s64 _74;

  <bb 2>:
  vm_committed_as_batch.6_49 = vm_committed_as_batch;
  __percpu_counter_add (&vm_committed_as, pages_8(D), vm_committed_as_batch.6_49);
  sysctl_overcommit_memory.0_10 = sysctl_overcommit_memory;
  if (sysctl_overcommit_memory.0_10 == 1)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  goto <bb 17>;

  <bb 4>:
  if (sysctl_overcommit_memory.0_10 == 0)
    goto <bb 5>;
  else
    goto <bb 11>;

  <bb 5>:
  x_50 ={v} MEM[(const long int *)&vm_stat];
  x_72 = MAX_EXPR <x_50, 0>;
  _52 = (long unsigned int) x_72;
  x_53 ={v} MEM[(const long int *)&vm_stat + 80B];
  x_69 = MAX_EXPR <x_53, 0>;
  _55 = (long unsigned int) x_69;
  _13 = _55 + _52;
  x_56 ={v} MEM[(const long int *)&vm_stat + 192B];
  x_73 = MAX_EXPR <x_56, 0>;
  _58 = (long unsigned int) x_73;
  _15 = _13 - _58;
  free_16 = (long int) _15;
  _59 ={v} MEM[(const long int *)&nr_swap_pages];
  free_18 = free_16 + _59;
  x_60 ={v} MEM[(const long int *)&vm_stat + 104B];
  x_75 = MAX_EXPR <x_60, 0>;
  _62 = (long unsigned int) x_75;
  free.1_20 = (long unsigned int) free_18;
  _21 = free.1_20 + _62;
  totalreserve_pages.2_22 = totalreserve_pages;
  if (_21 <= totalreserve_pages.2_22)
    goto <bb 6>;
  else
    goto <bb 7>;

  <bb 6>:
  _64 = -pages_8(D);
  vm_committed_as_batch.6_65 = vm_committed_as_batch;
  __percpu_counter_add (&vm_committed_as, _64, vm_committed_as_batch.6_65);
  goto <bb 17>;

  <bb 7>:
  _23 = _21 - totalreserve_pages.2_22;
  if (cap_sys_admin_25(D) == 0)
    goto <bb 9>;
  else
    goto <bb 8>;

  <bb 8>:
  free_24 = (long int) _23;
  goto <bb 10>;

  <bb 9>:
  sysctl_admin_reserve_kbytes.3_26 = sysctl_admin_reserve_kbytes;
  _27 = sysctl_admin_reserve_kbytes.3_26 >> 2;
  _28 = _23 - _27;
  free_29 = (long int) _28;

  <bb 10>:
  # free_1 = PHI <free_24(8), free_29(9)>
  if (free_1 > pages_8(D))
    goto <bb 3>;
  else
    goto <bb 6>;

  <bb 11>:
  _31 = vm_commit_limit ();
  if (cap_sys_admin_25(D) == 0)
    goto <bb 13>;
  else
    goto <bb 12>;

  <bb 12>:
  allowed_32 = (long int) _31;
  goto <bb 14>;

  <bb 13>:
  sysctl_admin_reserve_kbytes.3_33 = sysctl_admin_reserve_kbytes;
  _34 = sysctl_admin_reserve_kbytes.3_33 >> 2;
  _35 = _31 - _34;
  allowed_36 = (long int) _35;

  <bb 14>:
  # allowed_2 = PHI <allowed_32(12), allowed_36(13)>
  if (mm_37(D) != 0B)
    goto <bb 15>;
  else
    goto <bb 16>;

  <bb 15>:
  sysctl_user_reserve_kbytes.5_38 = sysctl_user_reserve_kbytes;
  _39 = sysctl_user_reserve_kbytes.5_38 >> 2;
  __min2_40 = (long int) _39;
  _41 = mm_37(D)->total_vm;
  _42 = _41 >> 5;
  __min1_43 = (long int) _42;
  _44 = MIN_EXPR <__min1_43, __min2_40>;
  allowed_45 = allowed_2 - _44;

  <bb 16>:
  # allowed_3 = PHI <allowed_2(14), allowed_45(15)>
  ret_46 = MEM[(struct percpu_counter *)&vm_committed_as + 8B];
  __asm__ __volatile__("" :  :  : "memory");
  _74 = MAX_EXPR <ret_46, 0>;
  if (allowed_3 > _74)
    goto <bb 3>;
  else
    goto <bb 6>;

  <bb 17>:
  # _4 = PHI <0(3), -12(6)>
  return _4;

}



;; Function unlink_file_vma (unlink_file_vma, funcdef_no=2990, decl_uid=25113, cgraph_uid=2990)

unlink_file_vma (struct vm_area_struct * vma)
{
  struct address_space * mapping;
  struct file * file;
  struct rw_semaphore * _9;

  <bb 2>:
  file_4 = vma_3(D)->vm_file;
  if (file_4 != 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  mapping_5 = file_4->f_mapping;
  _9 = &mapping_5->i_mmap_rwsem;
  down_write (_9);
  __remove_shared_vm_struct (vma_3(D), file_4, mapping_5);
  up_write (_9);

  <bb 4>:
  return;

}



;; Function __vma_link_rb (__vma_link_rb, funcdef_no=3005, decl_uid=25111, cgraph_uid=3006)

__vma_link_rb (struct mm_struct * mm, struct vm_area_struct * vma, struct rb_node * * rb_link, struct rb_node * rb_parent)
{
  struct vm_area_struct * node;
  long unsigned int augmented;
  struct rb_node * rb;
  struct vm_area_struct * node;
  long unsigned int augmented;
  struct rb_node * rb;
  long unsigned int parent.16;
  struct vm_area_struct * _4;
  long unsigned int _6;
  struct rb_root * _15;
  long int _28;
  long unsigned int _30;
  long unsigned int _31;
  long unsigned int _32;
  long int _36;
  long unsigned int _39;
  long unsigned int _40;
  long unsigned int pretmp_55;
  long unsigned int prephitmp_56;

  <bb 2>:
  _4 = vma_3(D)->vm_next;
  if (_4 != 0B)
    goto <bb 3>;
  else
    goto <bb 8>;

  <bb 3>:
  rb_17 = &_4->vm_rb;

  <bb 4>:
  # rb_48 = PHI <rb_33(7), rb_17(3)>
  node_27 = &MEM[(void *)rb_48 + -32B];
  _28 = vma_compute_subtree_gap (node_27);
  augmented_29 = (long unsigned int) _28;
  _30 = MEM[(struct vm_area_struct *)rb_48 + -32B].rb_subtree_gap;
  if (augmented_29 == _30)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  goto <bb 9>;

  <bb 6>:
  MEM[(struct vm_area_struct *)rb_48 + -32B].rb_subtree_gap = augmented_29;
  _31 = MEM[(struct vm_area_struct *)rb_48 + -32B].vm_rb.__rb_parent_color;
  _32 = _31 & 18446744073709551612;
  rb_33 = (struct rb_node *) _32;
  if (rb_33 != 0B)
    goto <bb 7>;
  else
    goto <bb 5>;

  <bb 7>:
  goto <bb 4>;

  <bb 8>:
  _6 = vma_3(D)->vm_end;
  mm_7(D)->highest_vm_end = _6;

  <bb 9>:
  rb_9 = &vma_3(D)->vm_rb;
  parent.16_18 = (long unsigned int) rb_parent_10(D);
  MEM[(struct rb_node *)vma_3(D) + 32B].__rb_parent_color = parent.16_18;
  MEM[(struct rb_node *)vma_3(D) + 32B].rb_right = 0B;
  MEM[(struct rb_node *)vma_3(D) + 32B].rb_left = 0B;
  *rb_link_11(D) = rb_9;
  vma_3(D)->rb_subtree_gap = 0;
  if (rb_9 != 0B)
    goto <bb 11>;
  else
    goto <bb 10>;

  <bb 10>:
  _15 = &mm_7(D)->mm_rb;
  __rb_insert_augmented (rb_9, _15, vma_gap_callbacks_rotate);
  return;

  <bb 11>:

  <bb 12>:
  # rb_49 = PHI <rb_41(14), rb_9(11)>
  # prephitmp_56 = PHI <pretmp_55(14), 0(11)>
  node_35 = &MEM[(void *)rb_49 + -32B];
  _36 = vma_compute_subtree_gap (node_35);
  augmented_37 = (long unsigned int) _36;
  if (augmented_37 == prephitmp_56)
    goto <bb 10>;
  else
    goto <bb 13>;

  <bb 13>:
  MEM[(struct vm_area_struct *)rb_49 + -32B].rb_subtree_gap = augmented_37;
  _39 = MEM[(struct vm_area_struct *)rb_49 + -32B].vm_rb.__rb_parent_color;
  _40 = _39 & 18446744073709551612;
  rb_41 = (struct rb_node *) _40;
  if (rb_41 != 0B)
    goto <bb 14>;
  else
    goto <bb 10>;

  <bb 14>:
  pretmp_55 = MEM[(struct vm_area_struct *)rb_41 + -32B].rb_subtree_gap;
  goto <bb 12>;

}



;; Function vma_link (vma_link, funcdef_no=3008, decl_uid=39928, cgraph_uid=3009)

vma_link (struct mm_struct * mm, struct vm_area_struct * vma, struct vm_area_struct * prev, struct rb_node * * rb_link, struct rb_node * rb_parent)
{
  struct address_space * mapping;
  struct file * _6;
  int _16;
  int _17;
  struct rw_semaphore * _19;

  <bb 2>:
  _6 = vma_5(D)->vm_file;
  if (_6 != 0B)
    goto <bb 3>;
  else
    goto <bb 6>;

  <bb 3>:
  mapping_7 = _6->f_mapping;
  _19 = &mapping_7->i_mmap_rwsem;
  down_write (_19);
  __vma_link_list (mm_9(D), vma_5(D), prev_10(D), rb_parent_12(D));
  __vma_link_rb (mm_9(D), vma_5(D), rb_link_11(D), rb_parent_12(D));
  __vma_link_file (vma_5(D));
  if (mapping_7 != 0B)
    goto <bb 4>;
  else
    goto <bb 5>;

  <bb 4>:
  up_write (_19);

  <bb 5>:
  _16 = mm_9(D)->map_count;
  _17 = _16 + 1;
  mm_9(D)->map_count = _17;
  return;

  <bb 6>:
  __vma_link_list (mm_9(D), vma_5(D), prev_10(D), rb_parent_12(D));
  __vma_link_rb (mm_9(D), vma_5(D), rb_link_11(D), rb_parent_12(D));
  __vma_link_file (vma_5(D));
  goto <bb 5>;

}



;; Function vma_adjust (vma_adjust, funcdef_no=3011, decl_uid=25085, cgraph_uid=3012)

vma_adjust (struct vm_area_struct * vma, long unsigned int start, long unsigned int end, long unsigned int pgoff, struct vm_area_struct * insert)
{
  struct vm_area_struct * node;
  long unsigned int augmented;
  struct rb_node * rb;
  struct anon_vma_chain * avc;
  const struct list_head * __mptr;
  const struct list_head * __mptr;
  struct anon_vma_chain * avc;
  const struct list_head * __mptr;
  const struct list_head * __mptr;
  struct vm_area_struct * node;
  long unsigned int augmented;
  struct rb_node * rb;
  struct vm_area_struct * node;
  long unsigned int augmented;
  struct rb_node * rb;
  struct vm_area_struct * prev;
  struct rb_node * * rb_link;
  struct rb_node * rb_parent;
  struct vm_area_struct * next;
  struct anon_vma_chain * avc;
  const struct list_head * __mptr;
  const struct list_head * __mptr;
  struct anon_vma_chain * avc;
  const struct list_head * __mptr;
  const struct list_head * __mptr;
  int error;
  int remove_next;
  long int adjust_next;
  bool end_changed;
  bool start_changed;
  struct file * file;
  struct anon_vma * anon_vma;
  struct rb_root * root;
  struct address_space * mapping;
  struct mm_struct * mm;
  struct kmem_cache * vm_area_cachep.24;
  long unsigned int adjust_next.23;
  int _32;
  _Bool _57;
  _Bool _59;
  _Bool _60;
  long unsigned int _62;
  long unsigned int _63;
  long unsigned int _64;
  long unsigned int _65;
  long unsigned int _67;
  long unsigned int _68;
  long unsigned int _69;
  long unsigned int _70;
  struct anon_vma * _73;
  struct anon_vma * _74;
  _Bool _83;
  _Bool _85;
  struct anon_vma * _87;
  long unsigned int _93;
  long unsigned int _96;
  long unsigned int _100;
  long int _101;
  long unsigned int _102;
  long unsigned int _103;
  long unsigned int _105;
  long unsigned int _107;
  struct anon_vma * _119;
  struct anon_vma * _123;
  int _125;
  int _126;
  struct mempolicy * _128;
  struct rw_semaphore * _135;
  struct rw_semaphore * _136;
  struct rw_semaphore * _139;
  struct rw_semaphore * _140;
  _Bool prephitmp_154;
  struct anon_vma * _155;
  struct rb_root * _156;
  struct list_head * _159;
  _Bool pretmp_163;
  struct anon_vma * _164;
  struct rb_root * _165;
  struct list_head * _168;
  struct rb_root * _170;
  unsigned int _172;
  unsigned int _173;
  long unsigned int _177;
  long unsigned int _178;
  long unsigned int _181;
  long unsigned int _182;
  int _192;
  int _193;
  long int _204;
  long unsigned int _206;
  long unsigned int _207;
  long unsigned int _208;
  struct list_head * _210;
  long int _212;
  long unsigned int _214;
  long unsigned int _215;
  long unsigned int _216;
  struct anon_vma * _221;
  struct rb_root * _222;
  struct list_head * _225;
  struct anon_vma * _230;
  struct rb_root * _231;
  struct list_head * _234;
  long int _238;
  long unsigned int _240;
  long unsigned int _241;
  long unsigned int _242;
  _Bool pretmp_244;
  _Bool pretmp_268;
  struct list_head * _269;
  struct list_head * _271;
  struct list_head * _278;
  struct list_head * _280;
  struct list_head * _283;
  struct list_head * _298;
  long unsigned int pretmp_316;
  struct list_head * _320;
  _Bool pretmp_323;

  <bb 2>:
  mm_54 = vma_53(D)->vm_mm;
  vma_55 = vma_53(D)->vm_next;
  file_56 = vma_53(D)->vm_file;
  _57 = vma_55 != 0B;
  _59 = insert_58(D) == 0B;
  _60 = _59 & _57;
  if (_60 != 0)
    goto <bb 3>;
  else
    goto <bb 18>;

  <bb 3>:
  _62 = vma_55->vm_end;
  if (end_61(D) >= _62)
    goto <bb 4> (again);
  else
    goto <bb 6>;

  # end_1 = PHI <end_61(D)(3), end_3(100)>
  # vma_4 = PHI <vma_55(3), vma_132(100)>
  # mapping_8 = PHI <0B(3), mapping_11(100)>
  # root_12 = PHI <0B(3), root_15(100)>
  # start_changed_17 = PHI <0(3), start_changed_20(100)>
  # end_changed_21 = PHI <0(3), end_changed_24(100)>
  # adjust_next_25 = PHI <0(3), adjust_next_27(100)>
  # end_284 = PHI <_62(3), pretmp_316(100)>
again:
  if (end_1 > end_284)
    goto <bb 5>;
  else
    goto <bb 10>;

  <bb 5>:
  goto <bb 10>;

  <bb 6>:
  _63 = vma_55->vm_start;
  if (end_61(D) > _63)
    goto <bb 7>;
  else
    goto <bb 8>;

  <bb 7>:
  _64 = end_61(D) - _63;
  _65 = _64 >> 12;
  adjust_next_66 = (long int) _65;
  goto <bb 12>;

  <bb 8>:
  _67 = vma_53(D)->vm_end;
  if (end_61(D) < _67)
    goto <bb 9>;
  else
    goto <bb 18>;

  <bb 9>:
  _68 = _67 - end_61(D);
  _69 = _68 >> 12;
  _70 = -_69;
  adjust_next_71 = (long int) _70;

  <bb 10>:
  # end_2 = PHI <end_284(4), end_61(D)(9), end_284(5)>
  # vma_5 = PHI <vma_4(4), vma_55(9), vma_4(5)>
  # vma_7 = PHI <vma_53(D)(4), vma_55(9), vma_53(D)(5)>
  # mapping_9 = PHI <mapping_8(4), 0B(9), mapping_8(5)>
  # root_13 = PHI <root_12(4), 0B(9), root_12(5)>
  # start_changed_18 = PHI <start_changed_17(4), 0(9), start_changed_17(5)>
  # end_changed_22 = PHI <end_changed_21(4), 0(9), end_changed_21(5)>
  # adjust_next_26 = PHI <adjust_next_25(4), adjust_next_71(9), adjust_next_25(5)>
  # remove_next_28 = PHI <1(4), 0(9), 2(5)>
  # vma_30 = PHI <vma_4(4), vma_53(D)(9), vma_4(5)>
  if (vma_30 != 0B)
    goto <bb 12>;
  else
    goto <bb 11>;

  <bb 11>:
  pretmp_163 = adjust_next_26 != 0;
  goto <bb 18>;

  <bb 12>:
  # end_272 = PHI <end_2(10), end_61(D)(7)>
  # vma_273 = PHI <vma_5(10), vma_55(7)>
  # vma_285 = PHI <vma_7(10), vma_53(D)(7)>
  # mapping_286 = PHI <mapping_9(10), 0B(7)>
  # root_275 = PHI <root_13(10), 0B(7)>
  # start_changed_276 = PHI <start_changed_18(10), 0(7)>
  # end_changed_315 = PHI <end_changed_22(10), 0(7)>
  # adjust_next_287 = PHI <adjust_next_26(10), adjust_next_66(7)>
  # remove_next_299 = PHI <remove_next_28(10), 0(7)>
  # vma_300 = PHI <vma_30(10), vma_55(7)>
  _73 = vma_300->anon_vma;
  if (_73 != 0B)
    goto <bb 14>;
  else
    goto <bb 13>;

  <bb 13>:
  pretmp_268 = adjust_next_287 != 0;
  goto <bb 18>;

  <bb 14>:
  _74 = vma_285->anon_vma;
  if (_74 == 0B)
    goto <bb 16>;
  else
    goto <bb 15>;

  <bb 15>:
  pretmp_323 = adjust_next_287 != 0;
  goto <bb 18>;

  <bb 16>:
  vma_285->anon_vma = _73;
  error_77 = anon_vma_clone (vma_285, vma_300);
  if (error_77 != 0)
    goto <bb 107>;
  else
    goto <bb 17>;

  <bb 17>:
  pretmp_244 = adjust_next_287 != 0;

  <bb 18>:
  # end_3 = PHI <end_61(D)(2), end_2(11), end_272(13), end_272(15), end_272(17), end_61(D)(8)>
  # vma_6 = PHI <vma_55(2), vma_5(11), vma_273(13), vma_273(15), vma_273(17), vma_55(8)>
  # mapping_10 = PHI <0B(2), mapping_9(11), mapping_286(13), mapping_286(15), mapping_286(17), 0B(8)>
  # root_14 = PHI <0B(2), root_13(11), root_275(13), root_275(15), root_275(17), 0B(8)>
  # start_changed_19 = PHI <0(2), start_changed_18(11), start_changed_276(13), start_changed_276(15), start_changed_276(17), 0(8)>
  # end_changed_23 = PHI <0(2), end_changed_22(11), end_changed_315(13), end_changed_315(15), end_changed_315(17), 0(8)>
  # adjust_next_27 = PHI <0(2), adjust_next_26(11), adjust_next_287(13), adjust_next_287(15), adjust_next_287(17), 0(8)>
  # remove_next_29 = PHI <0(2), remove_next_28(11), remove_next_299(13), remove_next_299(15), remove_next_299(17), 0(8)>
  # prephitmp_154 = PHI <_60(2), pretmp_163(11), pretmp_268(13), pretmp_323(15), pretmp_244(17), 0(8)>
  if (file_56 != 0B)
    goto <bb 19>;
  else
    goto <bb 21>;

  <bb 19>:
  mapping_78 = file_56->f_mapping;
  root_79 = &mapping_78->i_mmap;
  _135 = &mapping_78->i_mmap_rwsem;
  down_write (_135);
  if (insert_58(D) != 0B)
    goto <bb 20>;
  else
    goto <bb 21>;

  <bb 20>:
  __vma_link_file (insert_58(D));

  <bb 21>:
  # mapping_11 = PHI <mapping_10(18), mapping_78(19), mapping_78(20)>
  # root_15 = PHI <root_14(18), root_79(19), root_79(20)>
  anon_vma_82 = vma_53(D)->anon_vma;
  _83 = anon_vma_82 == 0B;
  _85 = prephitmp_154 & _83;
  if (_85 != 0)
    goto <bb 22>;
  else
    goto <bb 23>;

  <bb 22>:
  anon_vma_86 = vma_6->anon_vma;

  <bb 23>:
  # anon_vma_16 = PHI <anon_vma_82(21), anon_vma_86(22)>
  if (anon_vma_16 != 0B)
    goto <bb 25>;
  else
    goto <bb 24>;

  <bb 24>:
  if (root_15 != 0B)
    goto <bb 35>;
  else
    goto <bb 34>;

  <bb 25>:
  _87 = MEM[(struct anon_vma *)anon_vma_16];
  _136 = &_87->rwsem;
  down_write (_136);
  __mptr_152 = vma_53(D)->anon_vma_chain.next;
  avc_153 = &MEM[(void *)__mptr_152 + -16B];
  _271 = &MEM[(struct anon_vma_chain *)__mptr_152 + -16B].same_vma;
  _280 = &vma_53(D)->anon_vma_chain;
  if (_271 != _280)
    goto <bb 27>;
  else
    goto <bb 26>;

  <bb 26>:
  if (prephitmp_154 != 0)
    goto <bb 30>;
  else
    goto <bb 24>;

  <bb 27>:

  <bb 28>:
  # avc_279 = PHI <avc_158(29), avc_153(27)>
  _155 = avc_279->anon_vma;
  _156 = &_155->rb_root;
  anon_vma_interval_tree_remove (avc_279, _156);
  __mptr_157 = avc_279->same_vma.next;
  avc_158 = &MEM[(void *)__mptr_157 + -16B];
  _159 = &MEM[(struct anon_vma_chain *)__mptr_157 + -16B].same_vma;
  if (_159 != _280)
    goto <bb 29>;
  else
    goto <bb 26>;

  <bb 29>:
  goto <bb 28>;

  <bb 30>:
  __mptr_161 = vma_6->anon_vma_chain.next;
  avc_162 = &MEM[(void *)__mptr_161 + -16B];
  _269 = &MEM[(struct anon_vma_chain *)__mptr_161 + -16B].same_vma;
  _278 = &vma_6->anon_vma_chain;
  if (_269 != _278)
    goto <bb 31>;
  else
    goto <bb 24>;

  <bb 31>:

  <bb 32>:
  # avc_289 = PHI <avc_167(33), avc_162(31)>
  _164 = avc_289->anon_vma;
  _165 = &_164->rb_root;
  anon_vma_interval_tree_remove (avc_289, _165);
  __mptr_166 = avc_289->same_vma.next;
  avc_167 = &MEM[(void *)__mptr_166 + -16B];
  _168 = &MEM[(struct anon_vma_chain *)__mptr_166 + -16B].same_vma;
  if (_168 != _278)
    goto <bb 33>;
  else
    goto <bb 24>;

  <bb 33>:
  goto <bb 32>;

  <bb 34>:
  goto <bb 37>;

  <bb 35>:
  vma_interval_tree_remove (vma_53(D), root_15);
  if (prephitmp_154 != 0)
    goto <bb 36>;
  else
    goto <bb 34>;

  <bb 36>:
  vma_interval_tree_remove (vma_6, root_15);

  <bb 37>:
  _93 = vma_53(D)->vm_start;
  if (_93 != start_94(D))
    goto <bb 38>;
  else
    goto <bb 39>;

  <bb 38>:
  vma_53(D)->vm_start = start_94(D);

  <bb 39>:
  # start_changed_20 = PHI <start_changed_19(37), 1(38)>
  _96 = vma_53(D)->vm_end;
  if (_96 != end_3)
    goto <bb 40>;
  else
    goto <bb 41>;

  <bb 40>:
  vma_53(D)->vm_end = end_3;

  <bb 41>:
  # end_changed_24 = PHI <end_changed_23(39), 1(40)>
  vma_53(D)->vm_pgoff = pgoff_98(D);
  if (prephitmp_154 != 0)
    goto <bb 42>;
  else
    goto <bb 110>;

  <bb 42>:
  _100 = vma_6->vm_start;
  _101 = adjust_next_27 << 12;
  _102 = (long unsigned int) _101;
  _103 = _102 + _100;
  vma_6->vm_start = _103;
  _105 = vma_6->vm_pgoff;
  adjust_next.23_106 = (long unsigned int) adjust_next_27;
  _107 = adjust_next.23_106 + _105;
  vma_6->vm_pgoff = _107;
  if (root_15 != 0B)
    goto <bb 44>;
  else
    goto <bb 43>;

  <bb 43>:
  goto <bb 46>;

  <bb 44>:
  vma_interval_tree_insert (vma_6, root_15);

  <bb 45>:
  vma_interval_tree_insert (vma_53(D), root_15);

  <bb 46>:
  if (remove_next_29 != 0)
    goto <bb 47>;
  else
    goto <bb 54>;

  <bb 47>:
  _170 = &mm_54->mm_rb;
  vma_rb_erase (vma_6, _170);
  next_171 = vma_6->vm_next;
  vma_53(D)->vm_next = next_171;
  if (next_171 != 0B)
    goto <bb 48>;
  else
    goto <bb 49>;

  <bb 48>:
  next_171->vm_prev = vma_53(D);

  <bb 49>:
  _172 = mm_54->vmacache_seqnum;
  _173 = _172 + 1;
  mm_54->vmacache_seqnum = _173;
  if (_173 == 0)
    goto <bb 50>;
  else
    goto <bb 51>;

  <bb 50>:
  vmacache_flush_all (mm_54);

  <bb 51>:
  if (file_56 != 0B)
    goto <bb 53>;
  else
    goto <bb 52>;

  <bb 52>:
  goto <bb 78>;

  <bb 53>:
  __remove_shared_vm_struct (vma_6, file_56, mapping_11);
  goto <bb 78>;

  <bb 54>:
  if (insert_58(D) != 0B)
    goto <bb 55>;
  else
    goto <bb 64>;

  <bb 55>:
  _177 = insert_58(D)->vm_end;
  _178 = insert_58(D)->vm_start;
  rb_link_179 = &mm_54->mm_rb.rb_node;
  goto <bb 61>;

  <bb 56>:
  _181 = MEM[(struct vm_area_struct *)rb_parent_180 + -32B].vm_end;
  if (_178 < _181)
    goto <bb 57>;
  else
    goto <bb 59>;

  <bb 57>:
  _182 = MEM[(struct vm_area_struct *)rb_parent_180 + -32B].vm_start;
  if (_177 > _182)
    goto <bb 108>;
  else
    goto <bb 58>;

  <bb 58>:
  rb_link_183 = &rb_parent_180->rb_left;
  goto <bb 60>;

  <bb 59>:
  rb_link_184 = &rb_parent_180->rb_right;

  <bb 60>:
  # rb_link_31 = PHI <rb_link_183(58), rb_link_184(59)>
  # rb_parent_194 = PHI <rb_parent_186(58), rb_parent_180(59)>

  <bb 61>:
  # rb_link_185 = PHI <rb_link_31(60), rb_link_179(55)>
  # rb_parent_197 = PHI <rb_parent_180(60), 0B(55)>
  # rb_parent_186 = PHI <rb_parent_194(60), 0B(55)>
  rb_parent_180 = *rb_link_185;
  if (rb_parent_180 != 0B)
    goto <bb 56>;
  else
    goto <bb 62>;

  <bb 62>:
  # rb_link_288 = PHI <rb_link_185(61)>
  # rb_parent_282 = PHI <rb_parent_186(61)>
  # rb_parent_274 = PHI <rb_parent_197(61)>
  if (rb_parent_282 != 0B)
    goto <bb 63>;
  else
    goto <bb 109>;

  <bb 63>:
  prev_187 = &MEM[(void *)rb_parent_282 + -32B];
  goto <bb 109>;

  <bb 64>:
  if (start_changed_20 != 0)
    goto <bb 66>;
  else
    goto <bb 65>;

  <bb 65>:
  if (end_changed_24 != 0)
    goto <bb 71>;
  else
    goto <bb 52>;

  <bb 66>:
  rb_137 = &vma_53(D)->vm_rb;
  if (rb_137 != 0B)
    goto <bb 67>;
  else
    goto <bb 65>;

  <bb 67>:

  <bb 68>:
  # rb_319 = PHI <rb_209(70), rb_137(67)>
  node_203 = &MEM[(void *)rb_319 + -32B];
  _204 = vma_compute_subtree_gap (node_203);
  augmented_205 = (long unsigned int) _204;
  _206 = MEM[(struct vm_area_struct *)rb_319 + -32B].rb_subtree_gap;
  if (augmented_205 == _206)
    goto <bb 65>;
  else
    goto <bb 69>;

  <bb 69>:
  MEM[(struct vm_area_struct *)rb_319 + -32B].rb_subtree_gap = augmented_205;
  _207 = MEM[(struct vm_area_struct *)rb_319 + -32B].vm_rb.__rb_parent_color;
  _208 = _207 & 18446744073709551612;
  rb_209 = (struct rb_node *) _208;
  if (rb_209 != 0B)
    goto <bb 70>;
  else
    goto <bb 65>;

  <bb 70>:
  goto <bb 68>;

  <bb 71>:
  if (vma_6 == 0B)
    goto <bb 72>;
  else
    goto <bb 73>;

  <bb 72>:
  mm_54->highest_vm_end = end_3;
  goto <bb 78>;

  <bb 73>:
  if (adjust_next_27 == 0)
    goto <bb 74>;
  else
    goto <bb 52>;

  <bb 74>:
  rb_138 = &vma_6->vm_rb;

  <bb 75>:
  # rb_297 = PHI <rb_217(77), rb_138(74)>
  node_211 = &MEM[(void *)rb_297 + -32B];
  _212 = vma_compute_subtree_gap (node_211);
  augmented_213 = (long unsigned int) _212;
  _214 = MEM[(struct vm_area_struct *)rb_297 + -32B].rb_subtree_gap;
  if (augmented_213 == _214)
    goto <bb 52>;
  else
    goto <bb 76>;

  <bb 76>:
  MEM[(struct vm_area_struct *)rb_297 + -32B].rb_subtree_gap = augmented_213;
  _215 = MEM[(struct vm_area_struct *)rb_297 + -32B].vm_rb.__rb_parent_color;
  _216 = _215 & 18446744073709551612;
  rb_217 = (struct rb_node *) _216;
  if (rb_217 != 0B)
    goto <bb 77>;
  else
    goto <bb 52>;

  <bb 77>:
  goto <bb 75>;

  <bb 78>:
  if (anon_vma_16 != 0B)
    goto <bb 79>;
  else
    goto <bb 89>;

  <bb 79>:
  __mptr_218 = vma_53(D)->anon_vma_chain.next;
  avc_219 = &MEM[(void *)__mptr_218 + -16B];
  _298 = &MEM[(struct anon_vma_chain *)__mptr_218 + -16B].same_vma;
  _320 = &vma_53(D)->anon_vma_chain;
  if (_298 != _320)
    goto <bb 81>;
  else
    goto <bb 80>;

  <bb 80>:
  if (prephitmp_154 != 0)
    goto <bb 85>;
  else
    goto <bb 84>;

  <bb 81>:

  <bb 82>:
  # avc_295 = PHI <avc_224(83), avc_219(81)>
  _221 = avc_295->anon_vma;
  _222 = &_221->rb_root;
  anon_vma_interval_tree_insert (avc_295, _222);
  __mptr_223 = avc_295->same_vma.next;
  avc_224 = &MEM[(void *)__mptr_223 + -16B];
  _225 = &MEM[(struct anon_vma_chain *)__mptr_223 + -16B].same_vma;
  if (_225 != _320)
    goto <bb 83>;
  else
    goto <bb 80>;

  <bb 83>:
  goto <bb 82>;

  <bb 84>:
  _119 = MEM[(struct anon_vma *)anon_vma_16];
  _139 = &_119->rwsem;
  up_write (_139);
  goto <bb 89>;

  <bb 85>:
  __mptr_227 = vma_6->anon_vma_chain.next;
  avc_228 = &MEM[(void *)__mptr_227 + -16B];
  _210 = &MEM[(struct anon_vma_chain *)__mptr_227 + -16B].same_vma;
  _283 = &vma_6->anon_vma_chain;
  if (_210 != _283)
    goto <bb 86>;
  else
    goto <bb 84>;

  <bb 86>:

  <bb 87>:
  # avc_277 = PHI <avc_233(88), avc_228(86)>
  _230 = avc_277->anon_vma;
  _231 = &_230->rb_root;
  anon_vma_interval_tree_insert (avc_277, _231);
  __mptr_232 = avc_277->same_vma.next;
  avc_233 = &MEM[(void *)__mptr_232 + -16B];
  _234 = &MEM[(struct anon_vma_chain *)__mptr_232 + -16B].same_vma;
  if (_234 != _283)
    goto <bb 88>;
  else
    goto <bb 84>;

  <bb 88>:
  goto <bb 87>;

  <bb 89>:
  if (mapping_11 != 0B)
    goto <bb 90>;
  else
    goto <bb 91>;

  <bb 90>:
  _140 = &mapping_11->i_mmap_rwsem;
  up_write (_140);

  <bb 91>:
  if (remove_next_29 != 0)
    goto <bb 93>;
  else
    goto <bb 92>;

  <bb 92>:
  goto <bb 107>;

  <bb 93>:
  if (file_56 != 0B)
    goto <bb 94>;
  else
    goto <bb 95>;

  <bb 94>:
  fput (file_56);

  <bb 95>:
  _123 = vma_6->anon_vma;
  if (_123 != 0B)
    goto <bb 96>;
  else
    goto <bb 97>;

  <bb 96>:
  unlink_anon_vmas (vma_6);

  <bb 97>:
  _125 = mm_54->map_count;
  _126 = _125 + -1;
  mm_54->map_count = _126;
  _128 = vma_6->vm_policy;
  if (_128 != 0B)
    goto <bb 98>;
  else
    goto <bb 99>;

  <bb 98>:
  __mpol_put (_128);

  <bb 99>:
  vm_area_cachep.24_130 = vm_area_cachep;
  kmem_cache_free (vm_area_cachep.24_130, vma_6);
  vma_132 = vma_53(D)->vm_next;
  if (remove_next_29 == 2)
    goto <bb 100>;
  else
    goto <bb 101>;

  <bb 100>:
  pretmp_316 = vma_132->vm_end;
  goto <bb 4> (again);

  <bb 101>:
  if (vma_132 != 0B)
    goto <bb 102>;
  else
    goto <bb 106>;

  <bb 102>:
  rb_141 = &vma_132->vm_rb;

  <bb 103>:
  # rb_314 = PHI <rb_243(105), rb_141(102)>
  node_237 = &MEM[(void *)rb_314 + -32B];
  _238 = vma_compute_subtree_gap (node_237);
  augmented_239 = (long unsigned int) _238;
  _240 = MEM[(struct vm_area_struct *)rb_314 + -32B].rb_subtree_gap;
  if (augmented_239 == _240)
    goto <bb 92>;
  else
    goto <bb 104>;

  <bb 104>:
  MEM[(struct vm_area_struct *)rb_314 + -32B].rb_subtree_gap = augmented_239;
  _241 = MEM[(struct vm_area_struct *)rb_314 + -32B].vm_rb.__rb_parent_color;
  _242 = _241 & 18446744073709551612;
  rb_243 = (struct rb_node *) _242;
  if (rb_243 != 0B)
    goto <bb 105>;
  else
    goto <bb 92>;

  <bb 105>:
  goto <bb 103>;

  <bb 106>:
  mm_54->highest_vm_end = end_3;

  <bb 107>:
  # _32 = PHI <error_77(16), 0(106), 0(92)>
  return _32;

  <bb 108>:
  __asm__ __volatile__("1:	ud2
.pushsection __bug_table,"a"
2:	.long 1b - 2b, %c0 - 2b
	.word %c1, 0
	.org 2b+%c2
.popsection" :  : "i" "mm/mmap.c", "i" 713, "i" 12);
  __builtin_unreachable ();

  <bb 109>:
  # prev_281 = PHI <0B(62), prev_187(63)>
  __vma_link_list (mm_54, insert_58(D), prev_281, rb_parent_274);
  __vma_link_rb (mm_54, insert_58(D), rb_link_288, rb_parent_274);
  _192 = mm_54->map_count;
  _193 = _192 + 1;
  mm_54->map_count = _193;
  goto <bb 78>;

  <bb 110>:
  if (root_15 != 0B)
    goto <bb 45>;
  else
    goto <bb 43>;

}



;; Function __split_vma.isra.41 (__split_vma.isra.41, funcdef_no=3115, decl_uid=43999, cgraph_uid=3000)

__split_vma.isra.41 (struct vm_area_struct * vma, long unsigned int addr, int new_below)
{
  struct kmem_cache * vm_area_cachep.97;
  struct vm_area_struct * new;
  int err;
  long unsigned int _2;
  long unsigned int _3;
  struct file * _4;
  struct inode * _5;
  struct super_block * _6;
  void * _7;
  struct hstate * _8;
  long unsigned int _9;
  long unsigned int _10;
  long unsigned int _12;
  struct list_head * _15;
  long unsigned int _17;
  long unsigned int _18;
  long unsigned int _19;
  long unsigned int _20;
  long unsigned int _21;
  struct file * _24;
  struct atomic_long_t * _25;
  const struct vm_operations_struct * _26;
  void (*<T38f8>) (struct vm_area_struct *) _27;
  long unsigned int _28;
  long unsigned int _29;
  long unsigned int _30;
  long unsigned int _31;
  long unsigned int _32;
  long unsigned int _33;
  long unsigned int _35;
  long unsigned int _36;
  const struct vm_operations_struct * _39;
  void (*<T38f8>) (struct vm_area_struct *) _40;
  struct file * _41;
  struct mempolicy * _42;
  int _44;

  <bb 2>:
  _2 = MEM[(struct vm_area_struct *)vma_1(D) + 80B];
  _3 = _2 & 4194304;
  if (_3 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _4 = MEM[(struct vm_area_struct *)vma_1(D) + 160B];
  _5 = MEM[(const struct file *)_4 + 32B];
  _6 = MEM[(struct inode *)_5 + 40B];
  _7 = MEM[(struct super_block *)_6 + 944B];
  _8 = MEM[(struct hugetlbfs_sb_info *)_7].hstate;
  _9 = MEM[(struct hstate *)_8 + 16B];
  _10 = ~_9;
  _12 = addr_11(D) & _10;
  if (_12 != 0)
    goto <bb 28>;
  else
    goto <bb 4>;

  <bb 4>:
  vm_area_cachep.97_13 = vm_area_cachep;
  new_14 = kmem_cache_alloc (vm_area_cachep.97_13, 208);
  if (new_14 == 0B)
    goto <bb 28>;
  else
    goto <bb 5>;

  <bb 5>:
  *new_14 = *vma_1(D);
  _15 = &new_14->anon_vma_chain;
  MEM[(struct list_head *)new_14 + 120B].next = _15;
  MEM[(struct list_head *)new_14 + 120B].prev = _15;
  if (new_below_16(D) != 0)
    goto <bb 6>;
  else
    goto <bb 7>;

  <bb 6>:
  new_14->vm_end = addr_11(D);
  goto <bb 8>;

  <bb 7>:
  new_14->vm_start = addr_11(D);
  _17 = new_14->vm_pgoff;
  _18 = vma_1(D)->vm_start;
  _19 = addr_11(D) - _18;
  _20 = _19 >> 12;
  _21 = _20 + _17;
  new_14->vm_pgoff = _21;

  <bb 8>:
  err_22 = vma_dup_policy (vma_1(D), new_14);
  if (err_22 != 0)
    goto <bb 27> (out_free_vma);
  else
    goto <bb 9>;

  <bb 9>:
  err_23 = anon_vma_clone (new_14, vma_1(D));
  if (err_23 != 0)
    goto <bb 25> (out_free_mpol);
  else
    goto <bb 10>;

  <bb 10>:
  _24 = new_14->vm_file;
  if (_24 != 0B)
    goto <bb 11>;
  else
    goto <bb 12>;

  <bb 11>:
  _25 = &_24->f_count;
  __asm__ __volatile__(".pushsection .smp_locks,"a"
.balign 4
.long 671f - .
.popsection
671:
	lock; incq %0" : "=m" MEM[(struct atomic64_t *)_25].counter : "m" MEM[(struct atomic64_t *)_25].counter);

  <bb 12>:
  _26 = new_14->vm_ops;
  if (_26 != 0B)
    goto <bb 13>;
  else
    goto <bb 15>;

  <bb 13>:
  _27 = _26->open;
  if (_27 != 0B)
    goto <bb 14>;
  else
    goto <bb 15>;

  <bb 14>:
  _27 (new_14);

  <bb 15>:
  if (new_below_16(D) != 0)
    goto <bb 16>;
  else
    goto <bb 17>;

  <bb 16>:
  _28 = vma_1(D)->vm_pgoff;
  _29 = new_14->vm_start;
  _30 = addr_11(D) - _29;
  _31 = _30 >> 12;
  _32 = _31 + _28;
  _33 = vma_1(D)->vm_end;
  err_34 = vma_adjust (vma_1(D), addr_11(D), _33, _32, new_14);
  goto <bb 18>;

  <bb 17>:
  _35 = vma_1(D)->vm_pgoff;
  _36 = vma_1(D)->vm_start;
  err_37 = vma_adjust (vma_1(D), _36, addr_11(D), _35, new_14);

  <bb 18>:
  # err_38 = PHI <err_34(16), err_37(17)>
  if (err_38 == 0)
    goto <bb 28>;
  else
    goto <bb 19>;

  <bb 19>:
  _39 = new_14->vm_ops;
  if (_39 != 0B)
    goto <bb 20>;
  else
    goto <bb 22>;

  <bb 20>:
  _40 = _39->close;
  if (_40 != 0B)
    goto <bb 21>;
  else
    goto <bb 22>;

  <bb 21>:
  _40 (new_14);

  <bb 22>:
  _41 = new_14->vm_file;
  if (_41 != 0B)
    goto <bb 23>;
  else
    goto <bb 24>;

  <bb 23>:
  fput (_41);

  <bb 24>:
  unlink_anon_vmas (new_14);

  # err_45 = PHI <err_23(9), err_38(24)>
out_free_mpol:
  _42 = new_14->vm_policy;
  if (_42 != 0B)
    goto <bb 26>;
  else
    goto <bb 27> (out_free_vma);

  <bb 26>:
  __mpol_put (_42);

  # err_46 = PHI <err_22(8), err_45(25), err_45(26)>
out_free_vma:
  vm_area_cachep.97_43 = vm_area_cachep;
  kmem_cache_free (vm_area_cachep.97_43, new_14);

  <bb 28>:
  # _44 = PHI <-22(3), -12(4), 0(18), err_46(27)>
  return _44;

}



;; Function vma_merge (vma_merge, funcdef_no=3016, decl_uid=25096, cgraph_uid=3017)

vma_merge (struct mm_struct * mm, struct vm_area_struct * prev, long unsigned int addr, long unsigned int end, long unsigned int vm_flags, struct anon_vma * anon_vma, struct file * file, long unsigned int pgoff, struct mempolicy * policy, struct vm_userfaultfd_ctx vm_userfaultfd_ctx)
{
  int err;
  struct vm_area_struct * next;
  long unsigned int pglen;
  struct vm_area_struct * _5;
  long unsigned int _13;
  long unsigned int _16;
  long unsigned int _22;
  long unsigned int _24;
  struct mempolicy * _25;
  long unsigned int _32;
  struct mempolicy * _33;
  long unsigned int _35;
  int _36;
  struct anon_vma * _37;
  struct anon_vma * _38;
  long unsigned int _40;
  long unsigned int _48;
  struct mempolicy * _49;
  long unsigned int _51;
  int _52;
  long unsigned int _53;
  long unsigned int _54;
  long unsigned int _55;
  long unsigned int _58;
  long unsigned int _59;
  long unsigned int _60;
  bool _63;
  long unsigned int pretmp_64;
  bool _65;
  long unsigned int prephitmp_66;
  _Bool _67;
  _Bool _68;
  _Bool _69;
  long unsigned int pretmp_74;
  long unsigned int pretmp_76;
  bool _77;
  long unsigned int _81;
  struct file * _82;
  long unsigned int prephitmp_84;
  struct anon_vma * _85;
  _Bool _86;
  _Bool _87;
  _Bool _88;
  struct list_head * _89;
  struct list_head * _90;
  struct list_head * _91;
  long unsigned int prephitmp_94;
  long unsigned int pretmp_95;
  long unsigned int _96;
  long unsigned int _97;
  long unsigned int _98;
  long unsigned int _99;
  long unsigned int _100;
  long unsigned int _101;
  const struct vm_operations_struct * _103;
  void (*<T38f8>) (struct vm_area_struct *) _104;
  long unsigned int prephitmp_130;

  <bb 2>:
  _13 = end_11(D) - addr_12(D);
  pglen_14 = _13 >> 12;
  _16 = vm_flags_15(D) & 268715008;
  if (_16 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  goto <bb 43>;

  <bb 4>:
  if (prev_18(D) != 0B)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  next_19 = prev_18(D)->vm_next;
  goto <bb 7>;

  <bb 6>:
  next_21 = mm_20(D)->mmap;

  <bb 7>:
  # next_1 = PHI <next_19(5), next_21(6)>
  if (next_1 != 0B)
    goto <bb 8>;
  else
    goto <bb 10>;

  <bb 8>:
  _22 = next_1->vm_end;
  if (_22 == end_11(D))
    goto <bb 9>;
  else
    goto <bb 10>;

  <bb 9>:
  next_23 = next_1->vm_next;

  <bb 10>:
  # next_2 = PHI <next_1(7), next_1(8), next_23(9)>
  if (prev_18(D) != 0B)
    goto <bb 11>;
  else
    goto <bb 33>;

  <bb 11>:
  _24 = prev_18(D)->vm_end;
  if (_24 == addr_12(D))
    goto <bb 12>;
  else
    goto <bb 33>;

  <bb 12>:
  _25 = prev_18(D)->vm_policy;
  if (_25 == policy_26(D))
    goto <bb 13>;
  else
    goto <bb 14>;

  <bb 13>:
  _81 = prev_18(D)->vm_flags;
  if (vm_flags_15(D) != _81)
    goto <bb 33>;
  else
    goto <bb 15>;

  <bb 14>:
  _63 = __mpol_equal (_25, policy_26(D));
  if (_63 != 0)
    goto <bb 13>;
  else
    goto <bb 33>;

  <bb 15>:
  _82 = prev_18(D)->vm_file;
  if (file_29(D) != _82)
    goto <bb 33>;
  else
    goto <bb 16>;

  <bb 16>:
  _103 = prev_18(D)->vm_ops;
  if (_103 != 0B)
    goto <bb 17>;
  else
    goto <bb 45>;

  <bb 17>:
  _104 = _103->close;
  if (_104 != 0B)
    goto <bb 33>;
  else
    goto <bb 45>;

  <bb 18>:
  _89 = &prev_18(D)->anon_vma_chain;
  _90 = MEM[(const struct list_head *)prev_18(D) + 120B].next;
  if (_89 != _90)
    goto <bb 19>;
  else
    goto <bb 20>;

  <bb 19>:
  _91 = MEM[(const struct list_head *)prev_18(D) + 120B].prev;
  if (_90 == _91)
    goto <bb 21>;
  else
    goto <bb 20>;

  <bb 20>:
  if (anon_vma_28(D) == _85)
    goto <bb 21>;
  else
    goto <bb 33>;

  <bb 21>:
  _96 = MEM[(struct vm_area_struct *)prev_18(D)];
  _97 = MEM[(struct vm_area_struct *)prev_18(D) + 8B];
  _98 = _97 - _96;
  _99 = _98 >> 12;
  _100 = prev_18(D)->vm_pgoff;
  _101 = _99 + _100;
  if (pgoff_30(D) == _101)
    goto <bb 44>;
  else
    goto <bb 33>;

  <bb 22>:
  _32 = next_2->vm_start;
  if (_32 == end_11(D))
    goto <bb 23>;
  else
    goto <bb 31>;

  <bb 23>:
  _33 = next_2->vm_policy;
  if (policy_26(D) == _33)
    goto <bb 27>;
  else
    goto <bb 24>;

  <bb 24>:
  _65 = __mpol_equal (policy_26(D), _33);
  if (_65 != 0)
    goto <bb 26>;
  else
    goto <bb 25>;

  <bb 25>:
  pretmp_74 = prev_18(D)->vm_pgoff;
  pretmp_76 = prev_18(D)->vm_start;
  goto <bb 31>;

  <bb 26>:
  pretmp_95 = prev_18(D)->vm_pgoff;
  pretmp_64 = prev_18(D)->vm_start;

  <bb 27>:
  # prephitmp_84 = PHI <pretmp_95(26), _100(23)>
  # prephitmp_130 = PHI <pretmp_64(26), _96(23)>
  _35 = pglen_14 + pgoff_30(D);
  _36 = can_vma_merge_before (next_2, vm_flags_15(D), anon_vma_28(D), file_29(D), _35, vm_userfaultfd_ctx);
  if (_36 != 0)
    goto <bb 28>;
  else
    goto <bb 31>;

  <bb 28>:
  _37 = next_2->anon_vma;
  _38 = prev_18(D)->anon_vma;
  _67 = _38 == 0B;
  _68 = _37 == 0B;
  _69 = _67 | _68;
  if (_69 != 0)
    goto <bb 30>;
  else
    goto <bb 29>;

  <bb 29>:
  if (_37 == _38)
    goto <bb 30>;
  else
    goto <bb 31>;

  <bb 30>:
  _40 = next_2->vm_end;
  err_43 = vma_adjust (prev_18(D), prephitmp_130, _40, prephitmp_84, 0B);
  goto <bb 32>;

  <bb 31>:
  # prephitmp_94 = PHI <_100(44), _100(22), pretmp_74(25), prephitmp_84(27), prephitmp_84(29)>
  # prephitmp_66 = PHI <_96(44), _96(22), pretmp_76(25), prephitmp_130(27), prephitmp_130(29)>
  err_47 = vma_adjust (prev_18(D), prephitmp_66, end_11(D), prephitmp_94, 0B);

  <bb 32>:
  # err_3 = PHI <err_43(30), err_47(31)>
  if (err_3 != 0)
    goto <bb 3>;
  else
    goto <bb 43>;

  <bb 33>:
  if (next_2 != 0B)
    goto <bb 34>;
  else
    goto <bb 3>;

  <bb 34>:
  _48 = next_2->vm_start;
  if (_48 == end_11(D))
    goto <bb 35>;
  else
    goto <bb 3>;

  <bb 35>:
  _49 = next_2->vm_policy;
  if (policy_26(D) == _49)
    goto <bb 36>;
  else
    goto <bb 37>;

  <bb 36>:
  _51 = pglen_14 + pgoff_30(D);
  _52 = can_vma_merge_before (next_2, vm_flags_15(D), anon_vma_28(D), file_29(D), _51, vm_userfaultfd_ctx);
  if (_52 != 0)
    goto <bb 38>;
  else
    goto <bb 3>;

  <bb 37>:
  _77 = __mpol_equal (policy_26(D), _49);
  if (_77 != 0)
    goto <bb 36>;
  else
    goto <bb 3>;

  <bb 38>:
  if (prev_18(D) != 0B)
    goto <bb 39>;
  else
    goto <bb 41>;

  <bb 39>:
  _53 = prev_18(D)->vm_end;
  if (addr_12(D) < _53)
    goto <bb 40>;
  else
    goto <bb 41>;

  <bb 40>:
  _54 = prev_18(D)->vm_pgoff;
  _55 = prev_18(D)->vm_start;
  err_57 = vma_adjust (prev_18(D), _55, addr_12(D), _54, 0B);
  goto <bb 42>;

  <bb 41>:
  _58 = next_2->vm_pgoff;
  _59 = _58 - pglen_14;
  _60 = next_2->vm_end;
  err_62 = vma_adjust (next_1, addr_12(D), _60, _59, 0B);

  <bb 42>:
  # err_4 = PHI <err_57(40), err_62(41)>
  if (err_4 != 0)
    goto <bb 3>;
  else
    goto <bb 43>;

  <bb 43>:
  # _5 = PHI <0B(3), next_1(42), prev_18(D)(32)>
  return _5;

  <bb 44>:
  if (next_2 != 0B)
    goto <bb 22>;
  else
    goto <bb 31>;

  <bb 45>:
  _85 = prev_18(D)->anon_vma;
  _86 = anon_vma_28(D) == 0B;
  _87 = _85 == 0B;
  _88 = _86 | _87;
  if (_88 != 0)
    goto <bb 18>;
  else
    goto <bb 20>;

}



;; Function find_mergeable_anon_vma (find_mergeable_anon_vma, funcdef_no=3019, decl_uid=25098, cgraph_uid=3020)

find_mergeable_anon_vma (struct vm_area_struct * vma)
{
  struct vm_area_struct * near;
  struct anon_vma * anon_vma;
  struct anon_vma * _1;

  <bb 2>:
  near_6 = vma_5(D)->vm_next;
  if (near_6 == 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  near_9 = vma_5(D)->vm_prev;
  if (near_9 == 0B)
    goto <bb 6>;
  else
    goto <bb 5>;

  <bb 4>:
  anon_vma_8 = reusable_anon_vma (near_6, vma_5(D), near_6);
  if (anon_vma_8 != 0B)
    goto <bb 6>;
  else
    goto <bb 3>;

  <bb 5>:
  anon_vma_11 = reusable_anon_vma (near_9, near_9, vma_5(D));

  <bb 6>:
  # _1 = PHI <anon_vma_8(4), anon_vma_11(5), 0B(3)>
  return _1;

}



;; Function vm_stat_account (vm_stat_account, funcdef_no=3020, decl_uid=25348, cgraph_uid=3021)

vm_stat_account (struct mm_struct * mm, long unsigned int flags, struct file * file, long int pages)
{
  struct task_struct * pfo_ret__;
  long unsigned int pages.39;
  long unsigned int _4;
  long unsigned int _7;
  long unsigned int _10;
  long unsigned int _11;
  long unsigned int _14;
  long unsigned int _15;
  long unsigned int _16;
  long unsigned int _18;
  long unsigned int _19;
  long unsigned int _20;

  <bb 2>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___22 : "p" &current_task);
  _4 = mm_3(D)->total_vm;
  pages.39_6 = (long unsigned int) pages_5(D);
  _7 = pages.39_6 + _4;
  mm_3(D)->total_vm = _7;
  if (file_9(D) != 0B)
    goto <bb 3>;
  else
    goto <bb 6>;

  <bb 3>:
  _10 = mm_3(D)->shared_vm;
  _11 = pages.39_6 + _10;
  mm_3(D)->shared_vm = _11;
  _14 = flags_13(D) & 6;
  if (_14 == 4)
    goto <bb 5>;
  else
    goto <bb 4>;

  <bb 4>:
  goto <bb 8>;

  <bb 5>:
  _15 = mm_3(D)->exec_vm;
  _16 = pages.39_6 + _15;
  mm_3(D)->exec_vm = _16;
  goto <bb 8>;

  <bb 6>:
  _18 = flags_13(D) & 256;
  if (_18 != 0)
    goto <bb 7>;
  else
    goto <bb 4>;

  <bb 7>:
  _19 = mm_3(D)->stack_vm;
  _20 = pages.39_6 + _19;
  mm_3(D)->stack_vm = _20;

  <bb 8>:
  return;

}



;; Function do_mmap (do_mmap, funcdef_no=3023, decl_uid=25173, cgraph_uid=3024)

do_mmap (struct file * file, long unsigned int addr, long unsigned int len, long unsigned int prot, long unsigned int flags, vm_flags_t vm_flags, long unsigned int pgoff, long unsigned int * populate)
{
  struct task_struct * pfo_ret__;
  long unsigned int lock_limit;
  long unsigned int locked;
  void * hint.42;
  long unsigned int mmap_min_addr.43;
  long int charged.57;
  struct vm_userfaultfd_ctx D.44121;
  struct vm_area_struct * prev.58;
  struct kmem_cache * vm_area_cachep.59;
  _Bool __warned.60;
  struct rb_node * rb_parent.61;
  struct rb_node * * rb_link.62;
  struct mm_struct * mm;
  struct vm_area_struct * vma;
  struct vm_area_struct * prev;
  int error;
  struct rb_node * * rb_link;
  struct rb_node * rb_parent;
  long unsigned int charged;
  long unsigned int nr_pages;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  static bool __warned;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct mm_struct * mm;
  int sysctl_overcommit_memory.41;
  int sysctl_max_map_count.40;
  long unsigned int _9;
  long unsigned int _24;
  unsigned int _25;
  unsigned int _26;
  struct path * _28;
  _Bool _30;
  vm_flags_t _31;
  long unsigned int _34;
  long unsigned int _37;
  long unsigned int _41;
  int _42;
  long unsigned int _46;
  long unsigned int _49;
  long unsigned int _50;
  long unsigned int _51;
  long unsigned int _53;
  long unsigned int _55;
  int _57;
  struct inode * _61;
  long unsigned int _63;
  long unsigned int _64;
  unsigned int _65;
  unsigned int _66;
  unsigned int _67;
  unsigned int _68;
  unsigned int _69;
  unsigned int _70;
  int _72;
  unsigned int _74;
  unsigned int _75;
  unsigned int _77;
  unsigned int _78;
  struct path * _79;
  _Bool _81;
  long unsigned int _82;
  const struct file_operations * _84;
  int (*<T264d>) (struct file *, struct vm_area_struct *) _85;
  long unsigned int _86;
  long unsigned int _87;
  long unsigned int _88;
  long unsigned int _91;
  int _95;
  long unsigned int _101;
  long unsigned int _102;
  int _108;
  long unsigned int _109;
  long unsigned int _111;
  int _112;
  int _113;
  long unsigned int _114;
  int _115;
  int _116;
  int _118;
  struct list_head * _125;
  long unsigned int _126;
  long unsigned int _128;
  struct address_space * _129;
  struct file * _131;
  const struct file_operations * _132;
  int (*<T264d>) (struct file *, struct vm_area_struct *) _133;
  long unsigned int _135;
  long unsigned int _145;
  long unsigned int _151;
  struct address_space * _152;
  long unsigned int _153;
  long int _156;
  long unsigned int _159;
  long unsigned int _160;
  long unsigned int _161;
  struct mm_struct * _164;
  struct vm_area_struct * _165;
  long unsigned int _166;
  long unsigned int _167;
  long unsigned int _168;
  long unsigned int _169;
  long unsigned int _170;
  long unsigned int _171;
  struct address_space * _173;
  long unsigned int _178;
  long unsigned int _179;
  long unsigned int _251;
  long unsigned int _254;
  long unsigned int _255;
  long unsigned int _256;
  long unsigned int _258;
  struct signal_struct * _261;
  long long unsigned int _262;
  _Bool _266;
  long unsigned int _271;
  long unsigned int _272;
  long unsigned int _274;
  long unsigned int _352;

  <bb 2>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___104 : "p" &current_task);
  mm_19 = pfo_ret___104->mm;
  *populate_20(D) = 0;
  if (len_22(D) == 0)
    goto <bb 98> (<L79>);
  else
    goto <bb 3>;

  <bb 3>:
  _24 = prot_23(D) & 1;
  if (_24 != 0)
    goto <bb 5>;
  else
    goto <bb 4>;

  <bb 4>:
  goto <bb 9>;

  <bb 5>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___105 : "p" &current_task);
  _25 = pfo_ret___105->personality;
  _26 = _25 & 4194304;
  if (_26 != 0)
    goto <bb 6>;
  else
    goto <bb 4>;

  <bb 6>:
  if (file_27(D) == 0B)
    goto <bb 7>;
  else
    goto <bb 8>;

  <bb 7>:
  prot_32 = prot_23(D) | 4;
  goto <bb 9>;

  <bb 8>:
  _28 = &file_27(D)->f_path;
  _30 = path_noexec (_28);
  if (_30 != 0)
    goto <bb 4>;
  else
    goto <bb 7>;

  <bb 9>:
  # prot_2 = PHI <prot_23(D)(4), prot_32(7)>
  _34 = flags_33(D) & 16;
  if (_34 == 0)
    goto <bb 10>;
  else
    goto <bb 14>;

  <bb 10>:
  addr_248 = addr_35(D) & 18446744073709547520;
  hint.42_249 = (void *) addr_248;
  if (hint.42_249 != 0B)
    goto <bb 11>;
  else
    goto <bb 13>;

  <bb 11>:
  mmap_min_addr.43_250 = mmap_min_addr;
  if (addr_248 < mmap_min_addr.43_250)
    goto <bb 12>;
  else
    goto <bb 13>;

  <bb 12>:
  _251 = mmap_min_addr.43_250 + 4095;
  addr_252 = _251 & 18446744073709547520;

  <bb 13>:
  # addr_253 = PHI <addr_248(10), addr_248(11), addr_252(12)>

  <bb 14>:
  # addr_1 = PHI <addr_35(D)(9), addr_253(13)>
  _37 = len_22(D) + 4095;
  len_38 = _37 & 18446744073709547520;
  if (len_38 == 0)
    goto <bb 98> (<L79>);
  else
    goto <bb 15>;

  <bb 15>:
  charged_39 = len_38 >> 12;
  _41 = charged_39 + pgoff_40(D);
  if (pgoff_40(D) > _41)
    goto <bb 98> (<L79>);
  else
    goto <bb 16>;

  <bb 16>:
  _42 = mm_19->map_count;
  sysctl_max_map_count.40_43 = sysctl_max_map_count;
  if (_42 > sysctl_max_map_count.40_43)
    goto <bb 98> (<L79>);
  else
    goto <bb 17>;

  <bb 17>:
  addr_45 = get_unmapped_area (file_27(D), addr_1, len_38, pgoff_40(D), flags_33(D));
  _46 = addr_45 & 4095;
  if (_46 != 0)
    goto <bb 98> (<L79>);
  else
    goto <bb 18>;

  <bb 18>:
  _50 = mm_19->def_flags;
  _55 = flags_33(D) & 8192;
  if (_55 != 0)
    goto <bb 20>;
  else
    goto <bb 19>;

  <bb 19>:
  _49 = vm_flags_52(D) | _50;
  _255 = flags_33(D) & 10496;
  _51 = _49 | _255;
  _254 = prot_2 & 7;
  _53 = _51 | _254;
  _256 = _53 & 8192;
  if (_256 != 0)
    goto <bb 23>;
  else
    goto <bb 22>;

  <bb 20>:
  _57 = can_do_mlock ();
  if (_57 == 0)
    goto <bb 21>;
  else
    goto <bb 19>;

  <bb 21>:
  goto <bb 98> (<L79>);

  <bb 22>:
  vm_flags_54 = _53 | 112;
  if (file_27(D) != 0B)
    goto <bb 26>;
  else
    goto <bb 42>;

  <bb 23>:
  _258 = MEM[(long unsigned int *)mm_19 + 184B];
  locked_259 = charged_39 + _258;
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___260 : "p" &current_task);
  _261 = MEM[(const struct task_struct *)pfo_ret___260].signal;
  _262 ={v} MEM[(volatile __u64 *)_261].rlim[8].rlim_cur;
  lock_limit_263 = _262 >> 12;
  if (locked_259 > lock_limit_263)
    goto <bb 24>;
  else
    goto <bb 22>;

  <bb 24>:
  _266 = capable (14);
  if (_266 != 0)
    goto <bb 22>;
  else
    goto <bb 25>;

  <bb 25>:
  goto <bb 98> (<L79>);

  <bb 26>:
  _61 = MEM[(const struct file *)file_27(D) + 32B];
  _63 = flags_33(D) & 15;
  switch (_63) <default: <L79>, case 1: <L26>, case 2: <L38>>

<L26>:
  _64 = prot_2 & 2;
  if (_64 != 0)
    goto <bb 28>;
  else
    goto <bb 30>;

  <bb 28>:
  _65 = file_27(D)->f_mode;
  _66 = _65 & 2;
  if (_66 == 0)
    goto <bb 29>;
  else
    goto <bb 30>;

  <bb 29>:
  goto <bb 98> (<L79>);

  <bb 30>:
  _67 = _61->i_flags;
  _68 = _67 & 4;
  if (_68 != 0)
    goto <bb 31>;
  else
    goto <bb 32>;

  <bb 31>:
  _69 = file_27(D)->f_mode;
  _70 = _69 & 2;
  if (_70 != 0)
    goto <bb 29>;
  else
    goto <bb 32>;

  <bb 32>:
  _72 = locks_verify_locked (file_27(D));
  if (_72 != 0)
    goto <bb 25>;
  else
    goto <bb 33>;

  <bb 33>:
  vm_flags_73 = _53 | 248;
  _74 = file_27(D)->f_mode;
  _75 = _74 & 2;
  if (_75 == 0)
    goto <bb 34>;
  else
    goto <bb 35> (<L38>);

  <bb 34>:
  _31 = _53 & 18446744073709551575;
  vm_flags_76 = _31 | 208;

  # vm_flags_3 = PHI <vm_flags_54(26), vm_flags_73(33), vm_flags_76(34)>
<L38>:
  _77 = file_27(D)->f_mode;
  _78 = _77 & 1;
  if (_78 == 0)
    goto <bb 29>;
  else
    goto <bb 36>;

  <bb 36>:
  _79 = &file_27(D)->f_path;
  _81 = path_noexec (_79);
  if (_81 != 0)
    goto <bb 37>;
  else
    goto <bb 39>;

  <bb 37>:
  _82 = vm_flags_3 & 4;
  if (_82 != 0)
    goto <bb 21>;
  else
    goto <bb 38>;

  <bb 38>:
  vm_flags_83 = vm_flags_3 & 18446744073709551551;

  <bb 39>:
  # vm_flags_4 = PHI <vm_flags_3(36), vm_flags_83(38)>
  _84 = file_27(D)->f_op;
  _85 = _84->mmap;
  if (_85 == 0B)
    goto <bb 98> (<L79>);
  else
    goto <bb 40>;

  <bb 40>:
  _86 = vm_flags_4 & 256;
  if (_86 != 0)
    goto <bb 41>;
  else
    goto <bb 46>;

  <bb 41>:
  goto <bb 98> (<L79>);

  <bb 42>:
  _87 = flags_33(D) & 15;
  switch (_87) <default: <L79>, case 1: <L53>, case 2: <L56>>

<L53>:
  _88 = _53 & 256;
  if (_88 != 0)
    goto <bb 41>;
  else
    goto <bb 44>;

  <bb 44>:
  vm_flags_89 = _53 | 248;
  goto <bb 46>;

<L56>:
  pgoff_90 = addr_45 >> 12;

  <bb 46>:
  # vm_flags_5 = PHI <vm_flags_4(40), vm_flags_89(44), vm_flags_54(45)>
  # pgoff_8 = PHI <pgoff_40(D)(40), 0(44), pgoff_90(45)>
  _91 = flags_33(D) & 16384;
  if (_91 != 0)
    goto <bb 47>;
  else
    goto <bb 52>;

  <bb 47>:
  sysctl_overcommit_memory.41_92 = sysctl_overcommit_memory;
  if (sysctl_overcommit_memory.41_92 != 2)
    goto <bb 48>;
  else
    goto <bb 49>;

  <bb 48>:
  vm_flags_93 = vm_flags_5 | 2097152;

  <bb 49>:
  # vm_flags_6 = PHI <vm_flags_5(47), vm_flags_93(48)>
  if (file_27(D) != 0B)
    goto <bb 50>;
  else
    goto <bb 52>;

  <bb 50>:
  _95 = is_file_hugepages (file_27(D));
  if (_95 != 0)
    goto <bb 51>;
  else
    goto <bb 52>;

  <bb 51>:
  vm_flags_96 = vm_flags_6 | 2097152;

  <bb 52>:
  # vm_flags_7 = PHI <vm_flags_5(46), vm_flags_6(49), vm_flags_6(50), vm_flags_96(51)>
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___106 : "p" &current_task);
  mm_107 = pfo_ret___106->mm;
  _108 = may_expand_vm (mm_107, charged_39);
  if (_108 == 0)
    goto <bb 53>;
  else
    goto <bb 56>;

  <bb 53>:
  _109 = addr_45 + len_38;
  nr_pages_110 = count_vma_pages_range (mm_107, addr_45, _109);
  _111 = charged_39 - nr_pages_110;
  _112 = may_expand_vm (mm_107, _111);
  if (_112 == 0)
    goto <bb 100>;
  else
    goto <bb 56>;

  <bb 54>:
  _113 = do_munmap (mm_107, addr_45, len_38);
  if (_113 != 0)
    goto <bb 100>;
  else
    goto <bb 55>;

  <bb 55>:
  goto <bb 57>;

  <bb 56>:

  <bb 57>:
  _114 = addr_45 + len_38;
  _115 = find_vma_links (mm_107, addr_45, _114, &prev, &rb_link, &rb_parent);
  if (_115 != 0)
    goto <bb 54>;
  else
    goto <bb 58>;

  <bb 58>:
  # _352 = PHI <_114(57)>
  _116 = accountable_mapping (file_27(D), vm_flags_7);
  if (_116 != 0)
    goto <bb 59>;
  else
    goto <bb 61>;

  <bb 59>:
  charged.57_117 = (long int) charged_39;
  _118 = security_vm_enough_memory_mm (mm_107, charged.57_117);
  if (_118 != 0)
    goto <bb 100>;
  else
    goto <bb 60>;

  <bb 60>:
  vm_flags_119 = vm_flags_7 | 1048576;

  <bb 61>:
  # vm_flags_121 = PHI <vm_flags_7(58), vm_flags_119(60)>
  # charged_180 = PHI <0(58), charged_39(60)>
  prev.58_120 = prev;
  vma_122 = vma_merge (mm_107, prev.58_120, addr_45, _352, vm_flags_121, 0B, file_27(D), pgoff_8, 0B, D.44121);
  if (vma_122 != 0B)
    goto <bb 79> (out);
  else
    goto <bb 62>;

  <bb 62>:
  vm_area_cachep.59_123 = vm_area_cachep;
  vma_270 = kmem_cache_alloc (vm_area_cachep.59_123, 32976);
  if (vma_270 == 0B)
    goto <bb 91> (unacct_error);
  else
    goto <bb 63>;

  <bb 63>:
  vma_270->vm_mm = mm_107;
  vma_270->vm_start = addr_45;
  vma_270->vm_end = _352;
  vma_270->vm_flags = vm_flags_121;
  _271 = vm_flags_121 & 15;
  _272 = protection_map[_271].pgprot;
  MEM[(struct vm_area_struct *)vma_270 + 72B] = _272;
  vma_270->vm_pgoff = pgoff_8;
  _125 = &vma_270->anon_vma_chain;
  MEM[(struct list_head *)vma_270 + 120B].next = _125;
  MEM[(struct list_head *)vma_270 + 120B].prev = _125;
  if (file_27(D) != 0B)
    goto <bb 64>;
  else
    goto <bb 73>;

  <bb 64>:
  _126 = vm_flags_121 & 2048;
  if (_126 != 0)
    goto <bb 66>;
  else
    goto <bb 65>;

  <bb 65>:
  _128 = vm_flags_121 & 8;
  if (_128 != 0)
    goto <bb 68>;
  else
    goto <bb 67>;

  <bb 66>:
  error_127 = deny_write_access (file_27(D));
  if (error_127 != 0)
    goto <bb 90> (free_vma);
  else
    goto <bb 65>;

  <bb 67>:
  _131 = get_file (file_27(D));
  vma_270->vm_file = _131;
  _132 = file_27(D)->f_op;
  _133 = _132->mmap;
  error_134 = _133 (file_27(D), vma_270);
  if (error_134 != 0)
    goto <bb 86> (unmap_and_free_vma);
  else
    goto <bb 69>;

  <bb 68>:
  _129 = file_27(D)->f_mapping;
  error_130 = mapping_map_writable (_129);
  if (error_130 != 0)
    goto <bb 88> (allow_write_and_free_vma);
  else
    goto <bb 67>;

  <bb 69>:
  _135 = vma_270->vm_start;
  if (addr_45 != _135)
    goto <bb 70>;
  else
    goto <bb 72>;

  <bb 70>:
  __warned.60_139 = __warned;
  if (__warned.60_139 != 0)
    goto <bb 72>;
  else
    goto <bb 71>;

  <bb 71>:
  warn_slowpath_null ("mm/mmap.c", 1674);
  __warned = 1;

  <bb 72>:
  addr_143 = vma_270->vm_start;
  vm_flags_144 = vma_270->vm_flags;
  rb_parent.61_344 = rb_parent;
  rb_link.62_343 = rb_link;
  prev.58_345 = prev;
  vma_link (mm_107, vma_270, prev.58_345, rb_link.62_343, rb_parent.61_344);
  _151 = vm_flags_144 & 8;
  if (_151 != 0)
    goto <bb 75>;
  else
    goto <bb 76>;

  <bb 73>:
  _145 = vm_flags_121 & 8;
  if (_145 != 0)
    goto <bb 74>;
  else
    goto <bb 99>;

  <bb 74>:
  error_146 = shmem_zero_setup (vma_270);
  if (error_146 != 0)
    goto <bb 90> (free_vma);
  else
    goto <bb 99>;

  <bb 75>:
  _152 = file_27(D)->f_mapping;
  mapping_unmap_writable (_152);

  <bb 76>:
  _153 = vm_flags_144 & 2048;
  if (_153 != 0)
    goto <bb 77>;
  else
    goto <bb 78>;

  <bb 77>:
  allow_write_access (file_27(D));

  <bb 78>:
  # vm_flags_98 = PHI <vm_flags_121(99), vm_flags_144(76), vm_flags_144(77)>
  # addr_337 = PHI <addr_45(99), addr_143(76), addr_143(77)>
  file_154 = vma_270->vm_file;

  # file_158 = PHI <file_27(D)(61), file_154(78)>
  # addr_182 = PHI <addr_45(61), addr_337(78)>
  # vm_flags_157 = PHI <vm_flags_121(61), vm_flags_98(78)>
  # vma_155 = PHI <vma_122(61), vma_270(78)>
out:
  perf_event_mmap (vma_155);
  _156 = (long int) charged_39;
  vm_stat_account (mm_107, vm_flags_157, file_158, _156);
  _159 = vm_flags_157 & 8192;
  if (_159 != 0)
    goto <bb 80>;
  else
    goto <bb 85>;

  <bb 80>:
  _160 = vm_flags_157 & 268715008;
  if (_160 == 0)
    goto <bb 81>;
  else
    goto <bb 84>;

  <bb 81>:
  _161 = MEM[(struct vm_area_struct *)vma_155 + 80B];
  _274 = _161 & 4194304;
  if (_274 == 0)
    goto <bb 82>;
  else
    goto <bb 84>;

  <bb 82>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___163 : "p" &current_task);
  _164 = pfo_ret___163->mm;
  _165 = get_gate_vma (_164);
  if (vma_155 != _165)
    goto <bb 83>;
  else
    goto <bb 84>;

  <bb 83>:
  _166 = mm_107->locked_vm;
  _167 = charged_39 + _166;
  mm_107->locked_vm = _167;
  goto <bb 85>;

  <bb 84>:
  _168 = vma_155->vm_flags;
  _169 = _168 & 18446744073709543423;
  vma_155->vm_flags = _169;

  <bb 85>:
  vma_set_page_prot (vma_155);
  goto <bb 94>;

unmap_and_free_vma:
  vma_270->vm_file = 0B;
  fput (file_27(D));
  _170 = vma_270->vm_end;
  _171 = vma_270->vm_start;
  prev.58_172 = prev;
  unmap_region (mm_107, vma_270, prev.58_172, _171, _170);
  if (_128 != 0)
    goto <bb 87>;
  else
    goto <bb 88> (allow_write_and_free_vma);

  <bb 87>:
  _173 = file_27(D)->f_mapping;
  mapping_unmap_writable (_173);

  # error_183 = PHI <error_130(68), error_134(86), error_134(87)>
  # charged_184 = PHI <charged_180(68), 0(86), 0(87)>
allow_write_and_free_vma:
  if (_126 != 0)
    goto <bb 89>;
  else
    goto <bb 90> (free_vma);

  <bb 89>:
  allow_write_access (file_27(D));

  # error_185 = PHI <error_127(66), error_146(74), error_183(88), error_183(89)>
  # charged_186 = PHI <charged_180(66), charged_180(74), charged_184(88), charged_184(89)>
free_vma:
  vm_area_cachep.59_174 = vm_area_cachep;
  kmem_cache_free (vm_area_cachep.59_174, vma_270);

  # error_177 = PHI <-12(62), error_185(90)>
  # charged_175 = PHI <charged_180(62), charged_186(90)>
unacct_error:
  if (charged_175 != 0)
    goto <bb 92>;
  else
    goto <bb 93>;

  <bb 92>:
  charged.57_176 = (long int) charged_175;
  vm_unacct_memory (charged.57_176);

  <bb 93>:
  _178 = (long unsigned int) error_177;

  <bb 94>:
  # _179 = PHI <_178(93), addr_182(85)>
  prev ={v} {CLOBBER};
  rb_link ={v} {CLOBBER};
  rb_parent ={v} {CLOBBER};
  if (_179 <= 18446744073709547520)
    goto <bb 95>;
  else
    goto <bb 98> (<L79>);

  <bb 95>:
  _101 = vm_flags_7 & 8192;
  if (_101 != 0)
    goto <bb 97>;
  else
    goto <bb 96>;

  <bb 96>:
  _102 = flags_33(D) & 98304;
  if (_102 == 32768)
    goto <bb 97>;
  else
    goto <bb 98> (<L79>);

  <bb 97>:
  *populate_20(D) = len_38;

  # _9 = PHI <18446744073709551594(2), 18446744073709551604(16), 18446744073709551541(15), _179(94), addr_45(17), 18446744073709551615(21), 18446744073709551605(25), 18446744073709551603(29), _179(96), 18446744073709551604(100), 18446744073709551594(42), _179(97), 18446744073709551597(39), 18446744073709551594(41), 18446744073709551594(26), 18446744073709551604(14)>
<L79>:
  return _9;

  <bb 99>:
  rb_parent.61_347 = rb_parent;
  rb_link.62_346 = rb_link;
  prev.58_349 = prev;
  vma_link (mm_107, vma_270, prev.58_349, rb_link.62_346, rb_parent.61_347);
  goto <bb 78>;

  <bb 100>:
  prev ={v} {CLOBBER};
  rb_link ={v} {CLOBBER};
  rb_parent ={v} {CLOBBER};
  goto <bb 98> (<L79>);

}



;; Function vm_mmap_pgoff (vm_mmap_pgoff, funcdef_no=3024, decl_uid=39444, cgraph_uid=3025)

vm_mmap_pgoff (struct file * file, long unsigned int addr, long unsigned int len, long unsigned int prot, long unsigned int flag, long unsigned int pgoff)
{
  struct task_struct * pfo_ret__;
  long unsigned int lock_limit;
  long unsigned int locked;
  void * hint.42;
  long unsigned int mmap_min_addr.43;
  vm_flags_t vm_flags;
  long int charged.57;
  struct vm_userfaultfd_ctx D.44209;
  struct vm_area_struct * prev.58;
  struct kmem_cache * vm_area_cachep.59;
  _Bool __warned.60;
  struct rb_node * rb_parent.61;
  struct rb_node * * rb_link.62;
  struct mm_struct * mm;
  struct vm_area_struct * vma;
  struct vm_area_struct * prev;
  int error;
  struct rb_node * * rb_link;
  struct rb_node * rb_parent;
  long unsigned int charged;
  long unsigned int nr_pages;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct mm_struct * mm;
  int sysctl_overcommit_memory.41;
  int sysctl_max_map_count.40;
  struct task_struct * pfo_ret__;
  long unsigned int populate;
  struct mm_struct * mm;
  long unsigned int ret;
  int _9;
  struct rw_semaphore * _11;
  long unsigned int _24;
  unsigned int _26;
  unsigned int _27;
  struct path * _28;
  _Bool _29;
  long unsigned int _31;
  long unsigned int _33;
  long unsigned int _36;
  int _37;
  long unsigned int _41;
  long unsigned int _45;
  long unsigned int _46;
  long unsigned int _47;
  long unsigned int _49;
  int _50;
  struct inode * _53;
  long unsigned int _55;
  long unsigned int _56;
  unsigned int _57;
  unsigned int _58;
  unsigned int _59;
  unsigned int _60;
  unsigned int _61;
  unsigned int _62;
  int _63;
  unsigned int _65;
  unsigned int _66;
  vm_flags_t _67;
  unsigned int _69;
  unsigned int _70;
  struct path * _71;
  _Bool _72;
  long unsigned int _74;
  const struct file_operations * _76;
  int (*<T264d>) (struct file *, struct vm_area_struct *) _77;
  long unsigned int _79;
  long unsigned int _80;
  long unsigned int _81;
  long unsigned int _84;
  int _88;
  int _93;
  long unsigned int _94;
  long unsigned int _96;
  int _97;
  int _98;
  int _100;
  int _102;
  int _104;
  struct list_head * _112;
  long unsigned int _113;
  long unsigned int _115;
  struct address_space * _116;
  struct file * _118;
  const struct file_operations * _119;
  int (*<T264d>) (struct file *, struct vm_area_struct *) _120;
  long unsigned int _122;
  long unsigned int _132;
  long unsigned int _138;
  struct address_space * _139;
  long unsigned int _140;
  long int _143;
  long unsigned int _146;
  long unsigned int _147;
  long unsigned int _148;
  struct mm_struct * _151;
  struct vm_area_struct * _152;
  long unsigned int _153;
  long unsigned int _154;
  long unsigned int _155;
  long unsigned int _156;
  long unsigned int _157;
  long unsigned int _158;
  struct address_space * _160;
  long unsigned int _170;
  long unsigned int _171;
  long unsigned int _257;
  long unsigned int _260;
  long unsigned int _261;
  long unsigned int _262;
  long unsigned int _264;
  struct signal_struct * _267;
  long long unsigned int _268;
  _Bool _272;
  long unsigned int _277;
  long unsigned int _278;
  long unsigned int _280;
  long unsigned int pretmp_293;

  <bb 2>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___21 : "p" &current_task);
  mm_4 = pfo_ret___21->mm;
  _9 = security_mmap_file (file_5(D), prot_6(D), flag_7(D));
  ret_10 = (long unsigned int) _9;
  if (ret_10 == 0)
    goto <bb 3>;
  else
    goto <bb 99>;

  <bb 3>:
  _11 = &mm_4->mmap_sem;
  down_write (_11);
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___22 : "p" &current_task);
  mm_23 = pfo_ret___22->mm;
  if (len_14(D) == 0)
    goto <bb 103> (<L17>);
  else
    goto <bb 4>;

  <bb 4>:
  _24 = prot_6(D) & 1;
  if (_24 != 0)
    goto <bb 6>;
  else
    goto <bb 5>;

  <bb 5>:
  goto <bb 10>;

  <bb 6>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___25 : "p" &current_task);
  _26 = pfo_ret___25->personality;
  _27 = _26 & 4194304;
  if (_27 != 0)
    goto <bb 7>;
  else
    goto <bb 5>;

  <bb 7>:
  if (file_5(D) == 0B)
    goto <bb 8>;
  else
    goto <bb 9>;

  <bb 8>:
  prot_30 = prot_6(D) | 4;
  goto <bb 10>;

  <bb 9>:
  _28 = &file_5(D)->f_path;
  _29 = path_noexec (_28);
  if (_29 != 0)
    goto <bb 5>;
  else
    goto <bb 8>;

  <bb 10>:
  # prot_42 = PHI <prot_6(D)(5), prot_30(8)>
  _31 = flag_7(D) & 16;
  if (_31 == 0)
    goto <bb 11>;
  else
    goto <bb 15>;

  <bb 11>:
  addr_254 = addr_13(D) & 18446744073709547520;
  hint.42_255 = (void *) addr_254;
  if (hint.42_255 != 0B)
    goto <bb 12>;
  else
    goto <bb 14>;

  <bb 12>:
  mmap_min_addr.43_256 = mmap_min_addr;
  if (addr_254 < mmap_min_addr.43_256)
    goto <bb 13>;
  else
    goto <bb 14>;

  <bb 13>:
  _257 = mmap_min_addr.43_256 + 4095;
  addr_258 = _257 & 18446744073709547520;

  <bb 14>:
  # addr_259 = PHI <addr_254(11), addr_254(12), addr_258(13)>

  <bb 15>:
  # addr_39 = PHI <addr_13(D)(10), addr_259(14)>
  _33 = len_14(D) + 4095;
  populate_34 = _33 & 18446744073709547520;
  if (populate_34 == 0)
    goto <bb 103> (<L17>);
  else
    goto <bb 16>;

  <bb 16>:
  charged_35 = populate_34 >> 12;
  _36 = charged_35 + pgoff_15(D);
  if (pgoff_15(D) > _36)
    goto <bb 103> (<L17>);
  else
    goto <bb 17>;

  <bb 17>:
  _37 = mm_23->map_count;
  sysctl_max_map_count.40_38 = sysctl_max_map_count;
  if (_37 > sysctl_max_map_count.40_38)
    goto <bb 103> (<L17>);
  else
    goto <bb 18>;

  <bb 18>:
  ret_40 = get_unmapped_area (file_5(D), addr_39, populate_34, pgoff_15(D), flag_7(D));
  _41 = ret_40 & 4095;
  if (_41 != 0)
    goto <bb 103> (<L17>);
  else
    goto <bb 19>;

  <bb 19>:
  _46 = mm_23->def_flags;
  _49 = flag_7(D) & 8192;
  if (_49 != 0)
    goto <bb 21>;
  else
    goto <bb 20>;

  <bb 20>:
  _261 = flag_7(D) & 10496;
  _45 = _261 | _46;
  _260 = prot_42 & 7;
  _47 = _45 | _260;
  _262 = _47 & 8192;
  if (_262 != 0)
    goto <bb 24>;
  else
    goto <bb 23>;

  <bb 21>:
  _50 = can_do_mlock ();
  if (_50 == 0)
    goto <bb 22>;
  else
    goto <bb 20>;

  <bb 22>:
  goto <bb 103> (<L17>);

  <bb 23>:
  vm_flags_48 = _47 | 112;
  if (file_5(D) != 0B)
    goto <bb 27>;
  else
    goto <bb 44>;

  <bb 24>:
  _264 = MEM[(long unsigned int *)mm_23 + 184B];
  locked_265 = charged_35 + _264;
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___266 : "p" &current_task);
  _267 = MEM[(const struct task_struct *)pfo_ret___266].signal;
  _268 ={v} MEM[(volatile __u64 *)_267].rlim[8].rlim_cur;
  lock_limit_269 = _268 >> 12;
  if (locked_265 > lock_limit_269)
    goto <bb 25>;
  else
    goto <bb 23>;

  <bb 25>:
  _272 = capable (14);
  if (_272 != 0)
    goto <bb 23>;
  else
    goto <bb 26>;

  <bb 26>:
  goto <bb 103> (<L17>);

  <bb 27>:
  _53 = MEM[(const struct file *)file_5(D) + 32B];
  _55 = flag_7(D) & 15;
  switch (_55) <default: <L17>, case 1: <L6>, case 2: <L7>>

<L6>:
  _56 = prot_42 & 2;
  if (_56 != 0)
    goto <bb 29>;
  else
    goto <bb 31>;

  <bb 29>:
  _57 = file_5(D)->f_mode;
  _58 = _57 & 2;
  if (_58 == 0)
    goto <bb 30>;
  else
    goto <bb 31>;

  <bb 30>:
  goto <bb 103> (<L17>);

  <bb 31>:
  _59 = _53->i_flags;
  _60 = _59 & 4;
  if (_60 != 0)
    goto <bb 32>;
  else
    goto <bb 33>;

  <bb 32>:
  _61 = file_5(D)->f_mode;
  _62 = _61 & 2;
  if (_62 != 0)
    goto <bb 30>;
  else
    goto <bb 33>;

  <bb 33>:
  _63 = locks_verify_locked (file_5(D));
  if (_63 != 0)
    goto <bb 26>;
  else
    goto <bb 34>;

  <bb 34>:
  _65 = file_5(D)->f_mode;
  _66 = _65 & 2;
  if (_66 == 0)
    goto <bb 36>;
  else
    goto <bb 35>;

  <bb 35>:
  vm_flags_64 = _47 | 248;
  goto <bb 37> (<L7>);

  <bb 36>:
  _67 = _47 & 18446744073709551575;
  vm_flags_68 = _67 | 208;

  # vm_flags_73 = PHI <vm_flags_48(27), vm_flags_64(35), vm_flags_68(36)>
<L7>:
  _69 = file_5(D)->f_mode;
  _70 = _69 & 1;
  if (_70 == 0)
    goto <bb 30>;
  else
    goto <bb 38>;

  <bb 38>:
  _71 = &file_5(D)->f_path;
  _72 = path_noexec (_71);
  if (_72 != 0)
    goto <bb 39>;
  else
    goto <bb 41>;

  <bb 39>:
  _74 = vm_flags_73 & 4;
  if (_74 != 0)
    goto <bb 22>;
  else
    goto <bb 40>;

  <bb 40>:
  vm_flags_75 = vm_flags_73 & 18446744073709551551;

  <bb 41>:
  # vm_flags_78 = PHI <vm_flags_73(38), vm_flags_75(40)>
  _76 = file_5(D)->f_op;
  _77 = _76->mmap;
  if (_77 == 0B)
    goto <bb 103> (<L17>);
  else
    goto <bb 42>;

  <bb 42>:
  _79 = vm_flags_78 & 256;
  if (_79 != 0)
    goto <bb 43>;
  else
    goto <bb 48>;

  <bb 43>:
  goto <bb 103> (<L17>);

  <bb 44>:
  _80 = flag_7(D) & 15;
  switch (_80) <default: <L17>, case 1: <L8>, case 2: <L9>>

<L8>:
  _81 = _47 & 256;
  if (_81 != 0)
    goto <bb 43>;
  else
    goto <bb 46>;

  <bb 46>:
  vm_flags_82 = _47 | 248;
  goto <bb 48>;

<L9>:
  pgoff_83 = ret_40 >> 12;

  <bb 48>:
  # vm_flags_86 = PHI <vm_flags_78(42), vm_flags_82(46), vm_flags_48(47)>
  # pgoff_108 = PHI <pgoff_15(D)(42), 0(46), pgoff_83(47)>
  _84 = flag_7(D) & 16384;
  if (_84 != 0)
    goto <bb 49>;
  else
    goto <bb 54>;

  <bb 49>:
  sysctl_overcommit_memory.41_85 = sysctl_overcommit_memory;
  if (sysctl_overcommit_memory.41_85 != 2)
    goto <bb 50>;
  else
    goto <bb 51>;

  <bb 50>:
  vm_flags_87 = vm_flags_86 | 2097152;

  <bb 51>:
  # vm_flags_89 = PHI <vm_flags_86(49), vm_flags_87(50)>
  if (file_5(D) != 0B)
    goto <bb 52>;
  else
    goto <bb 54>;

  <bb 52>:
  _88 = is_file_hugepages (file_5(D));
  if (_88 != 0)
    goto <bb 53>;
  else
    goto <bb 54>;

  <bb 53>:
  vm_flags_90 = vm_flags_89 | 2097152;

  <bb 54>:
  # vm_flags_101 = PHI <vm_flags_86(48), vm_flags_89(51), vm_flags_89(52), vm_flags_90(53)>
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___91 : "p" &current_task);
  mm_92 = pfo_ret___91->mm;
  _93 = may_expand_vm (mm_92, charged_35);
  if (_93 == 0)
    goto <bb 55>;
  else
    goto <bb 58>;

  <bb 55>:
  _94 = ret_40 + populate_34;
  nr_pages_95 = count_vma_pages_range (mm_92, ret_40, _94);
  _96 = charged_35 - nr_pages_95;
  _97 = may_expand_vm (mm_92, _96);
  if (_97 == 0)
    goto <bb 101>;
  else
    goto <bb 58>;

  <bb 56>:
  _98 = do_munmap (mm_92, ret_40, populate_34);
  if (_98 != 0)
    goto <bb 101>;
  else
    goto <bb 57>;

  <bb 57>:
  goto <bb 59>;

  <bb 58>:
  pretmp_293 = ret_40 + populate_34;

  <bb 59>:
  _100 = find_vma_links (mm_92, ret_40, pretmp_293, &prev, &rb_link, &rb_parent);
  if (_100 != 0)
    goto <bb 56>;
  else
    goto <bb 60>;

  <bb 60>:
  _102 = accountable_mapping (file_5(D), vm_flags_101);
  if (_102 != 0)
    goto <bb 61>;
  else
    goto <bb 63>;

  <bb 61>:
  charged.57_103 = (long int) charged_35;
  _104 = security_vm_enough_memory_mm (mm_92, charged.57_103);
  if (_104 != 0)
    goto <bb 101>;
  else
    goto <bb 62>;

  <bb 62>:
  vm_flags_105 = vm_flags_101 | 1048576;

  <bb 63>:
  # vm_flags_107 = PHI <vm_flags_101(60), vm_flags_105(62)>
  # charged_173 = PHI <0(60), charged_35(62)>
  prev.58_106 = prev;
  vma_109 = vma_merge (mm_92, prev.58_106, ret_40, pretmp_293, vm_flags_107, 0B, file_5(D), pgoff_108, 0B, D.44209);
  if (vma_109 != 0B)
    goto <bb 81> (out);
  else
    goto <bb 64>;

  <bb 64>:
  vm_area_cachep.59_110 = vm_area_cachep;
  vma_276 = kmem_cache_alloc (vm_area_cachep.59_110, 32976);
  if (vma_276 == 0B)
    goto <bb 93> (unacct_error);
  else
    goto <bb 65>;

  <bb 65>:
  vma_276->vm_mm = mm_92;
  vma_276->vm_start = ret_40;
  vma_276->vm_end = pretmp_293;
  vma_276->vm_flags = vm_flags_107;
  _277 = vm_flags_107 & 15;
  _278 = protection_map[_277].pgprot;
  MEM[(struct vm_area_struct *)vma_276 + 72B] = _278;
  vma_276->vm_pgoff = pgoff_108;
  _112 = &vma_276->anon_vma_chain;
  MEM[(struct list_head *)vma_276 + 120B].next = _112;
  MEM[(struct list_head *)vma_276 + 120B].prev = _112;
  if (file_5(D) != 0B)
    goto <bb 66>;
  else
    goto <bb 75>;

  <bb 66>:
  _113 = vm_flags_107 & 2048;
  if (_113 != 0)
    goto <bb 68>;
  else
    goto <bb 67>;

  <bb 67>:
  _115 = vm_flags_107 & 8;
  if (_115 != 0)
    goto <bb 70>;
  else
    goto <bb 69>;

  <bb 68>:
  error_114 = deny_write_access (file_5(D));
  if (error_114 != 0)
    goto <bb 92> (free_vma);
  else
    goto <bb 67>;

  <bb 69>:
  _118 = get_file (file_5(D));
  vma_276->vm_file = _118;
  _119 = file_5(D)->f_op;
  _120 = _119->mmap;
  error_121 = _120 (file_5(D), vma_276);
  if (error_121 != 0)
    goto <bb 88> (unmap_and_free_vma);
  else
    goto <bb 71>;

  <bb 70>:
  _116 = file_5(D)->f_mapping;
  error_117 = mapping_map_writable (_116);
  if (error_117 != 0)
    goto <bb 90> (allow_write_and_free_vma);
  else
    goto <bb 69>;

  <bb 71>:
  _122 = vma_276->vm_start;
  if (ret_40 != _122)
    goto <bb 72>;
  else
    goto <bb 74>;

  <bb 72>:
  __warned.60_126 = __warned;
  if (__warned.60_126 != 0)
    goto <bb 74>;
  else
    goto <bb 73>;

  <bb 73>:
  warn_slowpath_null ("mm/mmap.c", 1674);
  __warned = 1;

  <bb 74>:
  ret_130 = vma_276->vm_start;
  vm_flags_131 = vma_276->vm_flags;
  rb_parent.61_354 = rb_parent;
  rb_link.62_356 = rb_link;
  prev.58_355 = prev;
  vma_link (mm_92, vma_276, prev.58_355, rb_link.62_356, rb_parent.61_354);
  _138 = vm_flags_131 & 8;
  if (_138 != 0)
    goto <bb 77>;
  else
    goto <bb 78>;

  <bb 75>:
  _132 = vm_flags_107 & 8;
  if (_132 != 0)
    goto <bb 76>;
  else
    goto <bb 100>;

  <bb 76>:
  error_133 = shmem_zero_setup (vma_276);
  if (error_133 != 0)
    goto <bb 92> (free_vma);
  else
    goto <bb 100>;

  <bb 77>:
  _139 = file_5(D)->f_mapping;
  mapping_unmap_writable (_139);

  <bb 78>:
  _140 = vm_flags_131 & 2048;
  if (_140 != 0)
    goto <bb 79>;
  else
    goto <bb 80>;

  <bb 79>:
  allow_write_access (file_5(D));

  <bb 80>:
  # vm_flags_344 = PHI <vm_flags_107(100), vm_flags_131(78), vm_flags_131(79)>
  # ret_330 = PHI <ret_40(100), ret_130(78), ret_130(79)>
  file_141 = vma_276->vm_file;

  # file_145 = PHI <file_5(D)(63), file_141(80)>
  # ret_175 = PHI <ret_40(63), ret_330(80)>
  # vm_flags_144 = PHI <vm_flags_107(63), vm_flags_344(80)>
  # vma_142 = PHI <vma_109(63), vma_276(80)>
out:
  perf_event_mmap (vma_142);
  _143 = (long int) charged_35;
  vm_stat_account (mm_92, vm_flags_144, file_145, _143);
  _146 = vm_flags_144 & 8192;
  if (_146 != 0)
    goto <bb 82>;
  else
    goto <bb 87>;

  <bb 82>:
  _147 = vm_flags_144 & 268715008;
  if (_147 == 0)
    goto <bb 83>;
  else
    goto <bb 86>;

  <bb 83>:
  _148 = MEM[(struct vm_area_struct *)vma_142 + 80B];
  _280 = _148 & 4194304;
  if (_280 == 0)
    goto <bb 84>;
  else
    goto <bb 86>;

  <bb 84>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___150 : "p" &current_task);
  _151 = pfo_ret___150->mm;
  _152 = get_gate_vma (_151);
  if (vma_142 != _152)
    goto <bb 85>;
  else
    goto <bb 86>;

  <bb 85>:
  _153 = mm_92->locked_vm;
  _154 = charged_35 + _153;
  mm_92->locked_vm = _154;
  goto <bb 87>;

  <bb 86>:
  _155 = vma_142->vm_flags;
  _156 = _155 & 18446744073709543423;
  vma_142->vm_flags = _156;

  <bb 87>:
  vma_set_page_prot (vma_142);
  goto <bb 96>;

unmap_and_free_vma:
  vma_276->vm_file = 0B;
  fput (file_5(D));
  _157 = vma_276->vm_end;
  _158 = vma_276->vm_start;
  prev.58_159 = prev;
  unmap_region (mm_92, vma_276, prev.58_159, _158, _157);
  if (_115 != 0)
    goto <bb 89>;
  else
    goto <bb 90> (allow_write_and_free_vma);

  <bb 89>:
  _160 = file_5(D)->f_mapping;
  mapping_unmap_writable (_160);

  # error_176 = PHI <error_117(70), error_121(88), error_121(89)>
  # charged_177 = PHI <charged_173(70), 0(88), 0(89)>
allow_write_and_free_vma:
  if (_113 != 0)
    goto <bb 91>;
  else
    goto <bb 92> (free_vma);

  <bb 91>:
  allow_write_access (file_5(D));

  # error_178 = PHI <error_114(68), error_133(76), error_176(90), error_176(91)>
  # charged_179 = PHI <charged_173(68), charged_173(76), charged_177(90), charged_177(91)>
free_vma:
  vm_area_cachep.59_161 = vm_area_cachep;
  kmem_cache_free (vm_area_cachep.59_161, vma_276);

  # error_164 = PHI <-12(64), error_178(92)>
  # charged_162 = PHI <charged_173(64), charged_179(92)>
unacct_error:
  if (charged_162 != 0)
    goto <bb 94>;
  else
    goto <bb 95>;

  <bb 94>:
  charged.57_163 = (long int) charged_162;
  vm_unacct_memory (charged.57_163);

  <bb 95>:
  ret_165 = (long unsigned int) error_164;

  <bb 96>:
  # ret_166 = PHI <ret_165(95), ret_175(87)>
  prev ={v} {CLOBBER};
  rb_link ={v} {CLOBBER};
  rb_parent ={v} {CLOBBER};
  if (ret_166 <= 18446744073709547520)
    goto <bb 97>;
  else
    goto <bb 103> (<L17>);

  <bb 97>:
  _170 = vm_flags_101 & 8192;
  if (_170 != 0)
    goto <bb 102>;
  else
    goto <bb 98>;

  <bb 98>:
  _171 = flag_7(D) & 98304;
  if (_171 == 32768)
    goto <bb 102>;
  else
    goto <bb 103> (<L17>);

  <bb 99>:
  # ret_1 = PHI <ret_10(2), ret_311(103), ret_166(102)>
  return ret_1;

  <bb 100>:
  rb_parent.61_348 = rb_parent;
  rb_link.62_359 = rb_link;
  prev.58_358 = prev;
  vma_link (mm_92, vma_276, prev.58_358, rb_link.62_359, rb_parent.61_348);
  goto <bb 80>;

  <bb 101>:
  prev ={v} {CLOBBER};
  rb_link ={v} {CLOBBER};
  rb_parent ={v} {CLOBBER};
  goto <bb 103> (<L17>);

  <bb 102>:
  up_write (_11);
  __mm_populate (ret_166, populate_34, 1);
  goto <bb 99>;

  # ret_311 = PHI <ret_166(98), 18446744073709551604(101), ret_40(18), 18446744073709551594(44), 18446744073709551594(43), 18446744073709551597(41), 18446744073709551594(3), ret_166(96), 18446744073709551604(17), 18446744073709551541(16), 18446744073709551603(30), 18446744073709551594(27), 18446744073709551605(26), 18446744073709551615(22), 18446744073709551604(15)>
<L17>:
  up_write (_11);
  goto <bb 99>;

}



;; Function vma_wants_writenotify (vma_wants_writenotify, funcdef_no=3027, decl_uid=24832, cgraph_uid=3029)

vma_wants_writenotify (struct vm_area_struct * vma)
{
  struct super_block * sb;
  struct super_block * blockdev_superblock.56;
  pgprotval_t preservebits;
  const struct vm_operations_struct * vm_ops;
  vm_flags_t vm_flags;
  int _1;
  unsigned int _3;
  long unsigned int _9;
  int (*<T38fe>) (struct vm_area_struct *, struct vm_fault *) _10;
  int (*<T38fe>) (struct vm_area_struct *, struct vm_fault *) _11;
  long unsigned int _12;
  long unsigned int _14;
  struct file * _15;
  struct address_space * _16;
  struct inode * _17;
  long unsigned int _19;
  long unsigned int _20;
  long unsigned int _22;
  unsigned int _23;
  unsigned int _24;
  unsigned int _25;
  struct block_device * _29;
  struct backing_dev_info * _30;
  struct backing_dev_info * _31;
  struct backing_dev_info * _32;
  int _38;
  _Bool _39;

  <bb 2>:
  vm_flags_7 = vma_6(D)->vm_flags;
  vm_ops_8 = vma_6(D)->vm_ops;
  _9 = vm_flags_7 & 10;
  if (_9 != 10)
    goto <bb 15>;
  else
    goto <bb 3>;

  <bb 3>:
  if (vm_ops_8 != 0B)
    goto <bb 4>;
  else
    goto <bb 6>;

  <bb 4>:
  _10 = vm_ops_8->page_mkwrite;
  if (_10 != 0B)
    goto <bb 15>;
  else
    goto <bb 5>;

  <bb 5>:
  _11 = vm_ops_8->pfn_mkwrite;
  if (_11 != 0B)
    goto <bb 15>;
  else
    goto <bb 6>;

  <bb 6>:
  _12 = vma_6(D)->vm_page_prot.pgprot;
  _19 = vm_flags_7 & 15;
  _20 = protection_map[_19].pgprot;
  preservebits_21 = _12 & 70368744174200;
  _22 = preservebits_21 | _20;
  if (_12 != _22)
    goto <bb 15>;
  else
    goto <bb 7>;

  <bb 7>:
  _14 = vm_flags_7 & 1024;
  if (_14 != 0)
    goto <bb 15>;
  else
    goto <bb 8>;

  <bb 8>:
  _15 = vma_6(D)->vm_file;
  if (_15 != 0B)
    goto <bb 9>;
  else
    goto <bb 15>;

  <bb 9>:
  _16 = _15->f_mapping;
  if (_16 != 0B)
    goto <bb 10>;
  else
    goto <bb 15>;

  <bb 10>:
  _17 = MEM[(struct address_space *)_16];
  if (_17 == 0B)
    goto <bb 14>;
  else
    goto <bb 11>;

  <bb 11>:
  sb_27 = _17->i_sb;
  blockdev_superblock.56_28 = blockdev_superblock;
  if (sb_27 == blockdev_superblock.56_28)
    goto <bb 12>;
  else
    goto <bb 13>;

  <bb 12>:
  _29 = I_BDEV (_17);
  _30 = blk_get_backing_dev_info (_29);
  goto <bb 14>;

  <bb 13>:
  _31 = sb_27->s_bdi;

  <bb 14>:
  # _32 = PHI <&noop_backing_dev_info(10), _30(12), _31(13)>
  _24 = MEM[(struct backing_dev_info *)_32 + 24B];
  _25 = _24 & 1;
  _3 = _25 ^ 1;
  _39 = (_Bool) _3;
  _23 = _3 & 1;
  _38 = (int) _23;

  <bb 15>:
  # _1 = PHI <0(6), _38(14), 1(5), 0(2), 0(9), 0(8), 0(7), 1(4)>
  return _1;

}



;; Function vma_set_page_prot (vma_set_page_prot, funcdef_no=2986, decl_uid=25296, cgraph_uid=2986)

vma_set_page_prot (struct vm_area_struct * vma)
{
  pgprotval_t oldprot;
  pgprotval_t oldprot;
  pgprotval_t preservebits;
  pgprotval_t preservebits;
  long unsigned int vm_flags;
  int _7;
  long unsigned int _9;
  long unsigned int _10;
  long unsigned int _12;
  long unsigned int _13;
  long unsigned int _14;
  long unsigned int _16;

  <bb 2>:
  vm_flags_4 = vma_3(D)->vm_flags;
  oldprot_19 = MEM[(struct vm_area_struct *)vma_3(D) + 72B];
  _9 = vm_flags_4 & 15;
  _10 = protection_map[_9].pgprot;
  preservebits_11 = oldprot_19 & 70368744174200;
  _12 = preservebits_11 | _10;
  MEM[(struct vm_area_struct *)vma_3(D) + 72B] = _12;
  _7 = vma_wants_writenotify (vma_3(D));
  if (_7 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  oldprot_17 = MEM[(struct vm_area_struct *)vma_3(D) + 72B];
  _13 = vm_flags_4 & 7;
  _14 = protection_map[_13].pgprot;
  preservebits_15 = oldprot_17 & 70368744174200;
  _16 = preservebits_15 | _14;
  MEM[(struct vm_area_struct *)vma_3(D) + 72B] = _16;

  <bb 4>:
  return;

}



;; Function mmap_region (mmap_region, funcdef_no=3029, decl_uid=25164, cgraph_uid=3031)

mmap_region (struct file * file, long unsigned int addr, long unsigned int len, vm_flags_t vm_flags, long unsigned int pgoff)
{
  int vm_committed_as_batch.6;
  int v;
  volatile u32 * __ptr;
  int v;
  volatile u32 * __ptr;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  static bool __warned;
  long unsigned int nr_pages;
  long unsigned int charged;
  struct rb_node * rb_parent;
  struct rb_node * * rb_link;
  int error;
  struct vm_area_struct * prev;
  struct vm_area_struct * vma;
  struct mm_struct * mm;
  struct rb_node * * rb_link.62;
  struct rb_node * rb_parent.61;
  _Bool __warned.60;
  struct kmem_cache * vm_area_cachep.59;
  struct vm_area_struct * prev.58;
  struct vm_userfaultfd_ctx D.40168;
  long int charged.57;
  long unsigned int _15;
  int _39;
  long unsigned int _41;
  long unsigned int _43;
  long unsigned int _46;
  int _48;
  int _51;
  int _53;
  int _59;
  struct list_head * _74;
  long unsigned int _76;
  long unsigned int _79;
  struct address_space * _80;
  const struct file_operations * _86;
  int (*<T264d>) (struct file *, struct vm_area_struct *) _87;
  long unsigned int _90;
  long unsigned int pretmp_91;
  long unsigned int _104;
  long unsigned int _105;
  struct address_space * _108;
  long unsigned int _111;
  long unsigned int _118;
  struct address_space * _119;
  long unsigned int _121;
  long int _130;
  long unsigned int _132;
  long unsigned int _133;
  long unsigned int _134;
  struct mm_struct * _136;
  struct vm_area_struct * _138;
  long unsigned int _139;
  long unsigned int _140;
  long unsigned int _143;
  const struct file_operations * _151;
  int _152;
  long unsigned int _154;
  long unsigned int pretmp_156;
  long unsigned int _160;
  long unsigned int _161;
  struct inode * _162;
  long unsigned int prephitmp_163;
  int _164;
  long unsigned int pretmp_172;
  int _173;
  struct atomic_long_t * _181;
  struct atomic_t * _182;
  struct inode * _183;
  struct atomic_t * _184;
  long unsigned int _186;
  long int _189;
  long unsigned int pretmp_202;
  long unsigned int pretmp_210;
  long unsigned int prephitmp_234;

  <bb 2>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___149 : "p" &current_task);
  mm_35 = pfo_ret___149->mm;
  charged_37 = len_36(D) >> 12;
  _39 = may_expand_vm (mm_35, charged_37);
  if (_39 == 0)
    goto <bb 3>;
  else
    goto <bb 8>;

  <bb 3>:
  _41 = vm_flags_40(D) & 16;
  if (_41 == 0)
    goto <bb 4>;
  else
    goto <bb 5>;

  <bb 4>:
  goto <bb 57>;

  <bb 5>:
  _43 = len_36(D) + addr_42(D);
  nr_pages_45 = count_vma_pages_range (mm_35, addr_42(D), _43);
  _46 = charged_37 - nr_pages_45;
  _48 = may_expand_vm (mm_35, _46);
  if (_48 == 0)
    goto <bb 4>;
  else
    goto <bb 8>;

  <bb 6>:
  _53 = do_munmap (mm_35, addr_42(D), len_36(D));
  if (_53 != 0)
    goto <bb 4>;
  else
    goto <bb 7>;

  <bb 7>:
  goto <bb 9>;

  <bb 8>:
  pretmp_156 = len_36(D) + addr_42(D);

  <bb 9>:
  _51 = find_vma_links (mm_35, addr_42(D), pretmp_156, &prev, &rb_link, &rb_parent);
  if (_51 != 0)
    goto <bb 6>;
  else
    goto <bb 10>;

  <bb 10>:
  if (file_54(D) != 0B)
    goto <bb 12>;
  else
    goto <bb 11>;

  <bb 11>:
  _154 = vm_flags_40(D) & 2097162;
  if (_154 == 2)
    goto <bb 14>;
  else
    goto <bb 16>;

  <bb 12>:
  _151 = file_54(D)->f_op;
  if (_151 == &hugetlbfs_file_operations)
    goto <bb 58>;
  else
    goto <bb 13>;

  <bb 13>:
  _152 = is_file_shm_hugepages (file_54(D));
  if (_152 != 0)
    goto <bb 58>;
  else
    goto <bb 11>;

  <bb 14>:
  charged.57_57 = (long int) charged_37;
  _59 = security_vm_enough_memory_mm (mm_35, charged.57_57);
  if (_59 != 0)
    goto <bb 4>;
  else
    goto <bb 15>;

  <bb 15>:
  vm_flags_60 = vm_flags_40(D) | 1048576;

  <bb 16>:
  # vm_flags_4 = PHI <vm_flags_40(D)(11), vm_flags_60(15), vm_flags_40(D)(58)>
  # charged_11 = PHI <0(11), charged_37(15), 0(58)>
  prev.58_61 = prev;
  vma_64 = vma_merge (mm_35, prev.58_61, addr_42(D), pretmp_156, vm_flags_4, 0B, file_54(D), pgoff_62(D), 0B, D.40168);
  if (vma_64 != 0B)
    goto <bb 40> (out);
  else
    goto <bb 17>;

  <bb 17>:
  vm_area_cachep.59_65 = vm_area_cachep;
  vma_159 = kmem_cache_alloc (vm_area_cachep.59_65, 32976);
  if (vma_159 == 0B)
    goto <bb 54> (unacct_error);
  else
    goto <bb 18>;

  <bb 18>:
  vma_159->vm_mm = mm_35;
  vma_159->vm_start = addr_42(D);
  vma_159->vm_end = pretmp_156;
  vma_159->vm_flags = vm_flags_4;
  _160 = vm_flags_4 & 15;
  _161 = protection_map[_160].pgprot;
  MEM[(struct vm_area_struct *)vma_159 + 72B] = _161;
  vma_159->vm_pgoff = pgoff_62(D);
  _74 = &vma_159->anon_vma_chain;
  MEM[(struct list_head *)vma_159 + 120B].next = _74;
  MEM[(struct list_head *)vma_159 + 120B].prev = _74;
  if (file_54(D) != 0B)
    goto <bb 19>;
  else
    goto <bb 34>;

  <bb 19>:
  _76 = vm_flags_4 & 2048;
  if (_76 != 0)
    goto <bb 20>;
  else
    goto <bb 24>;

  <bb 20>:
  _162 = MEM[(const struct file *)file_54(D) + 32B];

  <bb 21>:
  # v_230 = PHI <v_166(23), 0(20)>
  _164 = v_230 + -1;
  __ptr_165 = &MEM[(struct atomic_t *)_162 + 320B].counter;
  __asm__ __volatile__(".pushsection .smp_locks,"a"
.balign 4
.long 671f - .
.popsection
671:
	lock; cmpxchgl %2,%1" : "=a" v_166, "=m" *__ptr_165 : "r" _164, "0" v_230, "m" *__ptr_165 : "memory");
  if (v_230 == v_166)
    goto <bb 24>;
  else
    goto <bb 22>;

  <bb 22>:
  if (v_166 <= 0)
    goto <bb 23>;
  else
    goto <bb 53> (free_vma);

  <bb 23>:
  goto <bb 21>;

  <bb 24>:
  _79 = vm_flags_4 & 8;
  if (_79 != 0)
    goto <bb 25>;
  else
    goto <bb 29>;

  <bb 25>:
  _80 = file_54(D)->f_mapping;

  <bb 26>:
  # v_229 = PHI <v_175(28), 0(25)>
  _173 = v_229 + 1;
  __ptr_174 = &MEM[(struct atomic_t *)_80 + 28B].counter;
  __asm__ __volatile__(".pushsection .smp_locks,"a"
.balign 4
.long 671f - .
.popsection
671:
	lock; cmpxchgl %2,%1" : "=a" v_175, "=m" *__ptr_174 : "r" _173, "0" v_229, "m" *__ptr_174 : "memory");
  if (v_229 == v_175)
    goto <bb 29>;
  else
    goto <bb 27>;

  <bb 27>:
  if (v_175 >= 0)
    goto <bb 28>;
  else
    goto <bb 51> (allow_write_and_free_vma);

  <bb 28>:
  goto <bb 26>;

  <bb 29>:
  _181 = &file_54(D)->f_count;
  __asm__ __volatile__(".pushsection .smp_locks,"a"
.balign 4
.long 671f - .
.popsection
671:
	lock; incq %0" : "=m" MEM[(struct atomic64_t *)_181].counter : "m" MEM[(struct atomic64_t *)_181].counter);
  vma_159->vm_file = file_54(D);
  _86 = file_54(D)->f_op;
  _87 = _86->mmap;
  error_89 = _87 (file_54(D), vma_159);
  if (error_89 != 0)
    goto <bb 49> (unmap_and_free_vma);
  else
    goto <bb 30>;

  <bb 30>:
  _90 = vma_159->vm_start;
  if (addr_42(D) != _90)
    goto <bb 31>;
  else
    goto <bb 33>;

  <bb 31>:
  __warned.60_94 = __warned;
  if (__warned.60_94 != 0)
    goto <bb 33>;
  else
    goto <bb 32>;

  <bb 32>:
  warn_slowpath_null ("mm/mmap.c", 1674);
  __warned = 1;
  pretmp_210 = vma_159->vm_start;

  <bb 33>:
  # addr_185 = PHI <addr_42(D)(30), _90(31), pretmp_210(32)>
  vm_flags_101 = vma_159->vm_flags;
  rb_parent.61_244 = rb_parent;
  rb_link.62_243 = rb_link;
  prev.58_233 = prev;
  vma_link (mm_35, vma_159, prev.58_233, rb_link.62_243, rb_parent.61_244);
  _118 = vm_flags_101 & 8;
  if (_118 != 0)
    goto <bb 36>;
  else
    goto <bb 37>;

  <bb 34>:
  _111 = vm_flags_4 & 8;
  if (_111 != 0)
    goto <bb 35>;
  else
    goto <bb 59>;

  <bb 35>:
  error_113 = shmem_zero_setup (vma_159);
  if (error_113 != 0)
    goto <bb 53> (free_vma);
  else
    goto <bb 59>;

  <bb 36>:
  _119 = file_54(D)->f_mapping;
  _182 = &_119->i_mmap_writable;
  __asm__ __volatile__(".pushsection .smp_locks,"a"
.balign 4
.long 671f - .
.popsection
671:
	lock; decl %0" : "=m" _182->counter : "m" _182->counter);

  <bb 37>:
  _121 = vm_flags_101 & 2048;
  if (_121 != 0)
    goto <bb 38>;
  else
    goto <bb 39>;

  <bb 38>:
  _183 = MEM[(const struct file *)file_54(D) + 32B];
  _184 = &_183->i_writecount;
  __asm__ __volatile__(".pushsection .smp_locks,"a"
.balign 4
.long 671f - .
.popsection
671:
	lock; incl %0" : "=m" _184->counter : "m" _184->counter);

  <bb 39>:
  # addr_225 = PHI <addr_42(D)(59), addr_185(37), addr_185(38)>
  # vm_flags_239 = PHI <vm_flags_4(59), vm_flags_101(37), vm_flags_101(38)>
  file_123 = vma_159->vm_file;

  # file_1 = PHI <file_54(D)(16), file_123(39)>
  # addr_3 = PHI <addr_42(D)(16), addr_225(39)>
  # vm_flags_6 = PHI <vm_flags_4(16), vm_flags_239(39)>
  # vma_7 = PHI <vma_64(16), vma_159(39)>
out:
  perf_event_mmap (vma_7);
  _130 = (long int) charged_37;
  vm_stat_account (mm_35, vm_flags_6, file_1, _130);
  _132 = vm_flags_6 & 8192;
  if (_132 != 0)
    goto <bb 41>;
  else
    goto <bb 48>;

  <bb 41>:
  _133 = vm_flags_6 & 268715008;
  if (_133 == 0)
    goto <bb 42>;
  else
    goto <bb 46>;

  <bb 42>:
  _134 = MEM[(struct vm_area_struct *)vma_7 + 80B];
  _186 = _134 & 4194304;
  if (_186 == 0)
    goto <bb 43>;
  else
    goto <bb 47>;

  <bb 43>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___150 : "p" &current_task);
  _136 = pfo_ret___150->mm;
  _138 = get_gate_vma (_136);
  if (_138 != vma_7)
    goto <bb 45>;
  else
    goto <bb 44>;

  <bb 44>:
  pretmp_91 = _138->vm_flags;
  goto <bb 47>;

  <bb 45>:
  _139 = mm_35->locked_vm;
  _140 = charged_37 + _139;
  mm_35->locked_vm = _140;
  goto <bb 48>;

  <bb 46>:
  pretmp_202 = MEM[(struct vm_area_struct *)vma_7 + 80B];

  <bb 47>:
  # prephitmp_163 = PHI <pretmp_202(46), _134(42), pretmp_91(44)>
  _143 = prephitmp_163 & 18446744073709543423;
  vma_7->vm_flags = _143;

  <bb 48>:
  vma_set_page_prot (vma_7);
  goto <bb 57>;

unmap_and_free_vma:
  vma_159->vm_file = 0B;
  fput (file_54(D));
  _104 = vma_159->vm_end;
  _105 = vma_159->vm_start;
  prev.58_106 = prev;
  unmap_region (mm_35, vma_159, prev.58_106, _105, _104);
  if (_79 != 0)
    goto <bb 50>;
  else
    goto <bb 51> (allow_write_and_free_vma);

  <bb 50>:
  _108 = file_54(D)->f_mapping;
  mapping_unmap_writable (_108);

  # error_8 = PHI <-1(27), error_89(49), error_89(50)>
  # charged_12 = PHI <charged_11(27), 0(49), 0(50)>
allow_write_and_free_vma:
  if (_76 != 0)
    goto <bb 52>;
  else
    goto <bb 53> (free_vma);

  <bb 52>:
  allow_write_access (file_54(D));

  # error_9 = PHI <-26(22), error_113(35), error_8(51), error_8(52)>
  # charged_13 = PHI <charged_11(22), charged_11(35), charged_12(51), charged_12(52)>
free_vma:
  vm_area_cachep.59_124 = vm_area_cachep;
  kmem_cache_free (vm_area_cachep.59_124, vma_159);
  pretmp_172 = (long unsigned int) error_9;

  # charged_14 = PHI <charged_11(17), charged_13(53)>
  # prephitmp_234 = PHI <18446744073709551604(17), pretmp_172(53)>
unacct_error:
  if (charged_14 != 0)
    goto <bb 55>;
  else
    goto <bb 56>;

  <bb 55>:
  charged.57_126 = (long int) charged_14;
  _189 = -charged.57_126;
  vm_committed_as_batch.6_190 = vm_committed_as_batch;
  __percpu_counter_add (&vm_committed_as, _189, vm_committed_as_batch.6_190);

  <bb 56>:

  <bb 57>:
  # _15 = PHI <18446744073709551604(4), prephitmp_234(56), addr_3(48)>
  prev ={v} {CLOBBER};
  rb_link ={v} {CLOBBER};
  rb_parent ={v} {CLOBBER};
  return _15;

  <bb 58>:
  goto <bb 16>;

  <bb 59>:
  rb_parent.61_242 = rb_parent;
  rb_link.62_241 = rb_link;
  prev.58_240 = prev;
  vma_link (mm_35, vma_159, prev.58_240, rb_link.62_241, rb_parent.61_242);
  goto <bb 39>;

}



;; Function unmapped_area (unmapped_area, funcdef_no=3030, decl_uid=25216, cgraph_uid=3032)

unmapped_area (struct vm_unmapped_area_info * info)
{
  struct task_struct * pfo_ret__;
  const struct rb_node * __mptr;
  struct rb_node * prev;
  long unsigned int gap_end;
  long unsigned int gap_start;
  long unsigned int high_limit;
  long unsigned int low_limit;
  long unsigned int length;
  struct vm_area_struct * vma;
  struct mm_struct * mm;
  long unsigned int _8;
  long unsigned int _13;
  long unsigned int _14;
  long unsigned int _16;
  struct rb_node * _20;
  long unsigned int _22;
  struct rb_node * _24;
  long unsigned int _26;
  struct vm_area_struct * _27;
  long unsigned int _29;
  struct rb_node * _30;
  long unsigned int _32;
  long unsigned int _34;
  long unsigned int _35;
  struct rb_node * _38;
  struct vm_area_struct * _39;
  long unsigned int _45;
  long unsigned int _46;
  long unsigned int _48;
  struct rb_node * _68;

  <bb 2>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___50 : "p" &current_task);
  mm_11 = pfo_ret___50->mm;
  _13 = info_12(D)->length;
  _14 = info_12(D)->align_mask;
  length_15 = _14 + _13;
  if (_13 > length_15)
    goto <bb 29>;
  else
    goto <bb 3>;

  <bb 3>:
  _16 = info_12(D)->high_limit;
  if (length_15 > _16)
    goto <bb 29>;
  else
    goto <bb 4>;

  <bb 4>:
  high_limit_17 = _16 - length_15;
  gap_start_18 = info_12(D)->low_limit;
  if (high_limit_17 < gap_start_18)
    goto <bb 29>;
  else
    goto <bb 5>;

  <bb 5>:
  _20 = mm_11->mm_rb.rb_node;
  if (_20 == 0B)
    goto <bb 27> (check_highest);
  else
    goto <bb 6>;

  <bb 6>:
  _22 = MEM[(struct vm_area_struct *)_20 + -32B].rb_subtree_gap;
  if (length_15 > _22)
    goto <bb 27> (check_highest);
  else
    goto <bb 7>;

  <bb 7>:
  low_limit_19 = length_15 + gap_start_18;
  vma_21 = &MEM[(void *)_20 + -32B];
  goto <bb 10>;

  <bb 8>:
  vma_25 = &MEM[(void *)_24 + -32B];

  <bb 9>:
  # vma_47 = PHI <vma_25(8), vma_31(20)>

  <bb 10>:
  # vma_1 = PHI <vma_21(7), vma_47(9)>
  gap_end_23 = vma_1->vm_start;
  if (low_limit_19 <= gap_end_23)
    goto <bb 11>;
  else
    goto <bb 13>;

  <bb 11>:
  _24 = vma_1->vm_rb.rb_left;
  if (_24 != 0B)
    goto <bb 12>;
  else
    goto <bb 13>;

  <bb 12>:
  _26 = MEM[(struct vm_area_struct *)_24 + -32B].rb_subtree_gap;
  if (length_15 <= _26)
    goto <bb 8>;
  else
    goto <bb 13>;

  <bb 13>:
  _27 = vma_1->vm_prev;
  if (_27 != 0B)
    goto <bb 15>;
  else
    goto <bb 14>;

  <bb 14>:
  # gap_start_43 = PHI <0(13), gap_start_28(15)>
  goto <bb 16>;

  <bb 15>:
  gap_start_28 = _27->vm_end;
  if (high_limit_17 < gap_start_28)
    goto <bb 29>;
  else
    goto <bb 14>;

  <bb 16>:
  # vma_57 = PHI <vma_1(14), vma_37(26)>
  # gap_start_79 = PHI <gap_start_43(14), gap_start_40(26)>
  # gap_end_78 = PHI <gap_end_23(14), gap_end_41(26)>
  if (low_limit_19 <= gap_end_78)
    goto <bb 17>;
  else
    goto <bb 18>;

  <bb 17>:
  _29 = gap_end_78 - gap_start_79;
  if (length_15 <= _29)
    goto <bb 28> (found);
  else
    goto <bb 18>;

  <bb 18>:
  _30 = vma_57->vm_rb.rb_right;
  if (_30 != 0B)
    goto <bb 19>;
  else
    goto <bb 21>;

  <bb 19>:
  _32 = MEM[(struct vm_area_struct *)_30 + -32B].rb_subtree_gap;
  if (length_15 <= _32)
    goto <bb 20>;
  else
    goto <bb 21>;

  <bb 20>:
  # _68 = PHI <_30(19)>
  vma_31 = &MEM[(void *)_68 + -32B];
  goto <bb 9>;

  <bb 21>:

  <bb 22>:
  # vma_3 = PHI <vma_57(21), vma_37(24)>
  prev_33 = &vma_3->vm_rb;
  _34 = MEM[(struct rb_node *)vma_3 + 32B].__rb_parent_color;
  _35 = _34 & 18446744073709551612;
  if (_35 == 0)
    goto <bb 27> (check_highest);
  else
    goto <bb 23>;

  <bb 23>:
  __mptr_36 = (const struct rb_node *) _35;
  vma_37 = &MEM[(void *)__mptr_36 + -32B];
  _38 = MEM[(struct vm_area_struct *)__mptr_36 + -32B].vm_rb.rb_left;
  if (_38 == prev_33)
    goto <bb 25>;
  else
    goto <bb 24>;

  <bb 24>:
  goto <bb 22>;

  <bb 25>:
  # __mptr_56 = PHI <__mptr_36(23)>
  _39 = MEM[(struct vm_area_struct *)__mptr_56 + -32B].vm_prev;
  gap_start_40 = _39->vm_end;
  gap_end_41 = MEM[(struct vm_area_struct *)__mptr_56 + -32B].vm_start;
  if (high_limit_17 < gap_start_40)
    goto <bb 29>;
  else
    goto <bb 26>;

  <bb 26>:
  goto <bb 16>;

check_highest:
  gap_start_42 = mm_11->highest_vm_end;
  if (high_limit_17 < gap_start_42)
    goto <bb 29>;
  else
    goto <bb 28> (found);

  # gap_start_5 = PHI <gap_start_79(17), gap_start_42(27)>
found:
  gap_start_44 = MAX_EXPR <gap_start_5, gap_start_18>;
  _45 = info_12(D)->align_offset;
  _46 = _45 - gap_start_44;
  _48 = _46 & _14;
  gap_start_49 = _48 + gap_start_44;

  <bb 29>:
  # _8 = PHI <18446744073709551604(3), gap_start_49(28), 18446744073709551604(2), 18446744073709551604(27), 18446744073709551604(25), 18446744073709551604(15), 18446744073709551604(4)>
  return _8;

}



;; Function unmapped_area_topdown (unmapped_area_topdown, funcdef_no=3031, decl_uid=25218, cgraph_uid=3033)

unmapped_area_topdown (struct vm_unmapped_area_info * info)
{
  struct task_struct * pfo_ret__;
  const struct rb_node * __mptr;
  struct rb_node * prev;
  long unsigned int gap_end;
  long unsigned int gap_start;
  long unsigned int high_limit;
  long unsigned int low_limit;
  long unsigned int length;
  struct vm_area_struct * vma;
  struct mm_struct * mm;
  long unsigned int _6;
  long unsigned int _12;
  long unsigned int _13;
  long unsigned int _17;
  struct rb_node * _20;
  long unsigned int _22;
  struct vm_area_struct * _23;
  struct rb_node * _25;
  long unsigned int _27;
  long unsigned int _29;
  struct rb_node * _31;
  long unsigned int _33;
  long unsigned int _35;
  long unsigned int _36;
  struct rb_node * _39;
  struct vm_area_struct * _40;
  long unsigned int _47;
  long unsigned int _48;
  long unsigned int _50;
  struct rb_node * _55;

  <bb 2>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___52 : "p" &current_task);
  mm_10 = pfo_ret___52->mm;
  _12 = info_11(D)->length;
  _13 = info_11(D)->align_mask;
  length_14 = _13 + _12;
  if (_12 > length_14)
    goto <bb 31>;
  else
    goto <bb 3>;

  <bb 3>:
  gap_end_15 = info_11(D)->high_limit;
  if (length_14 > gap_end_15)
    goto <bb 31>;
  else
    goto <bb 4>;

  <bb 4>:
  high_limit_16 = gap_end_15 - length_14;
  _17 = info_11(D)->low_limit;
  if (high_limit_16 < _17)
    goto <bb 31>;
  else
    goto <bb 5>;

  <bb 5>:
  gap_start_19 = mm_10->highest_vm_end;
  if (high_limit_16 >= gap_start_19)
    goto <bb 30> (found_highest);
  else
    goto <bb 6>;

  <bb 6>:
  _20 = mm_10->mm_rb.rb_node;
  if (_20 == 0B)
    goto <bb 31>;
  else
    goto <bb 7>;

  <bb 7>:
  _22 = MEM[(struct vm_area_struct *)_20 + -32B].rb_subtree_gap;
  if (length_14 > _22)
    goto <bb 31>;
  else
    goto <bb 8>;

  <bb 8>:
  vma_21 = &MEM[(void *)_20 + -32B];
  goto <bb 11>;

  <bb 9>:
  vma_26 = &MEM[(void *)_25 + -32B];

  <bb 10>:
  # vma_8 = PHI <vma_26(9), vma_32(22)>

  <bb 11>:
  # vma_1 = PHI <vma_21(8), vma_8(10)>
  _23 = vma_1->vm_prev;
  if (_23 != 0B)
    goto <bb 12>;
  else
    goto <bb 13>;

  <bb 12>:
  gap_start_24 = _23->vm_end;
  if (high_limit_16 >= gap_start_24)
    goto <bb 13>;
  else
    goto <bb 14>;

  <bb 13>:
  # gap_start_65 = PHI <gap_start_24(12), 0(11)>
  _25 = vma_1->vm_rb.rb_right;
  if (_25 != 0B)
    goto <bb 15>;
  else
    goto <bb 14>;

  <bb 14>:
  # gap_start_43 = PHI <gap_start_65(13), gap_start_24(12), gap_start_65(15)>
  goto <bb 17>;

  <bb 15>:
  _27 = MEM[(struct vm_area_struct *)_25 + -32B].rb_subtree_gap;
  if (length_14 <= _27)
    goto <bb 9>;
  else
    goto <bb 14>;

  <bb 16>:
  # gap_start_45 = PHI <gap_start_42(28), 0(27)>

  <bb 17>:
  # vma_2 = PHI <vma_1(14), vma_38(16)>
  # gap_start_4 = PHI <gap_start_43(14), gap_start_45(16)>
  gap_end_28 = vma_2->vm_start;
  low_limit_18 = length_14 + _17;
  if (low_limit_18 > gap_end_28)
    goto <bb 31>;
  else
    goto <bb 18>;

  <bb 18>:
  if (gap_start_4 <= high_limit_16)
    goto <bb 19>;
  else
    goto <bb 20>;

  <bb 19>:
  _29 = gap_end_28 - gap_start_4;
  if (length_14 <= _29)
    goto <bb 29> (found);
  else
    goto <bb 20>;

  <bb 20>:
  _31 = vma_2->vm_rb.rb_left;
  if (_31 != 0B)
    goto <bb 21>;
  else
    goto <bb 23>;

  <bb 21>:
  _33 = MEM[(struct vm_area_struct *)_31 + -32B].rb_subtree_gap;
  if (length_14 <= _33)
    goto <bb 22>;
  else
    goto <bb 23>;

  <bb 22>:
  # _55 = PHI <_31(21)>
  vma_32 = &MEM[(void *)_55 + -32B];
  goto <bb 10>;

  <bb 23>:

  <bb 24>:
  # vma_3 = PHI <vma_2(23), vma_38(26)>
  prev_34 = &vma_3->vm_rb;
  _35 = MEM[(struct rb_node *)vma_3 + 32B].__rb_parent_color;
  _36 = _35 & 18446744073709551612;
  if (_36 == 0)
    goto <bb 31>;
  else
    goto <bb 25>;

  <bb 25>:
  __mptr_37 = (const struct rb_node *) _36;
  vma_38 = &MEM[(void *)__mptr_37 + -32B];
  _39 = MEM[(struct vm_area_struct *)__mptr_37 + -32B].vm_rb.rb_right;
  if (_39 == prev_34)
    goto <bb 27>;
  else
    goto <bb 26>;

  <bb 26>:
  goto <bb 24>;

  <bb 27>:
  # __mptr_54 = PHI <__mptr_37(25)>
  _40 = MEM[(struct vm_area_struct *)__mptr_54 + -32B].vm_prev;
  if (_40 != 0B)
    goto <bb 28>;
  else
    goto <bb 16>;

  <bb 28>:
  gap_start_42 = _40->vm_end;
  goto <bb 16>;

  # gap_end_81 = PHI <gap_end_28(19)>
found:
  gap_end_7 = MIN_EXPR <gap_end_81, gap_end_15>;

  # gap_end_5 = PHI <gap_end_15(5), gap_end_7(29)>
found_highest:
  gap_end_46 = gap_end_5 - _12;
  _47 = info_11(D)->align_offset;
  _48 = gap_end_46 - _47;
  _50 = _48 & _13;
  gap_end_51 = gap_end_46 - _50;

  <bb 31>:
  # _6 = PHI <18446744073709551604(3), gap_end_51(30), 18446744073709551604(2), 18446744073709551604(24), 18446744073709551604(17), 18446744073709551604(7), 18446744073709551604(6), 18446744073709551604(4)>
  return _6;

}



;; Function find_vma_prev (find_vma_prev, funcdef_no=3034, decl_uid=25277, cgraph_uid=3036)

find_vma_prev (struct mm_struct * mm, long unsigned int addr, struct vm_area_struct * * pprev)
{
  const struct rb_node * __mptr;
  struct vm_area_struct * vma;
  struct vm_area_struct * _9;
  struct vm_area_struct * _14;

  <bb 2>:
  vma_8 = find_vma (mm_5(D), addr_6(D));
  if (vma_8 != 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _9 = vma_8->vm_prev;
  *pprev_10(D) = _9;
  goto <bb 9>;

  <bb 4>:
  __mptr_12 = mm_5(D)->mm_rb.rb_node;
  *pprev_10(D) = 0B;
  if (__mptr_12 != 0B)
    goto <bb 6>;
  else
    goto <bb 5>;

  <bb 5>:
  goto <bb 9>;

  <bb 6>:

  <bb 7>:
  # __mptr_18 = PHI <__mptr_16(8), __mptr_12(6)>
  _14 = __mptr_18 + 18446744073709551584;
  *pprev_10(D) = _14;
  __mptr_16 = MEM[(struct rb_node *)__mptr_18].rb_right;
  if (__mptr_16 != 0B)
    goto <bb 8>;
  else
    goto <bb 5>;

  <bb 8>:
  goto <bb 7>;

  <bb 9>:
  return vma_8;

}



;; Function expand_downwards (expand_downwards, funcdef_no=3036, decl_uid=25270, cgraph_uid=3038)

expand_downwards (struct vm_area_struct * vma, long unsigned int address)
{
  struct vm_area_struct * node;
  long unsigned int augmented;
  struct rb_node * rb;
  struct anon_vma_chain * avc;
  const struct list_head * __mptr;
  struct anon_vma_chain * avc;
  const struct list_head * __mptr;
  const struct list_head * __mptr;
  long int grow.95;
  struct mm_struct * mm;
  long unsigned int locked;
  long unsigned int limit;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  long unsigned int lim;
  long unsigned int cur;
  struct anon_vma * anon_vma;
  struct anon_vma * anon_vma;
  long unsigned int grow;
  long unsigned int size;
  int error;
  int _2;
  int _8;
  long unsigned int prephitmp_10;
  long unsigned int pretmp_11;
  long unsigned int _18;
  long unsigned int _19;
  long unsigned int _21;
  long unsigned int _23;
  struct mm_struct * _26;
  long unsigned int _30;
  long unsigned int _31;
  struct mm_struct * _35;
  struct anon_vma * _40;
  struct rw_semaphore * _41;
  struct raw_spinlock * _42;
  struct anon_vma * _45;
  struct rw_semaphore * _46;
  long unsigned int _48;
  struct signal_struct * _56;
  struct signal_struct * _59;
  long long unsigned int _60;
  long unsigned int _62;
  long unsigned int _64;
  long unsigned int _65;
  long long unsigned int _67;
  long unsigned int _70;
  long unsigned int _71;
  long long unsigned int _73;
  _Bool _75;
  int _77;
  long unsigned int _78;
  long unsigned int _79;
  long unsigned int _80;
  long unsigned int _81;
  struct file * _82;
  struct list_head * _84;
  long unsigned int prephitmp_87;
  struct anon_vma * _88;
  struct rb_root * _89;
  struct list_head * _92;
  struct anon_vma * _97;
  struct rb_root * _98;
  struct list_head * _101;
  long int _105;
  long unsigned int _107;
  long unsigned int _108;
  long unsigned int _109;
  struct list_head * _113;
  long unsigned int pretmp_114;
  long long unsigned int _133;
  struct list_head * pretmp_139;
  struct list_head * pretmp_143;
  long unsigned int _148;

  <bb 2>:
  _8 = anon_vma_prepare (vma_6(D));
  if (_8 != 0)
    goto <bb 34>;
  else
    goto <bb 3>;

  <bb 3>:
  address_13 = address_12(D) & 18446744073709547520;
  error_15 = security_mmap_addr (address_13);
  if (error_15 != 0)
    goto <bb 34>;
  else
    goto <bb 4>;

  <bb 4>:
  anon_vma_16 = MEM[(struct vm_area_struct *)vma_6(D) + 136B];
  if (anon_vma_16 != 0B)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  _40 = anon_vma_16->root;
  _41 = &_40->rwsem;
  down_write (_41);

  <bb 6>:
  _18 = vma_6(D)->vm_start;
  if (address_13 < _18)
    goto <bb 7>;
  else
    goto <bb 32>;

  <bb 7>:
  _19 = vma_6(D)->vm_end;
  _21 = _18 - address_13;
  grow_22 = _21 >> 12;
  _23 = vma_6(D)->vm_pgoff;
  if (grow_22 <= _23)
    goto <bb 8>;
  else
    goto <bb 32>;

  <bb 8>:
  mm_54 = vma_6(D)->vm_mm;
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___55 : "p" &current_task);
  _56 = pfo_ret___55->signal;
  cur_57 = mm_54->total_vm;
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___58 : "p" &current_task);
  _59 = MEM[(const struct task_struct *)pfo_ret___58].signal;
  _60 ={v} MEM[(volatile __u64 *)_59].rlim[9].rlim_cur;
  lim_61 = _60 >> 12;
  _62 = grow_22 + cur_57;
  if (lim_61 < _62)
    goto <bb 37>;
  else
    goto <bb 35>;

  <bb 9>:
  _64 = vma_6(D)->vm_flags;
  _65 = _64 & 256;
  if (_65 != 0)
    goto <bb 10>;
  else
    goto <bb 11>;

  <bb 10>:
  size_66 = size_20 + 18446744073709547520;

  <bb 11>:
  # size_68 = PHI <size_66(10), size_20(9)>
  _67 ={v} MEM[(volatile __u64 *)_56 + 728B];
  if (_67 < size_68)
    goto <bb 37>;
  else
    goto <bb 12>;

  <bb 12>:
  # prephitmp_87 = PHI <_64(11), pretmp_114(36)>
  _70 = prephitmp_87 & 8192;
  if (_70 != 0)
    goto <bb 14>;
  else
    goto <bb 13>;

  <bb 13>:
  grow.95_76 = (long int) grow_22;
  _77 = security_vm_enough_memory_mm (mm_54, grow.95_76);
  if (_77 != 0)
    goto <bb 37>;
  else
    goto <bb 16>;

  <bb 14>:
  _71 = mm_54->locked_vm;
  locked_72 = grow_22 + _71;
  _73 ={v} MEM[(volatile __u64 *)_56 + 808B];
  limit_74 = _73 >> 12;
  if (locked_72 > limit_74)
    goto <bb 15>;
  else
    goto <bb 13>;

  <bb 15>:
  _75 = capable (14);
  if (_75 != 0)
    goto <bb 13>;
  else
    goto <bb 37>;

  <bb 16>:
  _78 = vma_6(D)->vm_flags;
  _79 = _78 & 8192;
  if (_79 != 0)
    goto <bb 17>;
  else
    goto <bb 18>;

  <bb 17>:
  _80 = mm_54->locked_vm;
  _81 = grow_22 + _80;
  mm_54->locked_vm = _81;
  pretmp_11 = vma_6(D)->vm_flags;

  <bb 18>:
  # prephitmp_10 = PHI <_78(16), pretmp_11(17)>
  _82 = vma_6(D)->vm_file;
  vm_stat_account (mm_54, prephitmp_10, _82, grow.95_76);
  _26 = vma_6(D)->vm_mm;
  _42 = &MEM[(struct spinlock_t *)_26 + 100B].D.5408.rlock;
  _raw_spin_lock (_42);
  __mptr_85 = vma_6(D)->anon_vma_chain.next;
  avc_86 = &MEM[(void *)__mptr_85 + -16B];
  _113 = &MEM[(struct anon_vma_chain *)__mptr_85 + -16B].same_vma;
  _84 = &vma_6(D)->anon_vma_chain;
  if (_113 != _84)
    goto <bb 19>;
  else
    goto <bb 38>;

  <bb 19>:

  <bb 20>:
  # avc_63 = PHI <avc_91(21), avc_86(19)>
  _88 = avc_63->anon_vma;
  _89 = &_88->rb_root;
  anon_vma_interval_tree_remove (avc_63, _89);
  __mptr_90 = avc_63->same_vma.next;
  avc_91 = &MEM[(void *)__mptr_90 + -16B];
  _92 = &MEM[(struct anon_vma_chain *)__mptr_90 + -16B].same_vma;
  if (_84 != _92)
    goto <bb 21>;
  else
    goto <bb 22>;

  <bb 21>:
  goto <bb 20>;

  <bb 22>:
  pretmp_139 = vma_6(D)->anon_vma_chain.next;
  avc_141 = &MEM[(void *)pretmp_139 + -16B];
  pretmp_143 = &MEM[(struct anon_vma_chain *)pretmp_139 + -16B].same_vma;
  vma_6(D)->vm_start = address_13;
  _30 = vma_6(D)->vm_pgoff;
  _31 = _30 - grow_22;
  vma_6(D)->vm_pgoff = _31;
  if (_84 != pretmp_143)
    goto <bb 24>;
  else
    goto <bb 23>;

  <bb 23>:
  rb_43 = &vma_6(D)->vm_rb;
  if (rb_43 != 0B)
    goto <bb 28>;
  else
    goto <bb 27>;

  <bb 24>:

  <bb 25>:
  # avc_25 = PHI <avc_100(26), avc_141(24)>
  _97 = avc_25->anon_vma;
  _98 = &_97->rb_root;
  anon_vma_interval_tree_insert (avc_25, _98);
  __mptr_99 = avc_25->same_vma.next;
  avc_100 = &MEM[(void *)__mptr_99 + -16B];
  _101 = &MEM[(struct anon_vma_chain *)__mptr_99 + -16B].same_vma;
  if (_84 != _101)
    goto <bb 26>;
  else
    goto <bb 23>;

  <bb 26>:
  goto <bb 25>;

  <bb 27>:
  _35 = vma_6(D)->vm_mm;
  __asm__ __volatile__("" :  :  : "memory");
  MEM[(volatile __u8 *)_35 + 100B] ={v} 0;
  __asm__ __volatile__("" :  :  : "memory");
  perf_event_mmap (vma_6(D));
  goto <bb 32>;

  <bb 28>:

  <bb 29>:
  # rb_102 = PHI <rb_110(31), rb_43(28)>
  node_104 = &MEM[(void *)rb_102 + -32B];
  _105 = vma_compute_subtree_gap (node_104);
  augmented_106 = (long unsigned int) _105;
  _107 = MEM[(struct vm_area_struct *)rb_102 + -32B].rb_subtree_gap;
  if (augmented_106 == _107)
    goto <bb 27>;
  else
    goto <bb 30>;

  <bb 30>:
  MEM[(struct vm_area_struct *)rb_102 + -32B].rb_subtree_gap = augmented_106;
  _108 = MEM[(struct vm_area_struct *)rb_102 + -32B].vm_rb.__rb_parent_color;
  _109 = _108 & 18446744073709551612;
  rb_110 = (struct rb_node *) _109;
  if (rb_110 != 0B)
    goto <bb 31>;
  else
    goto <bb 27>;

  <bb 31>:
  goto <bb 29>;

  <bb 32>:
  # error_1 = PHI <error_15(6), -12(7), -12(37), error_15(27)>
  anon_vma_38 = MEM[(struct vm_area_struct *)vma_6(D) + 136B];
  if (anon_vma_38 != 0B)
    goto <bb 33>;
  else
    goto <bb 34>;

  <bb 33>:
  _45 = anon_vma_38->root;
  _46 = &_45->rwsem;
  up_write (_46);

  <bb 34>:
  # _2 = PHI <-12(2), error_15(3), error_1(32), error_1(33)>
  return _2;

  <bb 35>:
  size_20 = _19 - address_13;
  if (size_20 != 0)
    goto <bb 9>;
  else
    goto <bb 36>;

  <bb 36>:
  _133 ={v} MEM[(volatile __u64 *)_56 + 728B];
  pretmp_114 = vma_6(D)->vm_flags;
  goto <bb 12>;

  <bb 37>:
  goto <bb 32>;

  <bb 38>:
  vma_6(D)->vm_start = address_13;
  _48 = vma_6(D)->vm_pgoff;
  _148 = _48 - grow_22;
  vma_6(D)->vm_pgoff = _148;
  goto <bb 23>;

}



;; Function expand_stack (expand_stack, funcdef_no=3037, decl_uid=25267, cgraph_uid=3039)

expand_stack (struct vm_area_struct * vma, long unsigned int address)
{
  struct vm_area_struct * prev;
  int _1;
  long unsigned int _8;
  long unsigned int _9;
  long unsigned int _10;
  int _12;

  <bb 2>:
  address_4 = address_3(D) & 18446744073709547520;
  prev_7 = vma_6(D)->vm_prev;
  if (prev_7 != 0B)
    goto <bb 3>;
  else
    goto <bb 5>;

  <bb 3>:
  _8 = prev_7->vm_end;
  if (_8 == address_4)
    goto <bb 4>;
  else
    goto <bb 5>;

  <bb 4>:
  _9 = prev_7->vm_flags;
  _10 = _9 & 256;
  if (_10 == 0)
    goto <bb 6>;
  else
    goto <bb 5>;

  <bb 5>:
  _12 = expand_downwards (vma_6(D), address_4);

  <bb 6>:
  # _1 = PHI <-12(4), _12(5)>
  return _1;

}



;; Function find_extend_vma (find_extend_vma, funcdef_no=3038, decl_uid=25299, cgraph_uid=3040)

find_extend_vma (struct mm_struct * mm, long unsigned int addr)
{
  struct vm_area_struct * vma;
  struct vm_area_struct * _1;
  long unsigned int _10;
  long unsigned int _11;
  long unsigned int _12;
  int _14;
  long unsigned int _15;
  long unsigned int _16;

  <bb 2>:
  addr_5 = addr_4(D) & 18446744073709547520;
  vma_9 = find_vma (mm_7(D), addr_5);
  if (vma_9 == 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  goto <bb 9>;

  <bb 4>:
  _10 = vma_9->vm_start;
  if (addr_5 >= _10)
    goto <bb 9>;
  else
    goto <bb 5>;

  <bb 5>:
  _11 = vma_9->vm_flags;
  _12 = _11 & 256;
  if (_12 == 0)
    goto <bb 3>;
  else
    goto <bb 6>;

  <bb 6>:
  _14 = expand_stack (vma_9, addr_5);
  if (_14 != 0)
    goto <bb 3>;
  else
    goto <bb 7>;

  <bb 7>:
  _15 = vma_9->vm_flags;
  _16 = _15 & 8192;
  if (_16 != 0)
    goto <bb 8>;
  else
    goto <bb 9>;

  <bb 8>:
  populate_vma_page_range (vma_9, addr_5, _10, 0B);

  <bb 9>:
  # _1 = PHI <0B(3), vma_9(4), vma_9(7), vma_9(8)>
  return _1;

}



;; Function split_vma (split_vma, funcdef_no=3043, decl_uid=25103, cgraph_uid=3045)

split_vma (struct mm_struct * mm, struct vm_area_struct * vma, long unsigned int addr, int new_below)
{
  int sysctl_max_map_count.96;
  int _1;
  int _5;
  int _11;

  <bb 2>:
  _5 = mm_4(D)->map_count;
  sysctl_max_map_count.96_6 = sysctl_max_map_count;
  if (_5 >= sysctl_max_map_count.96_6)
    goto <bb 4>;
  else
    goto <bb 3>;

  <bb 3>:
  _11 = __split_vma.isra.41 (vma_7(D), addr_8(D), new_below_9(D));

  <bb 4>:
  # _1 = PHI <-12(2), _11(3)>
  return _1;

}



;; Function do_munmap (do_munmap, funcdef_no=3044, decl_uid=25177, cgraph_uid=3046)

do_munmap (struct mm_struct * mm, long unsigned int start, size_t len)
{
  long int nr_accounted.107;
  long unsigned int nr_accounted;
  long int nrpages;
  int vm_committed_as_batch.6;
  struct vm_area_struct * node;
  long unsigned int augmented;
  struct rb_node * rb;
  long unsigned int iftmp.105;
  struct vm_area_struct * * insertion_point;
  struct task_struct * pfo_ret__;
  u64 pfo_ret__;
  struct task_struct * pfo_ret__;
  u64 pfo_ret__;
  struct vm_area_struct * tmp;
  int error;
  int error;
  struct vm_area_struct * last;
  struct vm_area_struct * prev;
  long unsigned int end;
  int sysctl_max_map_count.102;
  long unsigned int iftmp.100;
  long unsigned int iftmp.98;
  int _7;
  long unsigned int _16;
  unsigned int _19;
  unsigned int _20;
  unsigned int _23;
  unsigned int _24;
  long unsigned int _25;
  long unsigned int _26;
  long unsigned int _28;
  long unsigned int _35;
  long unsigned int _36;
  int _37;
  long unsigned int _43;
  long unsigned int _48;
  long unsigned int _49;
  long unsigned int _50;
  long unsigned int _51;
  long unsigned int _52;
  long unsigned int _53;
  long unsigned int _54;
  long unsigned int _62;
  struct thread_info * _63;
  long unsigned int _64;
  long unsigned int _65;
  long unsigned int _66;
  long unsigned int _69;
  struct thread_info * _70;
  long unsigned int _71;
  long unsigned int _72;
  long unsigned int _73;
  long unsigned int _75;
  long unsigned int _76;
  long unsigned int _77;
  long unsigned int _78;
  int _84;
  int _85;
  long unsigned int _87;
  unsigned int _92;
  unsigned int _93;
  long int _99;
  long unsigned int _101;
  long unsigned int _102;
  long unsigned int _103;
  long unsigned int _105;
  long unsigned int _106;
  long unsigned int _108;
  long unsigned int _109;
  long unsigned int _110;
  long unsigned int _111;
  long unsigned int _113;
  long unsigned int _114;
  long int _117;
  struct file * _118;
  long int _122;
  long unsigned int _135;
  struct rb_root * pretmp_151;

  <bb 2>:
  _16 = start_15(D) & 4095;
  if (_16 != 0)
    goto <bb 56>;
  else
    goto <bb 3>;

  <bb 3>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___61 : "p" &cpu_tss.x86_tss.sp0);
  _62 = pfo_ret___61 + 18446744073709535232;
  _63 = (struct thread_info *) _62;
  _64 ={v} MEM[(const long unsigned int *)_63 + 8B];
  _65 = _64 >> 29;
  _66 = _65 & 1;
  if (_66 != 0)
    goto <bb 4>;
  else
    goto <bb 6>;

  <bb 4>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___67 : "p" &current_task);
  _19 = pfo_ret___67->personality;
  _20 = _19 & 134217728;
  if (_20 != 0)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:

  <bb 6>:
  # iftmp.98_3 = PHI <4294959104(4), 140737488351232(3), 3221225472(5)>
  if (iftmp.98_3 < start_15(D))
    goto <bb 56>;
  else
    goto <bb 7>;

  <bb 7>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___68 : "p" &cpu_tss.x86_tss.sp0);
  _69 = pfo_ret___68 + 18446744073709535232;
  _70 = (struct thread_info *) _69;
  _71 ={v} MEM[(const long unsigned int *)_70 + 8B];
  _72 = _71 >> 29;
  _73 = _72 & 1;
  if (_73 != 0)
    goto <bb 8>;
  else
    goto <bb 10>;

  <bb 8>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___74 : "p" &current_task);
  _23 = pfo_ret___74->personality;
  _24 = _23 & 134217728;
  if (_24 != 0)
    goto <bb 9>;
  else
    goto <bb 10>;

  <bb 9>:

  <bb 10>:
  # iftmp.100_5 = PHI <4294959104(8), 140737488351232(7), 3221225472(9)>
  _26 = iftmp.100_5 - start_15(D);
  if (_26 < len_27(D))
    goto <bb 56>;
  else
    goto <bb 11>;

  <bb 11>:
  _28 = len_27(D) + 4095;
  len_29 = _28 & 18446744073709547520;
  if (len_29 == 0)
    goto <bb 56>;
  else
    goto <bb 12>;

  <bb 12>:
  prev_32 = find_vma (mm_30(D), start_15(D));
  if (prev_32 == 0B)
    goto <bb 56>;
  else
    goto <bb 13>;

  <bb 13>:
  prev_33 = prev_32->vm_prev;
  end_34 = len_29 + start_15(D);
  _35 = prev_32->vm_start;
  if (end_34 <= _35)
    goto <bb 56>;
  else
    goto <bb 14>;

  <bb 14>:
  if (start_15(D) > _35)
    goto <bb 15>;
  else
    goto <bb 18>;

  <bb 15>:
  _36 = prev_32->vm_end;
  if (end_34 < _36)
    goto <bb 16>;
  else
    goto <bb 17>;

  <bb 16>:
  _37 = mm_30(D)->map_count;
  sysctl_max_map_count.102_38 = sysctl_max_map_count;
  if (_37 >= sysctl_max_map_count.102_38)
    goto <bb 56>;
  else
    goto <bb 17>;

  <bb 17>:
  error_40 = __split_vma.isra.41 (prev_32, start_15(D), 0);
  if (error_40 != 0)
    goto <bb 56>;
  else
    goto <bb 18>;

  <bb 18>:
  # prev_1 = PHI <prev_33(14), prev_32(17)>
  last_42 = find_vma (mm_30(D), end_34);
  if (last_42 != 0B)
    goto <bb 20>;
  else
    goto <bb 19>;

  <bb 19>:
  if (prev_1 != 0B)
    goto <bb 22>;
  else
    goto <bb 23>;

  <bb 20>:
  _43 = last_42->vm_start;
  if (end_34 > _43)
    goto <bb 21>;
  else
    goto <bb 19>;

  <bb 21>:
  error_45 = __split_vma.isra.41 (last_42, end_34, 1);
  if (error_45 != 0)
    goto <bb 56>;
  else
    goto <bb 19>;

  <bb 22>:
  tmp_46 = prev_1->vm_next;
  goto <bb 24>;

  <bb 23>:
  tmp_47 = mm_30(D)->mmap;

  <bb 24>:
  # tmp_8 = PHI <tmp_46(22), tmp_47(23)>
  _48 = mm_30(D)->locked_vm;
  if (_48 != 0)
    goto <bb 26>;
  else
    goto <bb 25>;

  <bb 25>:
  if (prev_1 != 0B)
    goto <bb 34>;
  else
    goto <bb 35>;

  <bb 26>:
  if (tmp_8 != 0B)
    goto <bb 27>;
  else
    goto <bb 25>;

  <bb 27>:
  _25 = tmp_8->vm_start;
  if (_25 < end_34)
    goto <bb 28>;
  else
    goto <bb 25>;

  <bb 28>:

  <bb 29>:
  # tmp_21 = PHI <tmp_57(33), tmp_8(28)>
  # _135 = PHI <_49(33), _25(28)>
  _50 = tmp_21->vm_flags;
  _51 = _50 & 8192;
  if (_51 != 0)
    goto <bb 30>;
  else
    goto <bb 31>;

  <bb 30>:
  _52 = mm_30(D)->locked_vm;
  _53 = MEM[(struct vm_area_struct *)tmp_21 + 8B];
  _75 = _53 - _135;
  _76 = _75 >> 12;
  _54 = _52 - _76;
  mm_30(D)->locked_vm = _54;
  _77 = tmp_21->vm_end;
  _78 = tmp_21->vm_start;
  munlock_vma_pages_range (tmp_21, _78, _77);

  <bb 31>:
  tmp_57 = tmp_21->vm_next;
  if (tmp_57 != 0B)
    goto <bb 32>;
  else
    goto <bb 25>;

  <bb 32>:
  _49 = tmp_57->vm_start;
  if (end_34 > _49)
    goto <bb 33>;
  else
    goto <bb 25>;

  <bb 33>:
  goto <bb 29>;

  <bb 34>:
  insertion_point_80 = &prev_1->vm_next;
  goto <bb 36>;

  <bb 35>:
  insertion_point_81 = &mm_30(D)->mmap;

  <bb 36>:
  # insertion_point_88 = PHI <insertion_point_80(34), insertion_point_81(35)>
  tmp_8->vm_prev = 0B;
  pretmp_151 = &mm_30(D)->mm_rb;

  <bb 37>:
  # tmp_83 = PHI <tmp_8(36), tmp_86(39)>
  vma_rb_erase (tmp_83, pretmp_151);
  _84 = mm_30(D)->map_count;
  _85 = _84 + -1;
  mm_30(D)->map_count = _85;
  tmp_86 = tmp_83->vm_next;
  if (tmp_86 != 0B)
    goto <bb 38>;
  else
    goto <bb 57>;

  <bb 38>:
  _87 = tmp_86->vm_start;
  if (end_34 > _87)
    goto <bb 39>;
  else
    goto <bb 58>;

  <bb 39>:
  goto <bb 37>;

  <bb 40>:

  <bb 41>:
  # rb_181 = PHI <rb_104(40), rb_89(58)>
  node_98 = &MEM[(void *)rb_181 + -32B];
  _99 = vma_compute_subtree_gap (node_98);
  augmented_100 = (long unsigned int) _99;
  _101 = MEM[(struct vm_area_struct *)rb_181 + -32B].rb_subtree_gap;
  if (augmented_100 == _101)
    goto <bb 42>;
  else
    goto <bb 43>;

  <bb 42>:
  goto <bb 46>;

  <bb 43>:
  MEM[(struct vm_area_struct *)rb_181 + -32B].rb_subtree_gap = augmented_100;
  _102 = MEM[(struct vm_area_struct *)rb_181 + -32B].vm_rb.__rb_parent_color;
  _103 = _102 & 18446744073709551612;
  rb_104 = (struct rb_node *) _103;
  if (rb_104 != 0B)
    goto <bb 40>;
  else
    goto <bb 42>;

  <bb 44>:
  iftmp.105_90 = prev_1->vm_end;

  <bb 45>:
  # iftmp.105_91 = PHI <0(57), iftmp.105_90(44)>
  mm_30(D)->highest_vm_end = iftmp.105_91;

  <bb 46>:
  # tmp_172 = PHI <tmp_83(42), tmp_83(45)>
  tmp_172->vm_next = 0B;
  _92 = mm_30(D)->vmacache_seqnum;
  _93 = _92 + 1;
  mm_30(D)->vmacache_seqnum = _93;
  if (_93 == 0)
    goto <bb 47>;
  else
    goto <bb 48>;

  <bb 47>:
  vmacache_flush_all (mm_30(D));

  <bb 48>:
  unmap_region (mm_30(D), tmp_8, prev_1, start_15(D), end_34);
  _105 = MEM[(struct mm_struct *)mm_30(D) + 176B];
  _106 = MEM[(long unsigned int *)mm_30(D) + 168B];
  if (_105 > _106)
    goto <bb 49>;
  else
    goto <bb 50>;

  <bb 49>:
  MEM[(long unsigned int *)mm_30(D) + 168B] = _105;

  <bb 50>:

  <bb 51>:
  # tmp_107 = PHI <tmp_8(50), tmp_119(54)>
  # nr_accounted_115 = PHI <0(50), nr_accounted_120(54)>
  _108 = MEM[(struct vm_area_struct *)tmp_107];
  _109 = MEM[(struct vm_area_struct *)tmp_107 + 8B];
  _110 = _109 - _108;
  _111 = _110 >> 12;
  nrpages_112 = (long int) _111;
  _113 = tmp_107->vm_flags;
  _114 = _113 & 1048576;
  if (_114 != 0)
    goto <bb 52>;
  else
    goto <bb 53>;

  <bb 52>:
  nr_accounted_116 = _111 + nr_accounted_115;

  <bb 53>:
  # nr_accounted_120 = PHI <nr_accounted_115(51), nr_accounted_116(52)>
  _117 = -nrpages_112;
  _118 = tmp_107->vm_file;
  vm_stat_account (mm_30(D), _113, _118, _117);
  tmp_119 = remove_vma (tmp_107);
  if (tmp_119 != 0B)
    goto <bb 54>;
  else
    goto <bb 55>;

  <bb 54>:
  goto <bb 51>;

  <bb 55>:
  # nr_accounted_173 = PHI <nr_accounted_120(53)>
  nr_accounted.107_121 = (long int) nr_accounted_173;
  _122 = -nr_accounted.107_121;
  vm_committed_as_batch.6_123 = vm_committed_as_batch;
  __percpu_counter_add (&vm_committed_as, _122, vm_committed_as_batch.6_123);

  <bb 56>:
  # _7 = PHI <-22(6), 0(55), 0(13), error_45(21), -12(16), error_40(17), -22(2), -22(11), -22(10), 0(12)>
  return _7;

  <bb 57>:
  *insertion_point_88 = 0B;
  if (prev_1 != 0B)
    goto <bb 44>;
  else
    goto <bb 45>;

  <bb 58>:
  # tmp_174 = PHI <tmp_86(38)>
  *insertion_point_88 = tmp_174;
  tmp_174->vm_prev = prev_1;
  rb_89 = &tmp_174->vm_rb;
  goto <bb 41>;

}



;; Function vm_munmap (vm_munmap, funcdef_no=3045, decl_uid=25200, cgraph_uid=3047)

vm_munmap (long unsigned int start, size_t len)
{
  struct task_struct * pfo_ret__;
  struct mm_struct * mm;
  int ret;
  struct rw_semaphore * _3;

  <bb 2>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___10 : "p" &current_task);
  mm_2 = pfo_ret___10->mm;
  _3 = &mm_2->mmap_sem;
  down_write (_3);
  ret_8 = do_munmap (mm_2, start_5(D), len_6(D));
  up_write (_3);
  return ret_8;

}



;; Function do_brk (do_brk, funcdef_no=3051, decl_uid=39767, cgraph_uid=3055)

do_brk (long unsigned int addr, long unsigned int len)
{
  struct task_struct * pfo_ret__;
  long unsigned int lock_limit;
  long unsigned int locked;
  int vm_committed_as_batch.6;
  long unsigned int cur;
  long unsigned int lim;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  int error;
  long unsigned int pgoff;
  struct rb_node * rb_parent;
  struct rb_node * * rb_link;
  long unsigned int flags;
  struct vm_area_struct * prev;
  struct vm_area_struct * vma;
  struct mm_struct * mm;
  struct kmem_cache * vm_area_cachep.12;
  struct vm_userfaultfd_ctx D.40498;
  int sysctl_max_map_count.10;
  long unsigned int iftmp.9;
  long unsigned int _2;
  long unsigned int _13;
  unsigned int _15;
  unsigned int _16;
  long unsigned int _17;
  long unsigned int _20;
  long unsigned int _22;
  long unsigned int _23;
  long unsigned int pretmp_27;
  int _31;
  long unsigned int _32;
  int _34;
  long int _36;
  int _38;
  struct list_head * _44;
  long unsigned int _55;
  long unsigned int _57;
  long unsigned int _59;
  long unsigned int _60;
  long unsigned int _61;
  long unsigned int _71;
  long unsigned int _72;
  struct signal_struct * _83;
  long long unsigned int _84;
  long unsigned int _86;
  int _88;
  long int _90;
  long unsigned int _92;
  long unsigned int _93;
  long unsigned int _108;
  long unsigned int _110;
  struct signal_struct * _113;
  long long unsigned int _114;
  _Bool _118;

  <bb 2>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___67 : "p" &current_task);
  mm_9 = pfo_ret___67->mm;
  _13 = len_12(D) + 4095;
  len_14 = _13 & 18446744073709547520;
  if (len_14 == 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  goto <bb 29>;

  <bb 4>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___68 : "p" &current_task);
  _15 = pfo_ret___68->personality;
  _16 = _15 & 4194304;
  if (_16 != 0)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:

  <bb 6>:
  # iftmp.9_3 = PHI <1048695(5), 1048691(4)>
  _17 = mm_9->def_flags;
  _20 = get_unmapped_area (0B, addr_10(D), len_14, 0, 16);
  error_21 = (int) _20;
  _88 = error_21 & 4095;
  if (_88 != 0)
    goto <bb 7>;
  else
    goto <bb 8>;

  <bb 7>:
  _22 = (long unsigned int) error_21;
  goto <bb 29>;

  <bb 8>:
  _23 = mm_9->def_flags;
  _108 = _23 & 8192;
  if (_108 != 0)
    goto <bb 10>;
  else
    goto <bb 9>;

  <bb 9>:
  pretmp_27 = len_14 + addr_10(D);
  rb_link_117 = &mm_9->mm_rb.rb_node;
  goto <bb 12>;

  <bb 10>:
  locked_109 = len_14 >> 12;
  _110 = MEM[(long unsigned int *)mm_9 + 184B];
  locked_111 = locked_109 + _110;
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___112 : "p" &current_task);
  _113 = MEM[(const struct task_struct *)pfo_ret___112].signal;
  _114 ={v} MEM[(volatile __u64 *)_113].rlim[8].rlim_cur;
  lock_limit_115 = _114 >> 12;
  if (locked_111 > lock_limit_115)
    goto <bb 11>;
  else
    goto <bb 9>;

  <bb 11>:
  _118 = capable (14);
  if (_118 != 0)
    goto <bb 9>;
  else
    goto <bb 29>;

  <bb 12>:
  goto <bb 18>;

  <bb 13>:
  _71 = MEM[(struct vm_area_struct *)rb_parent_70 + -32B].vm_end;
  if (addr_10(D) < _71)
    goto <bb 14>;
  else
    goto <bb 16>;

  <bb 14>:
  _72 = MEM[(struct vm_area_struct *)rb_parent_70 + -32B].vm_start;
  if (pretmp_27 > _72)
    goto <bb 30>;
  else
    goto <bb 15>;

  <bb 15>:
  rb_link_73 = &rb_parent_70->rb_left;
  goto <bb 17>;

  <bb 16>:
  rb_link_74 = &rb_parent_70->rb_right;

  <bb 17>:
  # rb_link_63 = PHI <rb_link_74(16), rb_link_73(15)>
  # rb_parent_65 = PHI <rb_parent_70(16), rb_parent_76(15)>

  <bb 18>:
  # rb_link_75 = PHI <rb_link_63(17), rb_link_117(12)>
  # rb_parent_77 = PHI <rb_parent_70(17), 0B(12)>
  # rb_parent_76 = PHI <rb_parent_65(17), 0B(12)>
  rb_parent_70 = *rb_link_75;
  if (rb_parent_70 != 0B)
    goto <bb 13>;
  else
    goto <bb 19>;

  <bb 19>:
  # rb_link_24 = PHI <rb_link_75(18)>
  # rb_parent_79 = PHI <rb_parent_76(18)>
  # rb_parent_122 = PHI <rb_parent_77(18)>
  if (rb_parent_79 != 0B)
    goto <bb 20>;
  else
    goto <bb 32>;

  <bb 20>:
  prev_107 = &MEM[(void *)rb_parent_79 + -32B];
  goto <bb 32>;

  <bb 21>:
  _36 = (long int) _32;
  _38 = security_vm_enough_memory_mm (mm_9, _36);
  if (_38 != 0)
    goto <bb 22>;
  else
    goto <bb 23>;

  <bb 22>:
  goto <bb 29>;

  <bb 23>:
  pgoff_11 = addr_10(D) >> 12;
  flags_18 = iftmp.9_3 | _17;
  vma_40 = vma_merge (mm_9, prev_137, addr_10(D), pretmp_27, flags_18, 0B, 0B, pgoff_11, 0B, D.40498);
  if (vma_40 != 0B)
    goto <bb 27> (out);
  else
    goto <bb 24>;

  <bb 24>:
  vm_area_cachep.12_41 = vm_area_cachep;
  vma_89 = kmem_cache_alloc (vm_area_cachep.12_41, 32976);
  if (vma_89 == 0B)
    goto <bb 25>;
  else
    goto <bb 26>;

  <bb 25>:
  _90 = -_36;
  vm_committed_as_batch.6_91 = vm_committed_as_batch;
  __percpu_counter_add (&vm_committed_as, _90, vm_committed_as_batch.6_91);
  goto <bb 29>;

  <bb 26>:
  _44 = &vma_89->anon_vma_chain;
  MEM[(struct list_head *)vma_89 + 120B].next = _44;
  MEM[(struct list_head *)vma_89 + 120B].prev = _44;
  vma_89->vm_mm = mm_9;
  vma_89->vm_start = addr_10(D);
  vma_89->vm_end = pretmp_27;
  vma_89->vm_pgoff = pgoff_11;
  vma_89->vm_flags = flags_18;
  _92 = flags_18 & 15;
  _93 = protection_map[_92].pgprot;
  MEM[(struct vm_area_struct *)vma_89 + 72B] = _93;
  vma_link (mm_9, vma_89, prev_137, rb_link_24, rb_parent_122);

  # vma_1 = PHI <vma_40(23), vma_89(26)>
out:
  perf_event_mmap (vma_1);
  _55 = mm_9->total_vm;
  _57 = _32 + _55;
  mm_9->total_vm = _57;
  _59 = flags_18 & 8192;
  if (_59 != 0)
    goto <bb 28>;
  else
    goto <bb 3>;

  <bb 28>:
  _60 = mm_9->locked_vm;
  _61 = _32 + _60;
  mm_9->locked_vm = _61;

  <bb 29>:
  # _2 = PHI <addr_10(D)(3), _22(7), 18446744073709551605(11), addr_10(D)(28), 18446744073709551604(25), 18446744073709551604(22)>
  return _2;

  <bb 30>:
  _31 = do_munmap (mm_9, addr_10(D), len_14);
  if (_31 != 0)
    goto <bb 22>;
  else
    goto <bb 31>;

  <bb 31>:
  goto <bb 12>;

  <bb 32>:
  # prev_137 = PHI <0B(19), prev_107(20)>
  _32 = len_14 >> 12;
  cur_81 = mm_9->total_vm;
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___82 : "p" &current_task);
  _83 = MEM[(const struct task_struct *)pfo_ret___82].signal;
  _84 ={v} MEM[(volatile __u64 *)_83].rlim[9].rlim_cur;
  lim_85 = _84 >> 12;
  _86 = _32 + cur_81;
  if (lim_85 < _86)
    goto <bb 22>;
  else
    goto <bb 33>;

  <bb 33>:
  _34 = mm_9->map_count;
  sysctl_max_map_count.10_35 = sysctl_max_map_count;
  if (_34 > sysctl_max_map_count.10_35)
    goto <bb 22>;
  else
    goto <bb 21>;

}



;; Function vm_brk (vm_brk, funcdef_no=3052, decl_uid=25197, cgraph_uid=3056)

vm_brk (long unsigned int addr, long unsigned int len)
{
  struct task_struct * pfo_ret__;
  long unsigned int ret;
  struct mm_struct * mm;
  struct rw_semaphore * _4;
  long unsigned int _10;
  long unsigned int _11;

  <bb 2>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___14 : "p" &current_task);
  mm_3 = pfo_ret___14->mm;
  _4 = &mm_3->mmap_sem;
  down_write (_4);
  ret_9 = do_brk (addr_6(D), len_7(D));
  _10 = mm_3->def_flags;
  _11 = _10 & 8192;
  up_write (_4);
  if (_11 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  __mm_populate (addr_6(D), len_7(D), 1);

  <bb 4>:
  return ret_9;

}



;; Function SyS_brk (SyS_brk, funcdef_no=2992, decl_uid=39773, cgraph_uid=2993)

SyS_brk (long int brk)
{
  long unsigned int retval;
  long unsigned int newbrk;
  long unsigned int oldbrk;
  struct mm_struct * mm;
  long unsigned int min_brk;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct vm_area_struct * vma;
  long unsigned int brk.7;
  struct rw_semaphore * _8;
  long unsigned int _10;
  long unsigned int _11;
  struct signal_struct * _13;
  long long unsigned int _14;
  long unsigned int _16;
  long unsigned int _17;
  long unsigned int _19;
  long unsigned int _21;
  long unsigned int _22;
  long unsigned int _24;
  int _25;
  long unsigned int _26;
  long unsigned int _28;
  long unsigned int _30;
  long unsigned int _31;
  long unsigned int _32;
  long unsigned int _33;
  long unsigned int _36;
  long int _39;
  long int _40;
  long unsigned int _41;

  <bb 2>:
  brk.7_2 = (long unsigned int) brk_1(D);
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___6 : "p" &current_task);
  mm_7 = pfo_ret___6->mm;
  _8 = &mm_7->mmap_sem;
  down_write (_8);
  min_brk_9 = mm_7->start_brk;
  if (brk.7_2 < min_brk_9)
    goto <bb 12>;
  else
    goto <bb 3>;

  <bb 3>:
  _10 = mm_7->start_data;
  _11 = mm_7->end_data;
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___12 : "p" &current_task);
  _13 = MEM[(const struct task_struct *)pfo_ret___12].signal;
  _14 ={v} MEM[(volatile __u64 *)_13].rlim[2].rlim_cur;
  if (_14 != 18446744073709551615)
    goto <bb 4>;
  else
    goto <bb 14>;

  <bb 4>:
  _41 = min_brk_9 + _10;
  _16 = _11 - _41;
  _17 = _16 + brk.7_2;
  if (_14 < _17)
    goto <bb 12>;
  else
    goto <bb 14>;

  <bb 5>:
  if (brk.7_2 <= _21)
    goto <bb 6>;
  else
    goto <bb 7>;

  <bb 6>:
  _24 = oldbrk_23 - newbrk_20;
  _25 = do_munmap (mm_7, newbrk_20, _24);
  if (_25 == 0)
    goto <bb 9>;
  else
    goto <bb 12>;

  <bb 7>:
  _26 = newbrk_20 + 4096;
  vma_27 = find_vma (mm_7, oldbrk_23);
  if (vma_27 != 0B)
    goto <bb 8>;
  else
    goto <bb 15>;

  <bb 8>:
  _28 = vma_27->vm_start;
  if (_26 <= _28)
    goto <bb 15>;
  else
    goto <bb 12>;

  <bb 9>:
  mm_7->brk = brk.7_2;
  if (newbrk_20 > oldbrk_23)
    goto <bb 10>;
  else
    goto <bb 18>;

  <bb 10>:
  _32 = mm_7->def_flags;
  _33 = _32 & 8192;
  if (_33 != 0)
    goto <bb 17>;
  else
    goto <bb 18>;

  <bb 11>:
  goto <bb 13>;

  <bb 12>:
  retval_38 = mm_7->brk;
  up_write (_8);
  _39 = (long int) retval_38;

  <bb 13>:
  # _40 = PHI <brk_1(D)(11), _39(12)>
  return _40;

  <bb 14>:
  _19 = brk.7_2 + 4095;
  newbrk_20 = _19 & 18446744073709547520;
  _21 = mm_7->brk;
  _22 = _21 + 4095;
  oldbrk_23 = _22 & 18446744073709547520;
  if (newbrk_20 == oldbrk_23)
    goto <bb 16>;
  else
    goto <bb 5>;

  <bb 15>:
  _30 = newbrk_20 - oldbrk_23;
  _31 = do_brk (oldbrk_23, _30);
  if (oldbrk_23 != _31)
    goto <bb 12>;
  else
    goto <bb 9>;

  <bb 16>:
  mm_7->brk = brk.7_2;
  goto <bb 18>;

  <bb 17>:
  up_write (_8);
  _36 = newbrk_20 - oldbrk_23;
  __mm_populate (oldbrk_23, _36, 1);
  goto <bb 11>;

  <bb 18>:
  up_write (_8);
  goto <bb 11>;

}



;; Function SyS_munmap (SyS_munmap, funcdef_no=3046, decl_uid=40409, cgraph_uid=3049)

SyS_munmap (long int addr, long int len)
{
  long unsigned int addr.110;
  long unsigned int len.109;
  int _7;
  long int _8;

  <bb 2>:
  len.109_2 = (long unsigned int) len_1(D);
  addr.110_4 = (long unsigned int) addr_3(D);
  profile_munmap (addr.110_4);
  _7 = vm_munmap (addr.110_4, len.109_2);
  _8 = (long int) _7;
  return _8;

}



;; Function exit_mmap (exit_mmap, funcdef_no=3053, decl_uid=25121, cgraph_uid=3057)

exit_mmap (struct mm_struct * mm)
{
  int vm_committed_as_batch.6;
  long unsigned int nr_accounted;
  struct vm_area_struct * vma;
  struct mmu_gather tlb;
  long int nr_accounted.118;
  long unsigned int _12;
  long unsigned int _14;
  long unsigned int _15;
  long unsigned int _24;
  long unsigned int _25;
  long unsigned int _26;
  long unsigned int _27;
  long unsigned int _35;
  long unsigned int _36;
  long unsigned int _37;
  long unsigned int _38;
  long int _39;

  <bb 2>:
  _12 = mm_11(D)->locked_vm;
  if (_12 != 0)
    goto <bb 4>;
  else
    goto <bb 3>;

  <bb 3>:
  vma_18 = mm_11(D)->mmap;
  if (vma_18 == 0B)
    goto <bb 16>;
  else
    goto <bb 10>;

  <bb 4>:
  vma_13 = mm_11(D)->mmap;
  if (vma_13 != 0B)
    goto <bb 5>;
  else
    goto <bb 16>;

  <bb 5>:

  <bb 6>:
  # vma_46 = PHI <vma_17(9), vma_13(5)>
  _14 = vma_46->vm_flags;
  _15 = _14 & 8192;
  if (_15 != 0)
    goto <bb 7>;
  else
    goto <bb 8>;

  <bb 7>:
  _35 = vma_46->vm_end;
  _36 = vma_46->vm_start;
  munlock_vma_pages_range (vma_46, _36, _35);

  <bb 8>:
  vma_17 = vma_46->vm_next;
  if (vma_17 != 0B)
    goto <bb 9>;
  else
    goto <bb 3>;

  <bb 9>:
  goto <bb 6>;

  <bb 10>:
  lru_add_drain ();
  tlb_gather_mmu (&tlb, mm_11(D), 0, 18446744073709551615);
  unmap_vmas (&tlb, vma_18, 0, 18446744073709551615);
  free_pgtables (&tlb, vma_18, 0, 0);
  tlb_finish_mmu (&tlb, 0, 18446744073709551615);

  <bb 11>:
  # vma_47 = PHI <vma_30(14), vma_18(10)>
  # nr_accounted_48 = PHI <nr_accounted_3(14), 0(10)>
  _24 = vma_47->vm_flags;
  _25 = _24 & 1048576;
  if (_25 != 0)
    goto <bb 12>;
  else
    goto <bb 13>;

  <bb 12>:
  _26 = MEM[(struct vm_area_struct *)vma_47];
  _27 = MEM[(struct vm_area_struct *)vma_47 + 8B];
  _37 = _27 - _26;
  _38 = _37 >> 12;
  nr_accounted_28 = _38 + nr_accounted_48;

  <bb 13>:
  # nr_accounted_3 = PHI <nr_accounted_48(11), nr_accounted_28(12)>
  vma_30 = remove_vma (vma_47);
  if (vma_30 != 0B)
    goto <bb 14>;
  else
    goto <bb 15>;

  <bb 14>:
  goto <bb 11>;

  <bb 15>:
  # nr_accounted_8 = PHI <nr_accounted_3(13)>
  nr_accounted.118_31 = (long int) nr_accounted_8;
  _39 = -nr_accounted.118_31;
  vm_committed_as_batch.6_40 = vm_committed_as_batch;
  __percpu_counter_add (&vm_committed_as, _39, vm_committed_as_batch.6_40);
  tlb ={v} {CLOBBER};
  goto <bb 17>;

  <bb 16>:
  tlb ={v} {CLOBBER};

  <bb 17>:
  return;

}



;; Function insert_vm_struct (insert_vm_struct, funcdef_no=3054, decl_uid=25106, cgraph_uid=3058)

insert_vm_struct (struct mm_struct * mm, struct vm_area_struct * vma)
{
  struct rb_node * rb_parent;
  struct rb_node * * rb_link;
  struct vm_area_struct * prev;
  int _1;
  long unsigned int _7;
  long unsigned int _8;
  long unsigned int _11;
  long unsigned int _12;
  long int _13;
  int _15;
  const struct vm_operations_struct * _16;
  struct anon_vma * _17;
  long unsigned int _21;
  long unsigned int _22;
  long unsigned int _31;
  long unsigned int _32;
  long unsigned int _41;
  long unsigned int _42;

  <bb 2>:
  _7 = vma_6(D)->vm_end;
  _8 = vma_6(D)->vm_start;
  rb_link_29 = &mm_9(D)->mm_rb.rb_node;
  goto <bb 9>;

  <bb 3>:
  _31 = MEM[(struct vm_area_struct *)rb_parent_30 + -32B].vm_end;
  if (_8 < _31)
    goto <bb 4>;
  else
    goto <bb 7>;

  <bb 4>:
  _32 = MEM[(struct vm_area_struct *)rb_parent_30 + -32B].vm_start;
  if (_7 > _32)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  goto <bb 18>;

  <bb 6>:
  rb_link_33 = &rb_parent_30->rb_left;
  goto <bb 8>;

  <bb 7>:
  rb_link_34 = &rb_parent_30->rb_right;

  <bb 8>:
  # rb_link_24 = PHI <rb_link_34(7), rb_link_33(6)>
  # rb_parent_28 = PHI <rb_parent_30(7), rb_parent_36(6)>

  <bb 9>:
  # rb_link_35 = PHI <rb_link_24(8), rb_link_29(2)>
  # rb_parent_37 = PHI <rb_parent_30(8), 0B(2)>
  # rb_parent_36 = PHI <rb_parent_28(8), 0B(2)>
  rb_parent_30 = *rb_link_35;
  if (rb_parent_30 != 0B)
    goto <bb 3>;
  else
    goto <bb 10>;

  <bb 10>:
  # rb_link_48 = PHI <rb_link_35(9)>
  # rb_parent_19 = PHI <rb_parent_36(9)>
  # rb_parent_18 = PHI <rb_parent_37(9)>
  if (rb_parent_19 != 0B)
    goto <bb 11>;
  else
    goto <bb 19>;

  <bb 11>:
  prev_47 = &MEM[(void *)rb_parent_19 + -32B];
  goto <bb 19>;

  <bb 12>:
  _41 = _7 - _8;
  _42 = _41 >> 12;
  _13 = (long int) _42;
  _15 = security_vm_enough_memory_mm (mm_9(D), _13);
  if (_15 != 0)
    goto <bb 5>;
  else
    goto <bb 13>;

  <bb 13>:
  _16 = MEM[(struct vm_area_struct *)vma_6(D) + 144B];
  if (_16 == 0B)
    goto <bb 14>;
  else
    goto <bb 17>;

  <bb 14>:
  _17 = vma_6(D)->anon_vma;
  if (_17 != 0B)
    goto <bb 15>;
  else
    goto <bb 16>;

  <bb 15>:
  __asm__ __volatile__("1:	ud2
.pushsection __bug_table,"a"
2:	.long 1b - 2b, %c0 - 2b
	.word %c1, 0
	.org 2b+%c2
.popsection" :  : "i" "mm/mmap.c", "i" 2929, "i" 12);
  __builtin_unreachable ();

  <bb 16>:
  _21 = vma_6(D)->vm_start;
  _22 = _21 >> 12;
  vma_6(D)->vm_pgoff = _22;

  <bb 17>:
  vma_link (mm_9(D), vma_6(D), prev_20, rb_link_48, rb_parent_18);

  <bb 18>:
  # _1 = PHI <-12(5), 0(17)>
  return _1;

  <bb 19>:
  # prev_20 = PHI <0B(10), prev_47(11)>
  _11 = vma_6(D)->vm_flags;
  _12 = _11 & 1048576;
  if (_12 != 0)
    goto <bb 12>;
  else
    goto <bb 13>;

}



;; Function __install_special_mapping (__install_special_mapping, funcdef_no=3060, decl_uid=40583, cgraph_uid=3064)

__install_special_mapping (struct mm_struct * mm, long unsigned int addr, long unsigned int len, long unsigned int vm_flags, const struct vm_operations_struct * ops, void * priv)
{
  int ret;
  struct kmem_cache * vm_area_cachep.126;
  struct vm_area_struct * _1;
  struct list_head * _9;
  long unsigned int _16;
  long unsigned int _18;
  long unsigned int _20;
  long unsigned int _21;
  long unsigned int _30;
  long unsigned int _31;
  long unsigned int _32;
  long int _37;
  void * _38;
  long unsigned int _39;
  long unsigned int _40;
  void * _41;

  <bb 2>:
  vm_area_cachep.126_4 = vm_area_cachep;
  _38 = kmem_cache_alloc (vm_area_cachep.126_4, 32976);
  if (_38 == 0B)
    goto <bb 6>;
  else
    goto <bb 3>;

  <bb 3>:
  _9 = &MEM[(struct vm_area_struct *)_38].anon_vma_chain;
  MEM[(struct list_head *)_38 + 120B].next = _9;
  MEM[(struct list_head *)_38 + 120B].prev = _9;
  MEM[(struct vm_area_struct *)_38].vm_mm = mm_11(D);
  MEM[(struct vm_area_struct *)_38].vm_start = addr_13(D);
  _16 = addr_13(D) + len_15(D);
  MEM[(struct vm_area_struct *)_38].vm_end = _16;
  _18 = mm_11(D)->def_flags;
  _20 = vm_flags_19(D) | _18;
  _21 = _20 | 262144;
  MEM[(struct vm_area_struct *)_38].vm_flags = _21;
  _39 = _20 & 15;
  _40 = protection_map[_39].pgprot;
  MEM[(struct vm_area_struct *)_38 + 72B] = _40;
  MEM[(struct vm_area_struct *)_38].vm_ops = ops_24(D);
  MEM[(struct vm_area_struct *)_38].vm_private_data = priv_26(D);
  ret_29 = insert_vm_struct (mm_11(D), _38);
  if (ret_29 != 0)
    goto <bb 5> (out);
  else
    goto <bb 4>;

  <bb 4>:
  _30 = mm_11(D)->total_vm;
  _31 = len_15(D) >> 12;
  _32 = _31 + _30;
  mm_11(D)->total_vm = _32;
  perf_event_mmap (_38);
  goto <bb 6>;

out:
  vm_area_cachep.126_35 = vm_area_cachep;
  kmem_cache_free (vm_area_cachep.126_35, _38);
  _37 = (long int) ret_29;
  _41 = (void *) _37;

  <bb 6>:
  # _1 = PHI <-12B(2), _38(4), _41(5)>
  return _1;

}



;; Function copy_vma (copy_vma, funcdef_no=3055, decl_uid=25119, cgraph_uid=3059)

copy_vma (struct vm_area_struct * * vmap, long unsigned int addr, long unsigned int len, long unsigned int pgoff, bool * need_rmap_locks)
{
  struct rb_node * rb_parent;
  struct rb_node * * rb_link;
  struct vm_area_struct * prev;
  struct vm_area_struct * new_vma;
  struct mm_struct * mm;
  long unsigned int vma_start;
  struct kmem_cache * vm_area_cachep.123;
  struct vm_area_struct * _4;
  const struct vm_operations_struct * _17;
  struct anon_vma * _21;
  long unsigned int _28;
  struct mempolicy * _30;
  struct file * _31;
  struct anon_vma * _32;
  long unsigned int _33;
  long unsigned int _36;
  long unsigned int _40;
  long unsigned int _45;
  long unsigned int _46;
  _Bool _47;
  int _58;
  struct list_head * _59;
  int _62;
  struct file * _63;
  const struct vm_operations_struct * _65;
  void (*<T38f8>) (struct vm_area_struct *) _66;
  struct mempolicy * _70;
  long unsigned int _80;
  long unsigned int _81;
  struct atomic_long_t * _90;

  <bb 2>:
  new_vma_14 = *vmap_13(D);
  vma_start_15 = new_vma_14->vm_start;
  mm_16 = new_vma_14->vm_mm;
  _17 = MEM[(struct vm_area_struct *)new_vma_14 + 144B];
  if (_17 == 0B)
    goto <bb 3>;
  else
    goto <bb 5>;

  <bb 3>:
  _21 = new_vma_14->anon_vma;
  if (_21 == 0B)
    goto <bb 4>;
  else
    goto <bb 5>;

  <bb 4>:
  pgoff_26 = addr_25(D) >> 12;

  <bb 5>:
  # pgoff_1 = PHI <pgoff_20(D)(3), pgoff_26(4), pgoff_20(D)(2)>
  _28 = addr_25(D) + len_27(D);
  rb_link_78 = &mm_16->mm_rb.rb_node;
  goto <bb 12>;

  <bb 6>:
  _80 = MEM[(struct vm_area_struct *)rb_parent_79 + -32B].vm_end;
  if (addr_25(D) < _80)
    goto <bb 7>;
  else
    goto <bb 10>;

  <bb 7>:
  _81 = MEM[(struct vm_area_struct *)rb_parent_79 + -32B].vm_start;
  if (_28 > _81)
    goto <bb 8>;
  else
    goto <bb 9>;

  <bb 8>:
  goto <bb 32>;

  <bb 9>:
  rb_link_82 = &rb_parent_79->rb_left;
  goto <bb 11>;

  <bb 10>:
  rb_link_83 = &rb_parent_79->rb_right;

  <bb 11>:
  # rb_link_10 = PHI <rb_link_83(10), rb_link_82(9)>
  # rb_parent_76 = PHI <rb_parent_79(10), rb_parent_85(9)>

  <bb 12>:
  # rb_link_84 = PHI <rb_link_10(11), rb_link_78(5)>
  # rb_parent_86 = PHI <rb_parent_79(11), 0B(5)>
  # rb_parent_85 = PHI <rb_parent_76(11), 0B(5)>
  rb_parent_79 = *rb_link_84;
  if (rb_parent_79 != 0B)
    goto <bb 6>;
  else
    goto <bb 13>;

  <bb 13>:
  # rb_link_24 = PHI <rb_link_84(12)>
  # rb_parent_88 = PHI <rb_parent_85(12)>
  # rb_parent_3 = PHI <rb_parent_86(12)>
  if (rb_parent_88 != 0B)
    goto <bb 14>;
  else
    goto <bb 33>;

  <bb 14>:
  prev_99 = &MEM[(void *)rb_parent_88 + -32B];
  goto <bb 33>;

  <bb 15>:
  _36 = new_vma_35->vm_start;
  if (vma_start_15 >= _36)
    goto <bb 16>;
  else
    goto <bb 18>;

  <bb 16>:
  _40 = new_vma_35->vm_end;
  if (vma_start_15 < _40)
    goto <bb 17>;
  else
    goto <bb 18>;

  <bb 17>:
  *vmap_13(D) = new_vma_35;

  <bb 18>:
  # new_vma_2 = PHI <new_vma_14(15), new_vma_14(16), new_vma_35(17)>
  _45 = new_vma_35->vm_pgoff;
  _46 = new_vma_2->vm_pgoff;
  _47 = _45 <= _46;
  *need_rmap_locks_48(D) = _47;
  goto <bb 32>;

  <bb 19>:
  vm_area_cachep.123_50 = vm_area_cachep;
  new_vma_52 = kmem_cache_alloc (vm_area_cachep.123_50, 208);
  if (new_vma_52 == 0B)
    goto <bb 8>;
  else
    goto <bb 20>;

  <bb 20>:
  *new_vma_52 = *new_vma_14;
  new_vma_52->vm_start = addr_25(D);
  new_vma_52->vm_end = _28;
  new_vma_52->vm_pgoff = pgoff_1;
  _58 = vma_dup_policy (new_vma_14, new_vma_52);
  if (_58 != 0)
    goto <bb 21>;
  else
    goto <bb 22>;

  <bb 21>:
  goto <bb 31> (out_free_vma);

  <bb 22>:
  _59 = &new_vma_52->anon_vma_chain;
  MEM[(struct list_head *)new_vma_52 + 120B].next = _59;
  MEM[(struct list_head *)new_vma_52 + 120B].prev = _59;
  _62 = anon_vma_clone (new_vma_52, new_vma_14);
  if (_62 != 0)
    goto <bb 29> (out_free_mempol);
  else
    goto <bb 23>;

  <bb 23>:
  _63 = new_vma_52->vm_file;
  if (_63 != 0B)
    goto <bb 24>;
  else
    goto <bb 25>;

  <bb 24>:
  _90 = &_63->f_count;
  __asm__ __volatile__(".pushsection .smp_locks,"a"
.balign 4
.long 671f - .
.popsection
671:
	lock; incq %0" : "=m" MEM[(struct atomic64_t *)_90].counter : "m" MEM[(struct atomic64_t *)_90].counter);

  <bb 25>:
  _65 = new_vma_52->vm_ops;
  if (_65 != 0B)
    goto <bb 26>;
  else
    goto <bb 28>;

  <bb 26>:
  _66 = _65->open;
  if (_66 != 0B)
    goto <bb 27>;
  else
    goto <bb 28>;

  <bb 27>:
  _66 (new_vma_52);

  <bb 28>:
  vma_link (mm_16, new_vma_52, prev_18, rb_link_24, rb_parent_3);
  *need_rmap_locks_48(D) = 0;
  goto <bb 32>;

out_free_mempol:
  _70 = new_vma_52->vm_policy;
  if (_70 != 0B)
    goto <bb 30>;
  else
    goto <bb 21>;

  <bb 30>:
  __mpol_put (_70);

out_free_vma:
  vm_area_cachep.123_72 = vm_area_cachep;
  kmem_cache_free (vm_area_cachep.123_72, new_vma_52);

  <bb 32>:
  # _4 = PHI <0B(8), new_vma_52(28), 0B(31), new_vma_35(18)>
  return _4;

  <bb 33>:
  # prev_18 = PHI <0B(13), prev_99(14)>
  _30 = new_vma_14->vm_policy;
  _31 = new_vma_14->vm_file;
  _32 = new_vma_14->anon_vma;
  _33 = new_vma_14->vm_flags;
  new_vma_35 = vma_merge (mm_16, prev_18, addr_25(D), _28, _33, _32, _31, pgoff_1, _30, new_vma_14->vm_userfaultfd_ctx);
  if (new_vma_35 != 0B)
    goto <bb 15>;
  else
    goto <bb 19>;

}



;; Function may_expand_vm (may_expand_vm, funcdef_no=3056, decl_uid=25140, cgraph_uid=3060)

may_expand_vm (struct mm_struct * mm, long unsigned int npages)
{
  struct task_struct * pfo_ret__;
  long unsigned int lim;
  long unsigned int cur;
  long unsigned int _8;
  struct signal_struct * _10;
  long long unsigned int _11;
  _Bool _12;
  int _13;

  <bb 2>:
  cur_4 = mm_3(D)->total_vm;
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___9 : "p" &current_task);
  _10 = MEM[(const struct task_struct *)pfo_ret___9].signal;
  _11 ={v} MEM[(volatile __u64 *)_10].rlim[9].rlim_cur;
  lim_6 = _11 >> 12;
  _8 = npages_7(D) + cur_4;
  _12 = lim_6 >= _8;
  _13 = (int) _12;
  return _13;

}



;; Function SyS_mmap_pgoff (SyS_mmap_pgoff, funcdef_no=3025, decl_uid=40099, cgraph_uid=3027)

SyS_mmap_pgoff (long int addr, long int len, long int prot, long int flags, long int fd, long int pgoff)
{
  struct task_struct * pfo_ret__;
  long unsigned int lock_limit;
  long unsigned int locked;
  void * hint.42;
  long unsigned int mmap_min_addr.43;
  struct task_struct * pfo_ret__;
  void * p;
  struct file * file;
  long unsigned int retval;
  struct user_struct * user;
  unsigned int default_hstate_idx.53;
  long unsigned int ptr.54;
  vm_flags_t vm_flags;
  long int charged.57;
  struct vm_userfaultfd_ctx D.45495;
  struct vm_area_struct * prev.58;
  struct kmem_cache * vm_area_cachep.59;
  _Bool __warned.60;
  struct rb_node * rb_parent.61;
  struct rb_node * * rb_link.62;
  struct mm_struct * mm;
  struct vm_area_struct * vma;
  struct vm_area_struct * prev;
  int error;
  struct rb_node * * rb_link;
  struct rb_node * rb_parent;
  long unsigned int charged;
  long unsigned int nr_pages;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct mm_struct * mm;
  int sysctl_overcommit_memory.41;
  int sysctl_max_map_count.40;
  struct task_struct * pfo_ret__;
  long unsigned int populate;
  struct mm_struct * mm;
  long unsigned int addr;
  long unsigned int len;
  long unsigned int prot;
  long unsigned int flags;
  long unsigned int pgoff;
  long unsigned int flags.48;
  long unsigned int _16;
  int _17;
  int _18;
  unsigned int _19;
  const struct file_operations * _21;
  int _22;
  struct inode * _24;
  struct super_block * _25;
  void * _26;
  struct hstate * _27;
  unsigned int _28;
  int _29;
  long unsigned int _30;
  long unsigned int _31;
  long unsigned int _32;
  long unsigned int _33;
  long unsigned int _35;
  const struct file_operations * _39;
  int _40;
  long unsigned int _45;
  long unsigned int _46;
  int _47;
  int _48;
  struct hstate * _50;
  long unsigned int _51;
  struct hstate * _52;
  struct hstate * _53;
  unsigned int _54;
  int _55;
  long unsigned int _56;
  long unsigned int _57;
  long unsigned int _58;
  long unsigned int _59;
  long int _66;
  int _71;
  struct rw_semaphore * _73;
  long unsigned int _77;
  unsigned int _79;
  unsigned int _80;
  struct path * _81;
  _Bool _82;
  long unsigned int _84;
  long int pretmp_85;
  long unsigned int _86;
  long unsigned int _89;
  int _90;
  long unsigned int _94;
  long unsigned int _98;
  long unsigned int _99;
  long unsigned int _100;
  long unsigned int _102;
  int _103;
  struct inode * _106;
  long int pretmp_107;
  long unsigned int _108;
  long unsigned int _109;
  unsigned int _110;
  unsigned int _111;
  unsigned int _112;
  unsigned int _113;
  unsigned int _114;
  unsigned int _115;
  int _116;
  unsigned int _118;
  unsigned int _119;
  vm_flags_t _120;
  unsigned int _122;
  unsigned int _123;
  struct path * _124;
  _Bool _125;
  long unsigned int _127;
  const struct file_operations * _129;
  int (*<T264d>) (struct file *, struct vm_area_struct *) _130;
  long unsigned int _132;
  long unsigned int _133;
  long unsigned int _134;
  long unsigned int _137;
  int _141;
  int _146;
  long unsigned int _147;
  long unsigned int _149;
  int _150;
  int _151;
  int _153;
  int _155;
  int _157;
  long unsigned int pretmp_164;
  struct list_head * _165;
  long unsigned int _166;
  long unsigned int _168;
  struct address_space * _169;
  struct file * _171;
  const struct file_operations * _172;
  int (*<T264d>) (struct file *, struct vm_area_struct *) _173;
  long unsigned int _175;
  long int pretmp_182;
  long unsigned int _185;
  long unsigned int _191;
  struct address_space * _192;
  long unsigned int _193;
  long int _196;
  long unsigned int _199;
  long unsigned int _200;
  long unsigned int _201;
  struct mm_struct * _204;
  struct vm_area_struct * _205;
  long unsigned int _206;
  long unsigned int _207;
  long unsigned int _208;
  long unsigned int _209;
  long unsigned int _210;
  long unsigned int _211;
  struct address_space * _213;
  long unsigned int _223;
  long unsigned int _224;
  long int _230;
  long int _232;
  int _244;
  long unsigned int _252;
  long unsigned int _255;
  long unsigned int _256;
  long unsigned int _257;
  long unsigned int _259;
  struct signal_struct * _262;
  long long unsigned int _263;
  long int prephitmp_265;
  _Bool _267;
  long unsigned int _272;
  long unsigned int _273;
  long unsigned int _275;
  long int pretmp_287;
  long int prephitmp_308;
  long int prephitmp_371;
  long int pretmp_385;
  long int prephitmp_458;

  <bb 2>:
  flags.48_6 = (long unsigned int) flags_5(D);
  prot_8 = (long unsigned int) prot_7(D);
  len_10 = (long unsigned int) len_9(D);
  _16 = flags.48_6 & 32;
  if (_16 == 0)
    goto <bb 3>;
  else
    goto <bb 11>;

  <bb 3>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___242 : "p" &current_task);
  p_243 = pfo_ret___242->audit_context;
  if (p_243 == 0B)
    goto <bb 5>;
  else
    goto <bb 4>;

  <bb 4>:
  _244 = MEM[(int *)p_243];
  if (_244 != 0)
    goto <bb 5>;
  else
    goto <bb 123>;

  <bb 5>:
  _19 = (unsigned int) fd_3(D);
  file_20 = fget (_19);
  if (file_20 == 0B)
    goto <bb 121> (out);
  else
    goto <bb 6>;

  <bb 6>:
  _21 = file_20->f_op;
  if (_21 == &hugetlbfs_file_operations)
    goto <bb 124>;
  else
    goto <bb 7>;

  <bb 7>:
  _22 = is_file_shm_hugepages (file_20);
  if (_22 != 0)
    goto <bb 124>;
  else
    goto <bb 8>;

  <bb 8>:
  # len_231 = PHI <len_10(7), len_34(124)>
  _35 = flags.48_6 & 262144;
  if (_35 != 0)
    goto <bb 9>;
  else
    goto <bb 20>;

  <bb 9>:
  _39 = file_20->f_op;
  if (_39 == &hugetlbfs_file_operations)
    goto <bb 125>;
  else
    goto <bb 10>;

  <bb 10>:
  _40 = is_file_shm_hugepages (file_20);
  if (_40 != 0)
    goto <bb 125>;
  else
    goto <bb 120>;

  <bb 11>:
  _45 = flags.48_6 & 262144;
  if (_45 != 0)
    goto <bb 12>;
  else
    goto <bb 20>;

  <bb 12>:
  user = 0B;
  _46 = flags.48_6 >> 26;
  _47 = (int) _46;
  _48 = _47 & 63;
  if (_48 == 0)
    goto <bb 13>;
  else
    goto <bb 14>;

  <bb 13>:
  default_hstate_idx.53_49 = default_hstate_idx;
  _50 = &hstates[default_hstate_idx.53_49];
  goto <bb 15>;

  <bb 14>:
  _51 = 1 << _48;
  _52 = size_to_hstate (_51);

  <bb 15>:
  # _53 = PHI <_50(13), _52(14)>
  if (_53 == 0B)
    goto <bb 19>;
  else
    goto <bb 16>;

  <bb 16>:
  _54 = MEM[(struct hstate *)_53 + 8B];
  _55 = (int) _54;
  _56 = 4096 << _55;
  _57 = len_10 + 18446744073709551615;
  _58 = _57 + _56;
  _59 = -_56;
  len_60 = _59 & _58;
  file_61 = hugetlb_file_setup ("anon_hugepage", len_60, 2097152, &user, 2, _48);
  ptr.54_62 = (long unsigned int) file_61;
  if (ptr.54_62 > 18446744073709547520)
    goto <bb 17>;
  else
    goto <bb 18>;

  <bb 17>:
  _66 = (long int) file_61;
  goto <bb 19>;

  <bb 18>:
  user ={v} {CLOBBER};
  goto <bb 20>;

  <bb 19>:
  # _232 = PHI <-22(15), _66(17)>
  user ={v} {CLOBBER};
  goto <bb 122>;

  <bb 20>:
  # len_76 = PHI <len_231(8), len_231(125), len_10(11), len_60(18)>
  # file_70 = PHI <file_20(8), file_20(125), 0B(11), file_61(18)>
  flags_67 = flags.48_6 & 18446744073709545471;
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___68 : "p" &current_task);
  mm_69 = pfo_ret___68->mm;
  _71 = security_mmap_file (file_70, prot_8, flags_67);
  retval_72 = (long unsigned int) _71;
  if (retval_72 == 0)
    goto <bb 21>;
  else
    goto <bb 118>;

  <bb 21>:
  _73 = &mm_69->mmap_sem;
  down_write (_73);
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___74 : "p" &current_task);
  mm_75 = pfo_ret___74->mm;
  if (len_76 == 0)
    goto <bb 129> (<L14>);
  else
    goto <bb 22>;

  <bb 22>:
  _77 = prot_8 & 1;
  if (_77 != 0)
    goto <bb 23>;
  else
    goto <bb 27>;

  <bb 23>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___78 : "p" &current_task);
  _79 = pfo_ret___78->personality;
  _80 = _79 & 4194304;
  if (_80 != 0)
    goto <bb 24>;
  else
    goto <bb 27>;

  <bb 24>:
  if (file_70 == 0B)
    goto <bb 25>;
  else
    goto <bb 26>;

  <bb 25>:
  prot_83 = prot_8 | 4;
  goto <bb 27>;

  <bb 26>:
  _81 = &file_70->f_path;
  _82 = path_noexec (_81);
  if (_82 != 0)
    goto <bb 27>;
  else
    goto <bb 25>;

  <bb 27>:
  # prot_95 = PHI <prot_8(22), prot_8(23), prot_8(26), prot_83(25)>
  addr_12 = (long unsigned int) addr_11(D);
  _84 = flags.48_6 & 16;
  if (_84 == 0)
    goto <bb 28>;
  else
    goto <bb 32>;

  <bb 28>:
  addr_249 = addr_12 & 18446744073709547520;
  hint.42_250 = (void *) addr_249;
  if (hint.42_250 != 0B)
    goto <bb 29>;
  else
    goto <bb 31>;

  <bb 29>:
  mmap_min_addr.43_251 = mmap_min_addr;
  if (addr_249 < mmap_min_addr.43_251)
    goto <bb 30>;
  else
    goto <bb 31>;

  <bb 30>:
  _252 = mmap_min_addr.43_251 + 4095;
  addr_253 = _252 & 18446744073709547520;

  <bb 31>:
  # addr_254 = PHI <addr_249(28), addr_249(29), addr_253(30)>

  <bb 32>:
  # addr_92 = PHI <addr_12(27), addr_254(31)>
  _86 = len_76 + 4095;
  populate_87 = _86 & 18446744073709547520;
  if (populate_87 == 0)
    goto <bb 129> (<L14>);
  else
    goto <bb 33>;

  <bb 33>:
  pgoff_2 = (long unsigned int) pgoff_1(D);
  charged_88 = populate_87 >> 12;
  _89 = charged_88 + pgoff_2;
  if (pgoff_2 > _89)
    goto <bb 129> (<L14>);
  else
    goto <bb 34>;

  <bb 34>:
  _90 = mm_75->map_count;
  sysctl_max_map_count.40_91 = sysctl_max_map_count;
  if (_90 > sysctl_max_map_count.40_91)
    goto <bb 129> (<L14>);
  else
    goto <bb 35>;

  <bb 35>:
  retval_93 = get_unmapped_area (file_70, addr_92, populate_87, pgoff_2, flags_67);
  _94 = retval_93 & 4095;
  if (_94 != 0)
    goto <bb 36>;
  else
    goto <bb 37>;

  <bb 36>:
  pretmp_85 = (long int) retval_93;
  goto <bb 129> (<L14>);

  <bb 37>:
  _255 = prot_95 & 7;
  _256 = flags.48_6 & 8448;
  _99 = mm_75->def_flags;
  _98 = _256 | _99;
  _100 = _98 | _255;
  _102 = flags.48_6 & 8192;
  if (_102 != 0)
    goto <bb 39>;
  else
    goto <bb 38>;

  <bb 38>:
  _257 = _100 & 8192;
  if (_257 != 0)
    goto <bb 42>;
  else
    goto <bb 41>;

  <bb 39>:
  _103 = can_do_mlock ();
  if (_103 == 0)
    goto <bb 40>;
  else
    goto <bb 38>;

  <bb 40>:
  goto <bb 129> (<L14>);

  <bb 41>:
  vm_flags_101 = _100 | 112;
  if (file_70 != 0B)
    goto <bb 45>;
  else
    goto <bb 61>;

  <bb 42>:
  _259 = MEM[(long unsigned int *)mm_75 + 184B];
  locked_260 = charged_88 + _259;
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___261 : "p" &current_task);
  _262 = MEM[(const struct task_struct *)pfo_ret___261].signal;
  _263 ={v} MEM[(volatile __u64 *)_262].rlim[8].rlim_cur;
  lock_limit_264 = _263 >> 12;
  if (locked_260 > lock_limit_264)
    goto <bb 43>;
  else
    goto <bb 41>;

  <bb 43>:
  _267 = capable (14);
  if (_267 != 0)
    goto <bb 41>;
  else
    goto <bb 44>;

  <bb 44>:
  goto <bb 129> (<L14>);

  <bb 45>:
  _106 = MEM[(const struct file *)file_70 + 32B];
  _108 = flags.48_6 & 15;
  switch (_108) <default: <L14>, case 1: <L1>, case 2: <L2>>

<L1>:
  _109 = prot_95 & 2;
  if (_109 != 0)
    goto <bb 47>;
  else
    goto <bb 49>;

  <bb 47>:
  _110 = file_70->f_mode;
  _111 = _110 & 2;
  if (_111 == 0)
    goto <bb 48>;
  else
    goto <bb 49>;

  <bb 48>:
  goto <bb 129> (<L14>);

  <bb 49>:
  _112 = _106->i_flags;
  _113 = _112 & 4;
  if (_113 != 0)
    goto <bb 50>;
  else
    goto <bb 51>;

  <bb 50>:
  _114 = file_70->f_mode;
  _115 = _114 & 2;
  if (_115 != 0)
    goto <bb 48>;
  else
    goto <bb 51>;

  <bb 51>:
  _116 = locks_verify_locked (file_70);
  if (_116 != 0)
    goto <bb 44>;
  else
    goto <bb 52>;

  <bb 52>:
  vm_flags_117 = _100 | 248;
  _118 = file_70->f_mode;
  _119 = _118 & 2;
  if (_119 == 0)
    goto <bb 53>;
  else
    goto <bb 54> (<L2>);

  <bb 53>:
  _120 = _100 & 18446744073709551575;
  vm_flags_121 = _120 | 208;

  # vm_flags_126 = PHI <vm_flags_101(45), vm_flags_117(52), vm_flags_121(53)>
<L2>:
  _122 = file_70->f_mode;
  _123 = _122 & 1;
  if (_123 == 0)
    goto <bb 48>;
  else
    goto <bb 55>;

  <bb 55>:
  _124 = &file_70->f_path;
  _125 = path_noexec (_124);
  if (_125 != 0)
    goto <bb 56>;
  else
    goto <bb 58>;

  <bb 56>:
  _127 = vm_flags_126 & 4;
  if (_127 != 0)
    goto <bb 40>;
  else
    goto <bb 57>;

  <bb 57>:
  vm_flags_128 = vm_flags_126 & 18446744073709551551;

  <bb 58>:
  # vm_flags_131 = PHI <vm_flags_126(55), vm_flags_128(57)>
  _129 = file_70->f_op;
  _130 = _129->mmap;
  if (_130 == 0B)
    goto <bb 129> (<L14>);
  else
    goto <bb 59>;

  <bb 59>:
  _132 = vm_flags_131 & 256;
  if (_132 != 0)
    goto <bb 60>;
  else
    goto <bb 65>;

  <bb 60>:
  goto <bb 129> (<L14>);

  <bb 61>:
  _133 = flags.48_6 & 15;
  switch (_133) <default: <L14>, case 1: <L3>, case 2: <L4>>

<L3>:
  _134 = _100 & 256;
  if (_134 != 0)
    goto <bb 60>;
  else
    goto <bb 63>;

  <bb 63>:
  vm_flags_135 = _100 | 248;
  goto <bb 65>;

<L4>:
  pgoff_136 = retval_93 >> 12;

  <bb 65>:
  # vm_flags_139 = PHI <vm_flags_131(59), vm_flags_135(63), vm_flags_101(64)>
  # pgoff_161 = PHI <pgoff_2(59), 0(63), pgoff_136(64)>
  _137 = flags.48_6 & 16384;
  if (_137 != 0)
    goto <bb 66>;
  else
    goto <bb 71>;

  <bb 66>:
  sysctl_overcommit_memory.41_138 = sysctl_overcommit_memory;
  if (sysctl_overcommit_memory.41_138 != 2)
    goto <bb 67>;
  else
    goto <bb 68>;

  <bb 67>:
  vm_flags_140 = vm_flags_139 | 2097152;

  <bb 68>:
  # vm_flags_142 = PHI <vm_flags_139(66), vm_flags_140(67)>
  if (file_70 != 0B)
    goto <bb 69>;
  else
    goto <bb 71>;

  <bb 69>:
  _141 = is_file_hugepages (file_70);
  if (_141 != 0)
    goto <bb 70>;
  else
    goto <bb 71>;

  <bb 70>:
  vm_flags_143 = vm_flags_142 | 2097152;

  <bb 71>:
  # vm_flags_154 = PHI <vm_flags_139(65), vm_flags_142(68), vm_flags_142(69), vm_flags_143(70)>
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___144 : "p" &current_task);
  mm_145 = pfo_ret___144->mm;
  _146 = may_expand_vm (mm_145, charged_88);
  if (_146 == 0)
    goto <bb 72>;
  else
    goto <bb 75>;

  <bb 72>:
  _147 = retval_93 + populate_87;
  nr_pages_148 = count_vma_pages_range (mm_145, retval_93, _147);
  _149 = charged_88 - nr_pages_148;
  _150 = may_expand_vm (mm_145, _149);
  if (_150 == 0)
    goto <bb 127>;
  else
    goto <bb 75>;

  <bb 73>:
  _151 = do_munmap (mm_145, retval_93, populate_87);
  if (_151 != 0)
    goto <bb 127>;
  else
    goto <bb 74>;

  <bb 74>:
  goto <bb 76>;

  <bb 75>:
  pretmp_164 = retval_93 + populate_87;

  <bb 76>:
  _153 = find_vma_links (mm_145, retval_93, pretmp_164, &prev, &rb_link, &rb_parent);
  if (_153 != 0)
    goto <bb 73>;
  else
    goto <bb 77>;

  <bb 77>:
  _155 = accountable_mapping (file_70, vm_flags_154);
  if (_155 != 0)
    goto <bb 78>;
  else
    goto <bb 80>;

  <bb 78>:
  charged.57_156 = (long int) charged_88;
  _157 = security_vm_enough_memory_mm (mm_145, charged.57_156);
  if (_157 != 0)
    goto <bb 127>;
  else
    goto <bb 79>;

  <bb 79>:
  vm_flags_158 = vm_flags_154 | 1048576;

  <bb 80>:
  # vm_flags_160 = PHI <vm_flags_154(77), vm_flags_158(79)>
  # charged_233 = PHI <0(77), charged_88(79)>
  prev.58_159 = prev;
  vma_162 = vma_merge (mm_145, prev.58_159, retval_93, pretmp_164, vm_flags_160, 0B, file_70, pgoff_161, 0B, D.45495);
  if (vma_162 != 0B)
    goto <bb 98> (out);
  else
    goto <bb 81>;

  <bb 81>:
  vm_area_cachep.59_163 = vm_area_cachep;
  vma_271 = kmem_cache_alloc (vm_area_cachep.59_163, 32976);
  if (vma_271 == 0B)
    goto <bb 110> (unacct_error);
  else
    goto <bb 82>;

  <bb 82>:
  vma_271->vm_mm = mm_145;
  vma_271->vm_start = retval_93;
  vma_271->vm_end = pretmp_164;
  vma_271->vm_flags = vm_flags_160;
  _272 = vm_flags_160 & 15;
  _273 = protection_map[_272].pgprot;
  MEM[(struct vm_area_struct *)vma_271 + 72B] = _273;
  vma_271->vm_pgoff = pgoff_161;
  _165 = &vma_271->anon_vma_chain;
  MEM[(struct list_head *)vma_271 + 120B].next = _165;
  MEM[(struct list_head *)vma_271 + 120B].prev = _165;
  if (file_70 != 0B)
    goto <bb 83>;
  else
    goto <bb 92>;

  <bb 83>:
  _166 = vm_flags_160 & 2048;
  if (_166 != 0)
    goto <bb 85>;
  else
    goto <bb 84>;

  <bb 84>:
  _168 = vm_flags_160 & 8;
  if (_168 != 0)
    goto <bb 87>;
  else
    goto <bb 86>;

  <bb 85>:
  error_167 = deny_write_access (file_70);
  if (error_167 != 0)
    goto <bb 109> (free_vma);
  else
    goto <bb 84>;

  <bb 86>:
  _171 = get_file (file_70);
  vma_271->vm_file = _171;
  _172 = file_70->f_op;
  _173 = _172->mmap;
  error_174 = _173 (file_70, vma_271);
  if (error_174 != 0)
    goto <bb 105> (unmap_and_free_vma);
  else
    goto <bb 88>;

  <bb 87>:
  _169 = file_70->f_mapping;
  error_170 = mapping_map_writable (_169);
  if (error_170 != 0)
    goto <bb 107> (allow_write_and_free_vma);
  else
    goto <bb 86>;

  <bb 88>:
  _175 = vma_271->vm_start;
  if (retval_93 != _175)
    goto <bb 89>;
  else
    goto <bb 91>;

  <bb 89>:
  __warned.60_179 = __warned;
  if (__warned.60_179 != 0)
    goto <bb 91>;
  else
    goto <bb 90>;

  <bb 90>:
  warn_slowpath_null ("mm/mmap.c", 1674);
  __warned = 1;

  <bb 91>:
  retval_183 = vma_271->vm_start;
  vm_flags_184 = vma_271->vm_flags;
  rb_parent.61_429 = rb_parent;
  rb_link.62_391 = rb_link;
  prev.58_441 = prev;
  vma_link (mm_145, vma_271, prev.58_441, rb_link.62_391, rb_parent.61_429);
  _191 = vm_flags_184 & 8;
  if (_191 != 0)
    goto <bb 94>;
  else
    goto <bb 95>;

  <bb 92>:
  _185 = vm_flags_160 & 8;
  if (_185 != 0)
    goto <bb 93>;
  else
    goto <bb 126>;

  <bb 93>:
  error_186 = shmem_zero_setup (vma_271);
  if (error_186 != 0)
    goto <bb 109> (free_vma);
  else
    goto <bb 126>;

  <bb 94>:
  _192 = file_70->f_mapping;
  mapping_unmap_writable (_192);

  <bb 95>:
  _193 = vm_flags_184 & 2048;
  if (_193 != 0)
    goto <bb 96>;
  else
    goto <bb 97>;

  <bb 96>:
  allow_write_access (file_70);

  <bb 97>:
  # vm_flags_390 = PHI <vm_flags_160(126), vm_flags_184(95), vm_flags_184(96)>
  # retval_431 = PHI <retval_93(126), retval_183(95), retval_183(96)>
  file_194 = vma_271->vm_file;

  # file_198 = PHI <file_70(80), file_194(97)>
  # retval_235 = PHI <retval_93(80), retval_431(97)>
  # vm_flags_197 = PHI <vm_flags_160(80), vm_flags_390(97)>
  # vma_195 = PHI <vma_162(80), vma_271(97)>
out:
  perf_event_mmap (vma_195);
  _196 = (long int) charged_88;
  vm_stat_account (mm_145, vm_flags_197, file_198, _196);
  _199 = vm_flags_197 & 8192;
  if (_199 != 0)
    goto <bb 99>;
  else
    goto <bb 104>;

  <bb 99>:
  _200 = vm_flags_197 & 268715008;
  if (_200 == 0)
    goto <bb 100>;
  else
    goto <bb 103>;

  <bb 100>:
  _201 = MEM[(struct vm_area_struct *)vma_195 + 80B];
  _275 = _201 & 4194304;
  if (_275 == 0)
    goto <bb 101>;
  else
    goto <bb 103>;

  <bb 101>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___203 : "p" &current_task);
  _204 = pfo_ret___203->mm;
  _205 = get_gate_vma (_204);
  if (vma_195 != _205)
    goto <bb 102>;
  else
    goto <bb 103>;

  <bb 102>:
  _206 = mm_145->locked_vm;
  _207 = charged_88 + _206;
  mm_145->locked_vm = _207;
  goto <bb 104>;

  <bb 103>:
  _208 = vma_195->vm_flags;
  _209 = _208 & 18446744073709543423;
  vma_195->vm_flags = _209;

  <bb 104>:
  vma_set_page_prot (vma_195);
  goto <bb 113>;

unmap_and_free_vma:
  vma_271->vm_file = 0B;
  fput (file_70);
  _210 = vma_271->vm_end;
  _211 = vma_271->vm_start;
  prev.58_212 = prev;
  unmap_region (mm_145, vma_271, prev.58_212, _211, _210);
  if (_168 != 0)
    goto <bb 106>;
  else
    goto <bb 107> (allow_write_and_free_vma);

  <bb 106>:
  _213 = file_70->f_mapping;
  mapping_unmap_writable (_213);

  # error_236 = PHI <error_170(87), error_174(105), error_174(106)>
  # charged_237 = PHI <charged_233(87), 0(105), 0(106)>
allow_write_and_free_vma:
  if (_166 != 0)
    goto <bb 108>;
  else
    goto <bb 109> (free_vma);

  <bb 108>:
  allow_write_access (file_70);

  # error_238 = PHI <error_167(85), error_186(93), error_236(107), error_236(108)>
  # charged_239 = PHI <charged_233(85), charged_233(93), charged_237(107), charged_237(108)>
free_vma:
  vm_area_cachep.59_214 = vm_area_cachep;
  kmem_cache_free (vm_area_cachep.59_214, vma_271);

  # error_217 = PHI <-12(81), error_238(109)>
  # charged_215 = PHI <charged_233(81), charged_239(109)>
unacct_error:
  if (charged_215 != 0)
    goto <bb 111>;
  else
    goto <bb 112>;

  <bb 111>:
  charged.57_216 = (long int) charged_215;
  vm_unacct_memory (charged.57_216);

  <bb 112>:
  retval_218 = (long unsigned int) error_217;

  <bb 113>:
  # retval_219 = PHI <retval_218(112), retval_235(104)>
  prev ={v} {CLOBBER};
  rb_link ={v} {CLOBBER};
  rb_parent ={v} {CLOBBER};
  if (retval_219 <= 18446744073709547520)
    goto <bb 115>;
  else
    goto <bb 114>;

  <bb 114>:
  pretmp_107 = (long int) retval_219;
  goto <bb 129> (<L14>);

  <bb 115>:
  _223 = vm_flags_154 & 8192;
  if (_223 != 0)
    goto <bb 128>;
  else
    goto <bb 116>;

  <bb 116>:
  _224 = flags.48_6 & 98304;
  if (_224 == 32768)
    goto <bb 128>;
  else
    goto <bb 117>;

  <bb 117>:
  pretmp_287 = (long int) retval_219;
  goto <bb 129> (<L14>);

  <bb 118>:
  pretmp_385 = (long int) _71;

  # prephitmp_371 = PHI <prephitmp_265(129), pretmp_182(128), pretmp_385(118)>
out_fput:
  if (file_70 != 0B)
    goto <bb 120>;
  else
    goto <bb 121> (out);

  <bb 120>:
  # file_463 = PHI <file_70(119), file_20(10)>
  # prephitmp_308 = PHI <prephitmp_371(119), -22(10)>
  fput (file_463);

  # prephitmp_458 = PHI <-9(5), prephitmp_371(119), prephitmp_308(120)>
out:

  <bb 122>:
  # _230 = PHI <_232(19), prephitmp_458(121)>
  return _230;

  <bb 123>:
  _18 = (int) fd_3(D);
  _17 = (int) flags_5(D);
  __audit_mmap_fd (_18, _17);
  goto <bb 5>;

  <bb 124>:
  _24 = MEM[(const struct file *)file_20 + 32B];
  _25 = MEM[(struct inode *)_24 + 40B];
  _26 = MEM[(struct super_block *)_25 + 944B];
  _27 = MEM[(struct hugetlbfs_sb_info *)_26].hstate;
  _28 = MEM[(struct hstate *)_27 + 8B];
  _29 = (int) _28;
  _30 = 4096 << _29;
  _31 = _30 + 18446744073709551615;
  _32 = _31 + len_10;
  _33 = -_30;
  len_34 = _32 & _33;
  goto <bb 8>;

  <bb 125>:
  goto <bb 20>;

  <bb 126>:
  rb_parent.61_447 = rb_parent;
  rb_link.62_449 = rb_link;
  prev.58_248 = prev;
  vma_link (mm_145, vma_271, prev.58_248, rb_link.62_449, rb_parent.61_447);
  goto <bb 97>;

  <bb 127>:
  prev ={v} {CLOBBER};
  rb_link ={v} {CLOBBER};
  rb_parent ={v} {CLOBBER};
  goto <bb 129> (<L14>);

  <bb 128>:
  up_write (_73);
  __mm_populate (retval_219, populate_87, 1);
  pretmp_182 = (long int) retval_219;
  goto <bb 119> (out_fput);

  # prephitmp_265 = PHI <pretmp_287(117), -12(127), pretmp_85(36), -22(61), -22(60), -19(58), -22(21), pretmp_107(114), -12(34), -75(33), -13(48), -22(45), -11(44), -1(40), -12(32)>
<L14>:
  up_write (_73);
  goto <bb 119> (out_fput);

}



;; Function SyS_remap_file_pages (SyS_remap_file_pages, funcdef_no=3048, decl_uid=40442, cgraph_uid=3052)

SyS_remap_file_pages (long int start, long int size, long int prot, long int pgoff, long int flags)
{
  struct task_struct * pfo_ret__;
  long unsigned int lock_limit;
  long unsigned int locked;
  long unsigned int pgoff;
  _Bool __print_once.116;
  struct mm_struct * mm;
  struct vm_area_struct * vma;
  long unsigned int populate;
  long unsigned int ret;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct file * file;
  int sysctl_max_map_count.40;
  struct mm_struct * mm;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  long unsigned int nr_pages;
  long unsigned int charged;
  struct rb_node * rb_parent;
  struct rb_node * * rb_link;
  int error;
  struct vm_area_struct * prev;
  struct vm_area_struct * vma;
  struct mm_struct * mm;
  struct rb_node * * rb_link.62;
  struct rb_node * rb_parent.61;
  _Bool __warned.60;
  struct kmem_cache * vm_area_cachep.59;
  struct vm_area_struct * prev.58;
  struct vm_userfaultfd_ctx D.45625;
  long int charged.57;
  vm_flags_t vm_flags;
  static bool __print_once;
  long unsigned int start;
  long unsigned int size;
  long unsigned int prot;
  long unsigned int pgoff;
  long unsigned int flags;
  long unsigned int start.115;
  long unsigned int size.114;
  long unsigned int flags.111;
  int _18;
  char[16] * _20;
  long unsigned int _23;
  long unsigned int _24;
  long unsigned int _25;
  struct rw_semaphore * _26;
  long unsigned int _28;
  long unsigned int _29;
  long unsigned int _30;
  long unsigned int _31;
  long unsigned int _33;
  long unsigned int _36;
  long unsigned int _38;
  long unsigned int _42;
  struct file * _44;
  struct atomic_long_t * _45;
  unsigned int _51;
  unsigned int _52;
  struct path * _53;
  _Bool _54;
  long unsigned int _56;
  long unsigned int _59;
  int _60;
  long unsigned int _64;
  long unsigned int _68;
  long unsigned int _69;
  long unsigned int _70;
  long unsigned int _72;
  int _73;
  struct inode * _76;
  long unsigned int _78;
  unsigned int _79;
  unsigned int _80;
  unsigned int _81;
  unsigned int _82;
  unsigned int _83;
  unsigned int _84;
  int _85;
  unsigned int _87;
  unsigned int _88;
  vm_flags_t _89;
  unsigned int _91;
  struct path * _92;
  _Bool _93;
  long unsigned int _95;
  const struct file_operations * _97;
  int (*<T264d>) (struct file *, struct vm_area_struct *) _98;
  long unsigned int _100;
  long unsigned int _101;
  int _105;
  long unsigned int _106;
  long unsigned int _108;
  int _109;
  int _110;
  long unsigned int _111;
  int _112;
  int _114;
  int _116;
  struct list_head * _124;
  long unsigned int _125;
  long unsigned int _127;
  struct address_space * _128;
  struct file * _130;
  const struct file_operations * _131;
  int (*<T264d>) (struct file *, struct vm_area_struct *) _132;
  long unsigned int _134;
  long unsigned int _144;
  long unsigned int _150;
  struct address_space * _151;
  long unsigned int _152;
  long int _155;
  long unsigned int _158;
  long unsigned int _159;
  long unsigned int _160;
  struct mm_struct * _163;
  struct vm_area_struct * _164;
  long unsigned int _165;
  long unsigned int _166;
  long unsigned int _167;
  long unsigned int _168;
  long unsigned int _169;
  long unsigned int _170;
  struct address_space * _172;
  long unsigned int _182;
  long unsigned int _183;
  long int _191;
  long unsigned int _202;
  long unsigned int _206;
  long unsigned int _208;
  long unsigned int _210;
  long unsigned int _212;
  long unsigned int _214;
  long unsigned int _215;
  long unsigned int _217;
  struct signal_struct * _220;
  long long unsigned int _221;
  _Bool _225;
  long unsigned int _230;
  long unsigned int _231;
  long unsigned int _233;
  long int prephitmp_298;
  long int pretmp_299;
  long unsigned int _379;

  <bb 2>:
  pgoff_4 = (long unsigned int) pgoff_3(D);
  size.114_8 = (long unsigned int) size_7(D);
  start.115_10 = (long unsigned int) start_9(D);
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___14 : "p" &current_task);
  mm_15 = pfo_ret___14->mm;
  __print_once.116_16 = __print_once;
  if (__print_once.116_16 != 0)
    goto <bb 4>;
  else
    goto <bb 3>;

  <bb 3>:
  __print_once = 1;
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___17 : "p" &current_task);
  _18 = pfo_ret___17->pid;
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___19 : "p" &current_task);
  _20 = &pfo_ret___19->comm;
  printk ("\14mmap: %s (%d) uses deprecated remap_file_pages() syscall. See Documentation/vm/remap_file_pages.txt.\n", _20, _18);

  <bb 4>:
  if (prot_5(D) != 0)
    goto <bb 101>;
  else
    goto <bb 5>;

  <bb 5>:
  start_21 = start.115_10 & 18446744073709547520;
  size_22 = size.114_8 & 18446744073709547520;
  _23 = size_22 + start_21;
  if (start_21 >= _23)
    goto <bb 101>;
  else
    goto <bb 6>;

  <bb 6>:
  _24 = size_22 >> 12;
  _25 = _24 + pgoff_4;
  if (pgoff_4 > _25)
    goto <bb 101>;
  else
    goto <bb 7>;

  <bb 7>:
  _26 = &mm_15->mmap_sem;
  down_write (_26);
  vma_27 = find_vma (mm_15, start_21);
  if (vma_27 == 0B)
    goto <bb 104>;
  else
    goto <bb 8>;

  <bb 8>:
  _28 = vma_27->vm_flags;
  _29 = _28 & 8;
  if (_29 == 0)
    goto <bb 104>;
  else
    goto <bb 9>;

  <bb 9>:
  _30 = vma_27->vm_start;
  if (start_21 < _30)
    goto <bb 104>;
  else
    goto <bb 10>;

  <bb 10>:
  _31 = vma_27->vm_end;
  if (_23 > _31)
    goto <bb 104>;
  else
    goto <bb 11>;

  <bb 11>:
  _202 = _28 & 4194304;
  if (_202 != 0)
    goto <bb 12>;
  else
    goto <bb 13>;

  <bb 12>:
  _206 = linear_hugepage_index (vma_27, start_21);
  goto <bb 14>;

  <bb 13>:
  _208 = start_21 - _30;
  pgoff_209 = _208 >> 12;
  _210 = vma_27->vm_pgoff;
  pgoff_211 = pgoff_209 + _210;

  <bb 14>:
  # _212 = PHI <_206(12), pgoff_211(13)>
  if (pgoff_4 == _212)
    goto <bb 104>;
  else
    goto <bb 15>;

  <bb 15>:
  _33 = vma_27->vm_flags;
  flags.111_2 = (long unsigned int) flags_1(D);
  flags_40 = flags.111_2 & 65536;
  _42 = _33 & 8192;
  if (_42 != 0)
    goto <bb 17>;
  else
    goto <bb 16>;

  <bb 16>:
  flags_41 = flags_40 | 32785;
  goto <bb 18>;

  <bb 17>:
  flags_43 = flags_40 | 40977;
  munlock_vma_pages_range (vma_27, start_21, _23);

  <bb 18>:
  # flags_62 = PHI <flags_41(16), flags_43(17)>
  _44 = vma_27->vm_file;
  _45 = &_44->f_count;
  __asm__ __volatile__(".pushsection .smp_locks,"a"
.balign 4
.long 671f - .
.popsection
671:
	lock; incq %0" : "=m" MEM[(struct atomic64_t *)_45].counter : "m" MEM[(struct atomic64_t *)_45].counter);
  file_46 = vma_27->vm_file;
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___47 : "p" &current_task);
  mm_48 = pfo_ret___47->mm;
  if (size_22 == 0)
    goto <bb 106>;
  else
    goto <bb 19>;

  <bb 19>:
  prot_34 = _33 & 1;
  _38 = _33 & 4;
  _36 = _33 & 2;
  prot_37 = _36 | prot_34;
  prot_39 = prot_37 | _38;
  if (prot_34 != 0)
    goto <bb 20>;
  else
    goto <bb 24>;

  <bb 20>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___50 : "p" &current_task);
  _51 = pfo_ret___50->personality;
  _52 = _51 & 4194304;
  if (_52 != 0)
    goto <bb 21>;
  else
    goto <bb 24>;

  <bb 21>:
  if (file_46 == 0B)
    goto <bb 22>;
  else
    goto <bb 23>;

  <bb 22>:
  prot_55 = prot_39 | 4;
  goto <bb 24>;

  <bb 23>:
  _53 = &file_46->f_path;
  _54 = path_noexec (_53);
  if (_54 != 0)
    goto <bb 24>;
  else
    goto <bb 22>;

  <bb 24>:
  # prot_65 = PHI <prot_39(19), prot_39(20), prot_39(23), prot_55(22)>
  _56 = size_22 + 4095;
  populate_57 = _56 & 18446744073709547520;
  if (populate_57 == 0)
    goto <bb 106>;
  else
    goto <bb 25>;

  <bb 25>:
  charged_58 = populate_57 >> 12;
  _59 = charged_58 + pgoff_4;
  if (pgoff_4 > _59)
    goto <bb 106>;
  else
    goto <bb 26>;

  <bb 26>:
  _60 = mm_48->map_count;
  sysctl_max_map_count.40_61 = sysctl_max_map_count;
  if (_60 > sysctl_max_map_count.40_61)
    goto <bb 106>;
  else
    goto <bb 27>;

  <bb 27>:
  ret_63 = get_unmapped_area (file_46, start_21, populate_57, pgoff_4, flags_62);
  _64 = ret_63 & 4095;
  if (_64 != 0)
    goto <bb 106>;
  else
    goto <bb 28>;

  <bb 28>:
  _69 = mm_48->def_flags;
  _72 = flags_62 & 8192;
  if (_72 != 0)
    goto <bb 30>;
  else
    goto <bb 29>;

  <bb 29>:
  _214 = flags_62 & 10496;
  _68 = _214 | _69;
  _70 = _68 | prot_65;
  _215 = _70 & 8192;
  if (_215 != 0)
    goto <bb 33>;
  else
    goto <bb 32>;

  <bb 30>:
  _73 = can_do_mlock ();
  if (_73 == 0)
    goto <bb 31>;
  else
    goto <bb 29>;

  <bb 31>:
  goto <bb 106>;

  <bb 32>:
  if (file_46 != 0B)
    goto <bb 36>;
  else
    goto <bb 51>;

  <bb 33>:
  _217 = MEM[(long unsigned int *)mm_48 + 184B];
  locked_218 = charged_58 + _217;
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___219 : "p" &current_task);
  _220 = MEM[(const struct task_struct *)pfo_ret___219].signal;
  _221 ={v} MEM[(volatile __u64 *)_220].rlim[8].rlim_cur;
  lock_limit_222 = _221 >> 12;
  if (locked_218 > lock_limit_222)
    goto <bb 34>;
  else
    goto <bb 32>;

  <bb 34>:
  _225 = capable (14);
  if (_225 != 0)
    goto <bb 32>;
  else
    goto <bb 35>;

  <bb 35>:
  goto <bb 106>;

  <bb 36>:
  _76 = MEM[(const struct file *)file_46 + 32B];
  _78 = prot_65 & 2;
  if (_78 != 0)
    goto <bb 37>;
  else
    goto <bb 39>;

  <bb 37>:
  _79 = file_46->f_mode;
  _80 = _79 & 2;
  if (_80 == 0)
    goto <bb 38>;
  else
    goto <bb 39>;

  <bb 38>:
  goto <bb 106>;

  <bb 39>:
  _81 = _76->i_flags;
  _82 = _81 & 4;
  if (_82 != 0)
    goto <bb 40>;
  else
    goto <bb 41>;

  <bb 40>:
  _83 = file_46->f_mode;
  _84 = _83 & 2;
  if (_84 != 0)
    goto <bb 38>;
  else
    goto <bb 41>;

  <bb 41>:
  _85 = locks_verify_locked (file_46);
  if (_85 != 0)
    goto <bb 35>;
  else
    goto <bb 42>;

  <bb 42>:
  vm_flags_86 = _70 | 248;
  _87 = file_46->f_mode;
  _88 = _87 & 2;
  if (_88 == 0)
    goto <bb 43>;
  else
    goto <bb 44>;

  <bb 43>:
  _89 = _70 & 18446744073709551575;
  vm_flags_90 = _89 | 208;

  <bb 44>:
  # vm_flags_94 = PHI <vm_flags_86(42), vm_flags_90(43)>
  _91 = _87 & 1;
  if (_91 == 0)
    goto <bb 38>;
  else
    goto <bb 45>;

  <bb 45>:
  _92 = &file_46->f_path;
  _93 = path_noexec (_92);
  if (_93 != 0)
    goto <bb 46>;
  else
    goto <bb 48>;

  <bb 46>:
  _95 = vm_flags_94 & 4;
  if (_95 != 0)
    goto <bb 31>;
  else
    goto <bb 47>;

  <bb 47>:
  vm_flags_96 = vm_flags_94 & 18446744073709551551;

  <bb 48>:
  # vm_flags_99 = PHI <vm_flags_94(45), vm_flags_96(47)>
  _97 = file_46->f_op;
  _98 = _97->mmap;
  if (_98 == 0B)
    goto <bb 106>;
  else
    goto <bb 49>;

  <bb 49>:
  _100 = vm_flags_99 & 256;
  if (_100 != 0)
    goto <bb 50>;
  else
    goto <bb 53>;

  <bb 50>:
  goto <bb 106>;

  <bb 51>:
  _101 = _70 & 256;
  if (_101 != 0)
    goto <bb 50>;
  else
    goto <bb 52>;

  <bb 52>:
  vm_flags_102 = _70 | 248;

  <bb 53>:
  # vm_flags_113 = PHI <vm_flags_99(49), vm_flags_102(52)>
  # pgoff_120 = PHI <pgoff_4(49), 0(52)>
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___103 : "p" &current_task);
  mm_104 = pfo_ret___103->mm;
  _105 = may_expand_vm (mm_104, charged_58);
  if (_105 == 0)
    goto <bb 54>;
  else
    goto <bb 57>;

  <bb 54>:
  _106 = ret_63 + populate_57;
  nr_pages_107 = count_vma_pages_range (mm_104, ret_63, _106);
  _108 = charged_58 - nr_pages_107;
  _109 = may_expand_vm (mm_104, _108);
  if (_109 == 0)
    goto <bb 103>;
  else
    goto <bb 57>;

  <bb 55>:
  _110 = do_munmap (mm_104, ret_63, populate_57);
  if (_110 != 0)
    goto <bb 103>;
  else
    goto <bb 56>;

  <bb 56>:
  goto <bb 58>;

  <bb 57>:

  <bb 58>:
  _111 = ret_63 + populate_57;
  _112 = find_vma_links (mm_104, ret_63, _111, &prev, &rb_link, &rb_parent);
  if (_112 != 0)
    goto <bb 55>;
  else
    goto <bb 59>;

  <bb 59>:
  # _379 = PHI <_111(58)>
  _114 = accountable_mapping (file_46, vm_flags_113);
  if (_114 != 0)
    goto <bb 60>;
  else
    goto <bb 62>;

  <bb 60>:
  charged.57_115 = (long int) charged_58;
  _116 = security_vm_enough_memory_mm (mm_104, charged.57_115);
  if (_116 != 0)
    goto <bb 103>;
  else
    goto <bb 61>;

  <bb 61>:
  vm_flags_117 = vm_flags_113 | 1048576;

  <bb 62>:
  # vm_flags_119 = PHI <vm_flags_113(59), vm_flags_117(61)>
  # charged_192 = PHI <0(59), charged_58(61)>
  prev.58_118 = prev;
  vma_121 = vma_merge (mm_104, prev.58_118, ret_63, _379, vm_flags_119, 0B, file_46, pgoff_120, 0B, D.45625);
  if (vma_121 != 0B)
    goto <bb 80> (out);
  else
    goto <bb 63>;

  <bb 63>:
  vm_area_cachep.59_122 = vm_area_cachep;
  vma_229 = kmem_cache_alloc (vm_area_cachep.59_122, 32976);
  if (vma_229 == 0B)
    goto <bb 92> (unacct_error);
  else
    goto <bb 64>;

  <bb 64>:
  vma_229->vm_mm = mm_104;
  vma_229->vm_start = ret_63;
  vma_229->vm_end = _379;
  vma_229->vm_flags = vm_flags_119;
  _230 = vm_flags_119 & 15;
  _231 = protection_map[_230].pgprot;
  MEM[(struct vm_area_struct *)vma_229 + 72B] = _231;
  vma_229->vm_pgoff = pgoff_120;
  _124 = &vma_229->anon_vma_chain;
  MEM[(struct list_head *)vma_229 + 120B].next = _124;
  MEM[(struct list_head *)vma_229 + 120B].prev = _124;
  if (file_46 != 0B)
    goto <bb 65>;
  else
    goto <bb 74>;

  <bb 65>:
  _125 = vm_flags_119 & 2048;
  if (_125 != 0)
    goto <bb 67>;
  else
    goto <bb 66>;

  <bb 66>:
  _127 = vm_flags_119 & 8;
  if (_127 != 0)
    goto <bb 69>;
  else
    goto <bb 68>;

  <bb 67>:
  error_126 = deny_write_access (file_46);
  if (error_126 != 0)
    goto <bb 91> (free_vma);
  else
    goto <bb 66>;

  <bb 68>:
  _130 = get_file (file_46);
  vma_229->vm_file = _130;
  _131 = file_46->f_op;
  _132 = _131->mmap;
  error_133 = _132 (file_46, vma_229);
  if (error_133 != 0)
    goto <bb 87> (unmap_and_free_vma);
  else
    goto <bb 70>;

  <bb 69>:
  _128 = file_46->f_mapping;
  error_129 = mapping_map_writable (_128);
  if (error_129 != 0)
    goto <bb 89> (allow_write_and_free_vma);
  else
    goto <bb 68>;

  <bb 70>:
  _134 = vma_229->vm_start;
  if (ret_63 != _134)
    goto <bb 71>;
  else
    goto <bb 73>;

  <bb 71>:
  __warned.60_138 = __warned;
  if (__warned.60_138 != 0)
    goto <bb 73>;
  else
    goto <bb 72>;

  <bb 72>:
  warn_slowpath_null ("mm/mmap.c", 1674);
  __warned = 1;

  <bb 73>:
  ret_142 = vma_229->vm_start;
  vm_flags_143 = vma_229->vm_flags;
  rb_parent.61_377 = rb_parent;
  rb_link.62_376 = rb_link;
  prev.58_378 = prev;
  vma_link (mm_104, vma_229, prev.58_378, rb_link.62_376, rb_parent.61_377);
  _150 = vm_flags_143 & 8;
  if (_150 != 0)
    goto <bb 76>;
  else
    goto <bb 77>;

  <bb 74>:
  _144 = vm_flags_119 & 8;
  if (_144 != 0)
    goto <bb 75>;
  else
    goto <bb 102>;

  <bb 75>:
  error_145 = shmem_zero_setup (vma_229);
  if (error_145 != 0)
    goto <bb 91> (free_vma);
  else
    goto <bb 102>;

  <bb 76>:
  _151 = file_46->f_mapping;
  mapping_unmap_writable (_151);

  <bb 77>:
  _152 = vm_flags_143 & 2048;
  if (_152 != 0)
    goto <bb 78>;
  else
    goto <bb 79>;

  <bb 78>:
  allow_write_access (file_46);

  <bb 79>:
  # vm_flags_373 = PHI <vm_flags_119(102), vm_flags_143(77), vm_flags_143(78)>
  # ret_137 = PHI <ret_63(102), ret_142(77), ret_142(78)>
  file_153 = vma_229->vm_file;

  # file_157 = PHI <file_46(62), file_153(79)>
  # ret_194 = PHI <ret_63(62), ret_137(79)>
  # vm_flags_156 = PHI <vm_flags_119(62), vm_flags_373(79)>
  # vma_154 = PHI <vma_121(62), vma_229(79)>
out:
  perf_event_mmap (vma_154);
  _155 = (long int) charged_58;
  vm_stat_account (mm_104, vm_flags_156, file_157, _155);
  _158 = vm_flags_156 & 8192;
  if (_158 != 0)
    goto <bb 81>;
  else
    goto <bb 86>;

  <bb 81>:
  _159 = vm_flags_156 & 268715008;
  if (_159 == 0)
    goto <bb 82>;
  else
    goto <bb 85>;

  <bb 82>:
  _160 = MEM[(struct vm_area_struct *)vma_154 + 80B];
  _233 = _160 & 4194304;
  if (_233 == 0)
    goto <bb 83>;
  else
    goto <bb 85>;

  <bb 83>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___162 : "p" &current_task);
  _163 = pfo_ret___162->mm;
  _164 = get_gate_vma (_163);
  if (vma_154 != _164)
    goto <bb 84>;
  else
    goto <bb 85>;

  <bb 84>:
  _165 = mm_104->locked_vm;
  _166 = charged_58 + _165;
  mm_104->locked_vm = _166;
  goto <bb 86>;

  <bb 85>:
  _167 = vma_154->vm_flags;
  _168 = _167 & 18446744073709543423;
  vma_154->vm_flags = _168;

  <bb 86>:
  vma_set_page_prot (vma_154);
  goto <bb 95>;

unmap_and_free_vma:
  vma_229->vm_file = 0B;
  fput (file_46);
  _169 = vma_229->vm_end;
  _170 = vma_229->vm_start;
  prev.58_171 = prev;
  unmap_region (mm_104, vma_229, prev.58_171, _170, _169);
  if (_127 != 0)
    goto <bb 88>;
  else
    goto <bb 89> (allow_write_and_free_vma);

  <bb 88>:
  _172 = file_46->f_mapping;
  mapping_unmap_writable (_172);

  # error_195 = PHI <error_129(69), error_133(87), error_133(88)>
  # charged_196 = PHI <charged_192(69), 0(87), 0(88)>
allow_write_and_free_vma:
  if (_125 != 0)
    goto <bb 90>;
  else
    goto <bb 91> (free_vma);

  <bb 90>:
  allow_write_access (file_46);

  # error_197 = PHI <error_126(67), error_145(75), error_195(89), error_195(90)>
  # charged_198 = PHI <charged_192(67), charged_192(75), charged_196(89), charged_196(90)>
free_vma:
  vm_area_cachep.59_173 = vm_area_cachep;
  kmem_cache_free (vm_area_cachep.59_173, vma_229);

  # error_176 = PHI <-12(63), error_197(91)>
  # charged_174 = PHI <charged_192(63), charged_198(91)>
unacct_error:
  if (charged_174 != 0)
    goto <bb 93>;
  else
    goto <bb 94>;

  <bb 93>:
  charged.57_175 = (long int) charged_174;
  vm_unacct_memory (charged.57_175);

  <bb 94>:
  ret_177 = (long unsigned int) error_176;

  <bb 95>:
  # ret_178 = PHI <ret_177(94), ret_194(86)>
  prev ={v} {CLOBBER};
  rb_link ={v} {CLOBBER};
  rb_parent ={v} {CLOBBER};
  if (ret_178 <= 18446744073709547520)
    goto <bb 96>;
  else
    goto <bb 106>;

  <bb 96>:
  _182 = vm_flags_113 & 8192;
  if (_182 != 0)
    goto <bb 105>;
  else
    goto <bb 97>;

  <bb 97>:
  _183 = flags_62 & 98304;
  if (_183 == 32768)
    goto <bb 105>;
  else
    goto <bb 106>;

  <bb 98>:
  # ret_374 = PHI <ret_350(106), ret_360(104)>
  if (ret_374 <= 18446744073709547520)
    goto <bb 100>;
  else
    goto <bb 99>;

  <bb 99>:
  pretmp_299 = (long int) ret_374;

  <bb 100>:
  # prephitmp_298 = PHI <pretmp_299(99), 0(98), 0(105)>

  <bb 101>:
  # _191 = PHI <-22(5), prephitmp_298(100), -22(4), -22(6)>
  return _191;

  <bb 102>:
  rb_parent.61_351 = rb_parent;
  rb_link.62_352 = rb_link;
  prev.58_372 = prev;
  vma_link (mm_104, vma_229, prev.58_372, rb_link.62_352, rb_parent.61_351);
  goto <bb 79>;

  <bb 103>:
  prev ={v} {CLOBBER};
  rb_link ={v} {CLOBBER};
  rb_parent ={v} {CLOBBER};
  goto <bb 106>;

  <bb 104>:
  # ret_360 = PHI <0(14), 18446744073709551594(8), 18446744073709551594(7), 18446744073709551594(10), 18446744073709551594(9)>
  up_write (_26);
  goto <bb 98>;

  <bb 105>:
  fput (_44);
  up_write (_26);
  __mm_populate (ret_178, populate_57, 1);
  goto <bb 100>;

  <bb 106>:
  # ret_350 = PHI <18446744073709551605(35), ret_178(95), ret_178(97), 18446744073709551604(103), 18446744073709551594(18), 18446744073709551594(50), 18446744073709551597(48), 18446744073709551541(25), 18446744073709551615(31), 18446744073709551604(26), ret_63(27), 18446744073709551603(38), 18446744073709551604(24)>
  fput (_44);
  up_write (_26);
  goto <bb 98>;

}



;; Function _install_special_mapping (_install_special_mapping, funcdef_no=3061, decl_uid=25146, cgraph_uid=3065)

_install_special_mapping (struct mm_struct * mm, long unsigned int addr, long unsigned int len, long unsigned int vm_flags, const struct vm_special_mapping * spec)
{
  struct vm_area_struct * _8;

  <bb 2>:
  _8 = __install_special_mapping (mm_2(D), addr_3(D), len_4(D), vm_flags_5(D), &special_mapping_vmops, spec_6(D));
  return _8;

}



;; Function install_special_mapping (install_special_mapping, funcdef_no=3062, decl_uid=25152, cgraph_uid=3066)

install_special_mapping (struct mm_struct * mm, long unsigned int addr, long unsigned int len, long unsigned int vm_flags, struct page * * pages)
{
  long unsigned int ptr.54;
  struct vm_area_struct * vma;
  long int _13;
  int _14;
  int _15;

  <bb 2>:
  vma_8 = __install_special_mapping (mm_2(D), addr_3(D), len_4(D), vm_flags_5(D), &legacy_special_mapping_vmops, pages_6(D));
  ptr.54_9 = (long unsigned int) vma_8;
  if (ptr.54_9 > 18446744073709547520)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _13 = (long int) vma_8;
  _14 = (int) _13;

  <bb 4>:
  # _15 = PHI <0(2), _14(3)>
  return _15;

}



;; Function mm_drop_all_locks (mm_drop_all_locks, funcdef_no=3068, decl_uid=25132, cgraph_uid=3072)

mm_drop_all_locks (struct mm_struct * mm)
{
  int oldbit;
  const struct list_head * __mptr;
  const struct list_head * __mptr;
  struct anon_vma_chain * avc;
  struct vm_area_struct * vma;
  long unsigned int shifttmp_1;
  struct rw_semaphore * _8;
  int _11;
  struct list_head * _12;
  struct anon_vma * _20;
  struct list_head * _23;
  struct anon_vma * _25;
  struct file * _29;
  struct address_space * _30;
  int _34;
  struct list_head * _35;
  struct anon_vma * _36;
  long unsigned int _37;
  long unsigned int _38;
  struct rb_node * * _39;
  struct anon_vma * _41;
  struct rw_semaphore * _42;
  long unsigned int _43;
  long unsigned int _45;
  struct rw_semaphore * _46;
  long unsigned int * _47;

  <bb 2>:
  _8 = &mm_7(D)->mmap_sem;
  _11 = down_read_trylock (_8);
  if (_11 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  __asm__ __volatile__("1:	ud2
.pushsection __bug_table,"a"
2:	.long 1b - 2b, %c0 - 2b
	.word %c1, 0
	.org 2b+%c2
.popsection" :  : "i" "mm/mmap.c", "i" 3303, "i" 12);
  __builtin_unreachable ();

  <bb 4>:
  _34 ={v} MEM[(const int *)&mm_all_locks_mutex];
  if (_34 == 1)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  __asm__ __volatile__("1:	ud2
.pushsection __bug_table,"a"
2:	.long 1b - 2b, %c0 - 2b
	.word %c1, 0
	.org 2b+%c2
.popsection" :  : "i" "mm/mmap.c", "i" 3304, "i" 12);
  __builtin_unreachable ();

  <bb 6>:
  vma_19 = mm_7(D)->mmap;
  if (vma_19 != 0B)
    goto <bb 8>;
  else
    goto <bb 7>;

  <bb 7>:
  mutex_unlock (&mm_all_locks_mutex);
  return;

  <bb 8>:

  <bb 9>:
  # vma_13 = PHI <vma_32(24), vma_19(8)>
  _20 = vma_13->anon_vma;
  if (_20 != 0B)
    goto <bb 11>;
  else
    goto <bb 10>;

  <bb 10>:
  _29 = vma_13->vm_file;
  if (_29 != 0B)
    goto <bb 19>;
  else
    goto <bb 23> (<L19>);

  <bb 11>:
  __mptr_21 = vma_13->anon_vma_chain.next;
  avc_22 = &MEM[(void *)__mptr_21 + -16B];
  _35 = &MEM[(struct anon_vma_chain *)__mptr_21 + -16B].same_vma;
  _12 = &vma_13->anon_vma_chain;
  if (_35 != _12)
    goto <bb 12>;
  else
    goto <bb 10>;

  <bb 12>:

  <bb 13>:
  # avc_14 = PHI <avc_28(18), avc_22(12)>
  _25 = avc_14->anon_vma;
  _36 = _25->root;
  _37 ={v} MEM[(const long unsigned int *)_36 + 64B];
  _38 = _37 & 1;
  if (_38 != 0)
    goto <bb 14>;
  else
    goto <bb 17>;

  <bb 14>:
  _39 = &_36->rb_root.rb_node;
  __asm__ __volatile__("btr %2,%1
	sbb %0,%0" : "=r" oldbit_40, "=m" MEM[(volatile long int *)_39] : "Ir" 0, "m" MEM[(volatile long int *)_39]);
  if (oldbit_40 == 0)
    goto <bb 15>;
  else
    goto <bb 16>;

  <bb 15>:
  __asm__ __volatile__("1:	ud2
.pushsection __bug_table,"a"
2:	.long 1b - 2b, %c0 - 2b
	.word %c1, 0
	.org 2b+%c2
.popsection" :  : "i" "mm/mmap.c", "i" 3275, "i" 12);
  __builtin_unreachable ();

  <bb 16>:
  _41 = MEM[(struct anon_vma *)_25];
  _42 = &_41->rwsem;
  up_write (_42);

  <bb 17>:
  __mptr_27 = avc_14->same_vma.next;
  avc_28 = &MEM[(void *)__mptr_27 + -16B];
  _23 = &MEM[(struct anon_vma_chain *)__mptr_27 + -16B].same_vma;
  if (_12 != _23)
    goto <bb 18>;
  else
    goto <bb 10>;

  <bb 18>:
  goto <bb 13>;

  <bb 19>:
  _30 = _29->f_mapping;
  if (_30 != 0B)
    goto <bb 20>;
  else
    goto <bb 23> (<L19>);

  <bb 20>:
  _43 ={v} MEM[(const long unsigned int *)_30 + 112B];
  shifttmp_1 = _43 & 134217728;
  if (shifttmp_1 != 0)
    goto <bb 21>;
  else
    goto <bb 23> (<L19>);

  <bb 21>:
  _46 = &_30->i_mmap_rwsem;
  up_write (_46);
  _47 = &_30->flags;
  __asm__ __volatile__ goto(".pushsection .smp_locks,"a"
.balign 4
.long 671f - .
.popsection
671:
	lock; btr %1, %0; jc %l2" :  : "m" MEM[(volatile long unsigned int *)_47], "Ir" 27 : "memory" : "cc_label" <L19>);

  <bb 22>:
  __asm__ __volatile__("");
  __asm__ __volatile__("1:	ud2
.pushsection __bug_table,"a"
2:	.long 1b - 2b, %c0 - 2b
	.word %c1, 0
	.org 2b+%c2
.popsection" :  : "i" "mm/mmap.c", "i" 3290, "i" 12);
  __builtin_unreachable ();

<L19>:
  vma_32 = vma_13->vm_next;
  if (vma_32 != 0B)
    goto <bb 24>;
  else
    goto <bb 7>;

  <bb 24>:
  goto <bb 9>;

}



;; Function mm_take_all_locks (mm_take_all_locks, funcdef_no=3065, decl_uid=25130, cgraph_uid=3069)

mm_take_all_locks (struct mm_struct * mm)
{
  int oldbit;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  const struct list_head * __mptr;
  const struct list_head * __mptr;
  struct anon_vma_chain * avc;
  struct vm_area_struct * vma;
  long unsigned int shifttmp_3;
  int _4;
  struct rw_semaphore * _13;
  int _16;
  int _17;
  struct file * _23;
  struct address_space * _24;
  struct anon_vma * _29;
  struct list_head * _32;
  struct anon_vma * _34;
  void * _41;
  long unsigned int _42;
  long unsigned int _43;
  long unsigned int _44;
  void * _46;
  int _48;
  void * _50;
  long unsigned int _51;
  long unsigned int _52;
  long unsigned int _53;
  long unsigned int _54;
  long unsigned int _55;
  int _57;
  long unsigned int _58;
  long unsigned int _60;
  long unsigned int * _61;
  long unsigned int _62;
  struct rw_semaphore * _63;
  struct anon_vma * _64;
  long unsigned int _65;
  long unsigned int _66;
  struct rw_semaphore * _67;
  struct anon_vma * _68;
  struct rb_node * * _69;
  struct list_head * _76;
  struct list_head * _77;
  void * _81;
  long unsigned int _82;
  long unsigned int _83;
  long unsigned int _84;
  int _85;

  <bb 2>:
  _13 = &mm_12(D)->mmap_sem;
  _16 = down_read_trylock (_13);
  if (_16 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  __asm__ __volatile__("1:	ud2
.pushsection __bug_table,"a"
2:	.long 1b - 2b, %c0 - 2b
	.word %c1, 0
	.org 2b+%c2
.popsection" :  : "i" "mm/mmap.c", "i" 3232, "i" 12);
  __builtin_unreachable ();

  <bb 4>:
  mutex_lock (&mm_all_locks_mutex);
  vma_21 = mm_12(D)->mmap;
  if (vma_21 != 0B)
    goto <bb 6>;
  else
    goto <bb 5>;

  <bb 5>:
  goto <bb 31>;

  <bb 6>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___80 : "p" &current_task);
  _81 = pfo_ret___80->stack;
  _82 ={v} MEM[(const long unsigned int *)_81 + 8B];
  _83 = _82 >> 2;
  _84 = _83 & 1;
  _85 = (int) _84;
  if (_85 != 0)
    goto <bb 30>;
  else
    goto <bb 7>;

  <bb 7>:
  goto <bb 10>;

  <bb 8>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___40 : "p" &current_task);
  _41 = pfo_ret___40->stack;
  _42 ={v} MEM[(const long unsigned int *)_41 + 8B];
  _43 = _42 >> 2;
  _44 = _43 & 1;
  _48 = (int) _44;
  if (_48 != 0)
    goto <bb 30>;
  else
    goto <bb 9>;

  <bb 9>:

  <bb 10>:
  # vma_86 = PHI <vma_26(9), vma_21(7)>
  _23 = vma_86->vm_file;
  if (_23 != 0B)
    goto <bb 11>;
  else
    goto <bb 15>;

  <bb 11>:
  _24 = _23->f_mapping;
  if (_24 != 0B)
    goto <bb 12>;
  else
    goto <bb 15>;

  <bb 12>:
  _58 ={v} MEM[(const long unsigned int *)_24 + 112B];
  shifttmp_3 = _58 & 134217728;
  if (shifttmp_3 == 0)
    goto <bb 13>;
  else
    goto <bb 15>;

  <bb 13>:
  _61 = &_24->flags;
  __asm__ __volatile__ goto(".pushsection .smp_locks,"a"
.balign 4
.long 671f - .
.popsection
671:
	lock; bts %1, %0; jc %l2" :  : "m" MEM[(volatile long unsigned int *)_61], "Ir" 27 : "memory" : "cc_label" <L23>);

  <bb 14>:
  __asm__ __volatile__("");
  _63 = &_24->i_mmap_rwsem;
  down_write (_63);

  <bb 15>:
  vma_26 = vma_86->vm_next;
  if (vma_26 != 0B)
    goto <bb 8>;
  else
    goto <bb 16>;

  <bb 16>:
  vma_27 = mm_12(D)->mmap;
  if (vma_27 != 0B)
    goto <bb 17>;
  else
    goto <bb 5>;

  <bb 17>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___45 : "p" &current_task);
  _46 = pfo_ret___45->stack;
  _54 ={v} MEM[(const long unsigned int *)_46 + 8B];
  _55 = _54 >> 2;
  _62 = _55 & 1;
  _17 = (int) _62;
  if (_17 != 0)
    goto <bb 30>;
  else
    goto <bb 18>;

  <bb 18>:
  goto <bb 21>;

  <bb 19>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___49 : "p" &current_task);
  _50 = pfo_ret___49->stack;
  _51 ={v} MEM[(const long unsigned int *)_50 + 8B];
  _52 = _51 >> 2;
  _53 = _52 & 1;
  _57 = (int) _53;
  if (_57 != 0)
    goto <bb 30>;
  else
    goto <bb 20>;

  <bb 20>:

  <bb 21>:
  # vma_87 = PHI <vma_38(20), vma_27(18)>
  _29 = vma_87->anon_vma;
  if (_29 != 0B)
    goto <bb 23>;
  else
    goto <bb 22>;

  <bb 22>:
  vma_38 = vma_87->vm_next;
  if (vma_38 != 0B)
    goto <bb 19>;
  else
    goto <bb 5>;

  <bb 23>:
  __mptr_30 = vma_87->anon_vma_chain.next;
  avc_31 = &MEM[(void *)__mptr_30 + -16B];
  _76 = &MEM[(struct anon_vma_chain *)__mptr_30 + -16B].same_vma;
  _77 = &vma_87->anon_vma_chain;
  if (_76 != _77)
    goto <bb 24>;
  else
    goto <bb 22>;

  <bb 24>:

  <bb 25>:
  # avc_88 = PHI <avc_37(29), avc_31(24)>
  _34 = avc_88->anon_vma;
  _64 = MEM[(struct anon_vma * *)_34];
  _65 ={v} MEM[(const long unsigned int *)_64 + 64B];
  _66 = _65 & 1;
  if (_66 == 0)
    goto <bb 26>;
  else
    goto <bb 28>;

  <bb 26>:
  _67 = &_64->rwsem;
  down_write (_67);
  _68 = MEM[(struct anon_vma * *)_34];
  _69 = &_68->rb_root.rb_node;
  __asm__("bts %2,%1
	sbb %0,%0" : "=r" oldbit_70, "=m" MEM[(volatile long int *)_69] : "Ir" 0, "m" MEM[(volatile long int *)_69]);
  if (oldbit_70 != 0)
    goto <bb 27>;
  else
    goto <bb 28>;

  <bb 27>:
  __asm__ __volatile__("1:	ud2
.pushsection __bug_table,"a"
2:	.long 1b - 2b, %c0 - 2b
	.word %c1, 0
	.org 2b+%c2
.popsection" :  : "i" "mm/mmap.c", "i" 3174, "i" 12);
  __builtin_unreachable ();

  <bb 28>:
  __mptr_36 = avc_88->same_vma.next;
  avc_37 = &MEM[(void *)__mptr_36 + -16B];
  _32 = &MEM[(struct anon_vma_chain *)__mptr_36 + -16B].same_vma;
  if (_32 != _77)
    goto <bb 29>;
  else
    goto <bb 22>;

  <bb 29>:
  goto <bb 25>;

  <bb 30>:
  mm_drop_all_locks (mm_12(D));

  <bb 31>:
  # _4 = PHI <_16(5), -4(30)>
  return _4;

<L23>:
  __asm__ __volatile__("1:	ud2
.pushsection __bug_table,"a"
2:	.long 1b - 2b, %c0 - 2b
	.word %c1, 0
	.org 2b+%c2
.popsection" :  : "i" "mm/mmap.c", "i" 3191, "i" 12);
  __builtin_unreachable ();

}



;; Function mmap_init (mmap_init, funcdef_no=3069, decl_uid=25020, cgraph_uid=3073) (unlikely executed)

mmap_init ()
{
  static struct lock_class_key __key;

  <bb 2>:
  __percpu_counter_init (&vm_committed_as, 0, 208, &__key);
  return;

}



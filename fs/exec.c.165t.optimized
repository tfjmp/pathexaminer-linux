
;; Function trace_sched_process_exec (trace_sched_process_exec, funcdef_no=2780, decl_uid=39828, cgraph_uid=2780) (unlikely executed)

trace_sched_process_exec (struct task_struct * p, pid_t old_pid, struct linux_binprm * bprm)
{
  void * __data;
  void * it_func;
  struct tracepoint_func * it_func_ptr;
  void (*<T61c8>) (void *, struct task_struct *, pid_t, struct linux_binprm *) it_func.163;
  void * _19;
  long long unsigned int _23;

  <bb 2>:
  __asm__ __volatile__ goto("1:.byte 0x0f,0x1f,0x44,0x00,0
	.pushsection __jump_table,  "aw" 
	 .balign 8 
	 .quad 1b, %l2, %c0 + %c1 
	.popsection 
	" :  : "i" &__tracepoint_sched_process_exec.key, "i" 0 :  : "l_yes" <L24>);

  <bb 3>:
  __asm__ __volatile__("");
  goto <bb 7>;

  <bb 4>:

  <bb 5>:
  # it_func_ptr_1 = PHI <it_func_ptr_9(9), it_func_ptr_18(4)>
  it_func_11 = MEM[base: it_func_ptr_1, offset: 0B];
  __data_12 = MEM[base: it_func_ptr_1, offset: 8B];
  it_func.163_13 = (void (*<T61c8>) (void *, struct task_struct *, pid_t, struct linux_binprm *)) it_func_11;
  it_func.163_13 (__data_12, p_14(D), old_pid_15(D), bprm_16(D));
  it_func_ptr_18 = it_func_ptr_1 + 16;
  _19 = MEM[base: it_func_ptr_18, offset: 0B];
  if (_19 != 0B)
    goto <bb 4>;
  else
    goto <bb 6>;

  <bb 6>:
  __asm__ __volatile__("" :  :  : "memory");

  <bb 7>:
  return;

<L24>:
  __asm__ __volatile__("" :  :  : "memory");
  _23 ={v} MEM[(volatile __u64 *)&__tracepoint_sched_process_exec + 48B];
  it_func_ptr_9 = (struct tracepoint_func *) _23;
  if (it_func_ptr_9 != 0B)
    goto <bb 9>;
  else
    goto <bb 6>;

  <bb 9>:
  goto <bb 5>;

}



;; Function install_exec_creds (install_exec_creds, funcdef_no=2881, decl_uid=30479, cgraph_uid=2882)

install_exec_creds (struct linux_binprm * bprm)
{
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct cred * _5;
  struct mm_struct * _8;
  long unsigned int _9;
  struct signal_struct * _13;
  struct mutex * _14;
  int _20;
  int _21;

  <bb 2>:
  security_bprm_committing_creds (bprm_3(D));
  _5 = bprm_3(D)->cred;
  commit_creds (_5);
  bprm_3(D)->cred = 0B;
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___16 : "p" &current_task);
  _8 = pfo_ret___16->mm;
  _9 = MEM[(struct mm_struct *)_8 + 800B];
  _20 = (int) _9;
  _21 = _20 & 3;
  if (_21 != 1)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___17 : "p" &current_task);
  perf_event_exit_task (pfo_ret___17);

  <bb 4>:
  security_bprm_committed_creds (bprm_3(D));
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___18 : "p" &current_task);
  _13 = pfo_ret___18->signal;
  _14 = &_13->cred_guard_mutex;
  mutex_unlock (_14);
  return;

}



;; Function prepare_binprm (prepare_binprm, funcdef_no=2884, decl_uid=30452, cgraph_uid=2885)

prepare_binprm (struct linux_binprm * bprm)
{
  int retval;
  int _1;
  char[128] * _9;
  struct file * _11;
  int _13;

  <bb 2>:
  bprm_fill_uid (bprm_4(D));
  retval_7 = security_bprm_set_creds (bprm_4(D));
  if (retval_7 != 0)
    goto <bb 4>;
  else
    goto <bb 3>;

  <bb 3>:
  bprm_4(D)->cred_prepared = 1;
  _9 = &bprm_4(D)->buf;
  memset (_9, 0, 128);
  _11 = bprm_4(D)->file;
  _13 = kernel_read (_11, 0, _9, 128);

  <bb 4>:
  # _1 = PHI <retval_7(2), _13(3)>
  return _1;

}



;; Function search_binary_handler (search_binary_handler, funcdef_no=2886, decl_uid=30456, cgraph_uid=2887)

search_binary_handler (struct linux_binprm * bprm)
{
  int __ret;
  int __ret;
  int __ret;
  int __ret;
  struct task_struct * pfo_ret__;
  int retval;
  struct linux_binfmt * fmt;
  bool need_retry;
  int _6;
  unsigned int _13;
  struct list_head * _18;
  struct module * _19;
  _Bool _21;
  unsigned int _23;
  unsigned int _24;
  int (*<T4b2d>) (struct linux_binprm *) _26;
  unsigned int _31;
  unsigned int _32;
  struct mm_struct * _34;
  struct file * _37;
  char _41;
  unsigned char _42;
  unsigned char _43;
  _Bool _44;
  unsigned char _45;
  _Bool _46;
  _Bool _47;
  char _48;
  unsigned char _49;
  unsigned char _50;
  _Bool _51;
  unsigned char _52;
  _Bool _53;
  _Bool _54;
  char _55;
  unsigned char _56;
  unsigned char _57;
  _Bool _58;
  unsigned char _60;
  _Bool _61;
  _Bool _62;
  char _63;
  unsigned char _64;
  unsigned char _65;
  _Bool _66;
  unsigned char _68;
  _Bool _69;
  _Bool _70;
  short unsigned int _71;
  int _72;
  int _74;
  struct module * _76;
  struct list_head * _100;

  <bb 2>:
  _13 = bprm_12(D)->recursion_depth;
  if (_13 > 5)
    goto <bb 23>;
  else
    goto <bb 3>;

  <bb 3>:
  retval_15 = security_bprm_check (bprm_12(D));
  if (retval_15 != 0)
    goto <bb 23>;
  else
    goto <bb 4>;

  <bb 4>:

  # need_retry_1 = PHI <1(4), 0(22)>
  # retval_3 = PHI <-2(4), retval_85(22)>
retry:
  _raw_read_lock (&binfmt_lock);
  fmt_17 = formats.next;
  _100 = &fmt_17->lh;
  if (_100 != &formats)
    goto <bb 6>;
  else
    goto <bb 16>;

  <bb 6>:

  <bb 7>:
  # fmt_99 = PHI <fmt_39(15), fmt_17(6)>
  # retval_96 = PHI <retval_4(15), retval_3(6)>
  _19 = fmt_99->module;
  _21 = try_module_get (_19);
  if (_21 != 0)
    goto <bb 8>;
  else
    goto <bb 14>;

  <bb 8>:
  __asm__ __volatile__(".pushsection .smp_locks,"a"
.balign 4
.long 671f - .
.popsection
671:
	lock; xaddl %0, %1
" : "=r" __ret_79, "=m" MEM[(struct atomic_t *)&binfmt_lock].counter : "0" -256, "m" MEM[(struct atomic_t *)&binfmt_lock].counter : "cc", "memory", "memory");
  __asm__ __volatile__("" :  :  : "memory");
  _23 = bprm_12(D)->recursion_depth;
  _24 = _23 + 1;
  bprm_12(D)->recursion_depth = _24;
  _26 = fmt_99->load_binary;
  retval_28 = _26 (bprm_12(D));
  _raw_read_lock (&binfmt_lock);
  _76 = MEM[(struct linux_binfmt *)fmt_99 + 16B];
  module_put (_76);
  _31 = bprm_12(D)->recursion_depth;
  _32 = _31 + 4294967295;
  bprm_12(D)->recursion_depth = _32;
  if (retval_28 < 0)
    goto <bb 9>;
  else
    goto <bb 13>;

  <bb 9>:
  _34 = bprm_12(D)->mm;
  if (_34 == 0B)
    goto <bb 10>;
  else
    goto <bb 11>;

  <bb 10>:
  __asm__ __volatile__(".pushsection .smp_locks,"a"
.balign 4
.long 671f - .
.popsection
671:
	lock; xaddl %0, %1
" : "=r" __ret_82, "=m" MEM[(struct atomic_t *)&binfmt_lock].counter : "0" -256, "m" MEM[(struct atomic_t *)&binfmt_lock].counter : "cc", "memory", "memory");
  __asm__ __volatile__("" :  :  : "memory");
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___75 : "p" &current_task);
  force_sigsegv (11, pfo_ret___75);
  goto <bb 23>;

  <bb 11>:
  if (retval_28 != -8)
    goto <bb 13>;
  else
    goto <bb 12>;

  <bb 12>:
  _37 = bprm_12(D)->file;
  if (_37 == 0B)
    goto <bb 13>;
  else
    goto <bb 14>;

  <bb 13>:
  # retval_81 = PHI <retval_28(8), retval_28(12), retval_28(11)>
  __asm__ __volatile__(".pushsection .smp_locks,"a"
.balign 4
.long 671f - .
.popsection
671:
	lock; xaddl %0, %1
" : "=r" __ret_84, "=m" MEM[(struct atomic_t *)&binfmt_lock].counter : "0" -256, "m" MEM[(struct atomic_t *)&binfmt_lock].counter : "cc", "memory", "memory");
  __asm__ __volatile__("" :  :  : "memory");
  goto <bb 23>;

  <bb 14>:
  # retval_4 = PHI <retval_96(7), retval_28(12)>
  fmt_39 = fmt_99->lh.next;
  _18 = &fmt_39->lh;
  if (_18 != &formats)
    goto <bb 15>;
  else
    goto <bb 16>;

  <bb 15>:
  goto <bb 7>;

  <bb 16>:
  # retval_85 = PHI <retval_4(14), retval_3(5)>
  __asm__ __volatile__(".pushsection .smp_locks,"a"
.balign 4
.long 671f - .
.popsection
671:
	lock; xaddl %0, %1
" : "=r" __ret_86, "=m" MEM[(struct atomic_t *)&binfmt_lock].counter : "0" -256, "m" MEM[(struct atomic_t *)&binfmt_lock].counter : "cc", "memory", "memory");
  __asm__ __volatile__("" :  :  : "memory");
  if (need_retry_1 != 0)
    goto <bb 17>;
  else
    goto <bb 23>;

  <bb 17>:
  _41 = bprm_12(D)->buf[0];
  _42 = (unsigned char) _41;
  _43 = _42 + 247;
  _44 = _43 <= 1;
  _45 = _42 + 224;
  _46 = _45 <= 94;
  _47 = _46 | _44;
  if (_47 != 0)
    goto <bb 18>;
  else
    goto <bb 21>;

  <bb 18>:
  _48 = bprm_12(D)->buf[1];
  _49 = (unsigned char) _48;
  _50 = _49 + 247;
  _51 = _50 <= 1;
  _52 = _49 + 224;
  _53 = _52 <= 94;
  _54 = _53 | _51;
  if (_54 != 0)
    goto <bb 19>;
  else
    goto <bb 21>;

  <bb 19>:
  _55 = bprm_12(D)->buf[2];
  _56 = (unsigned char) _55;
  _57 = _56 + 247;
  _58 = _57 <= 1;
  _60 = _56 + 224;
  _61 = _60 <= 94;
  _62 = _61 | _58;
  if (_62 != 0)
    goto <bb 20>;
  else
    goto <bb 21>;

  <bb 20>:
  _63 = bprm_12(D)->buf[3];
  _64 = (unsigned char) _63;
  _65 = _64 + 247;
  _66 = _65 <= 1;
  _68 = _64 + 224;
  _69 = _68 <= 94;
  _70 = _69 | _66;
  if (_70 != 0)
    goto <bb 23>;
  else
    goto <bb 21>;

  <bb 21>:
  _71 = MEM[(ushort *)bprm_12(D) + 2B];
  _72 = (int) _71;
  _74 = __request_module (1, "binfmt-%04x", _72);
  if (_74 < 0)
    goto <bb 23>;
  else
    goto <bb 22>;

  <bb 22>:
  goto <bb 5> (retry);

  <bb 23>:
  # _6 = PHI <-40(2), retval_15(3), retval_28(10), retval_81(13), retval_85(20), retval_85(21), retval_85(16)>
  return _6;

}



;; Function unregister_binfmt (unregister_binfmt, funcdef_no=2847, decl_uid=30450, cgraph_uid=2847)

unregister_binfmt (struct linux_binfmt * fmt)
{
  struct list_head * _6;
  struct list_head * _7;

  <bb 2>:
  _raw_write_lock (&binfmt_lock);
  _6 = MEM[(struct list_head *)fmt_3(D)].next;
  _7 = MEM[(struct list_head *)fmt_3(D)].prev;
  _6->prev = _7;
  _7->next = _6;
  MEM[(struct list_head *)fmt_3(D)].next = -2401263026318606080B;
  MEM[(struct list_head *)fmt_3(D)].prev = -2401263026318605824B;
  __asm__ __volatile__("" :  :  : "memory");
  MEM[(volatile __u8 *)&binfmt_lock] ={v} 0;
  __asm__ __volatile__("" :  :  : "memory");
  return;

}



;; Function shift_arg_pages (shift_arg_pages, funcdef_no=2865, decl_uid=40866, cgraph_uid=2866)

shift_arg_pages (struct vm_area_struct * vma, long unsigned int shift)
{
  struct mmu_gather tlb;
  long unsigned int new_end;
  long unsigned int new_start;
  long unsigned int length;
  long unsigned int old_end;
  long unsigned int old_start;
  struct mm_struct * mm;
  long unsigned int iftmp.17;
  long unsigned int iftmp.16;
  int _1;
  struct vm_area_struct * _19;
  long unsigned int _20;
  int _22;
  long unsigned int _24;
  struct vm_area_struct * _27;
  struct vm_area_struct * _30;
  long unsigned int _34;

  <bb 2>:
  mm_8 = vma_7(D)->vm_mm;
  old_start_9 = vma_7(D)->vm_start;
  old_end_10 = vma_7(D)->vm_end;
  new_start_13 = old_start_9 - shift_12(D);
  new_end_14 = old_end_10 - shift_12(D);
  if (new_start_13 > new_end_14)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  __asm__ __volatile__("1:	ud2
.pushsection __bug_table,"a"
2:	.long 1b - 2b, %c0 - 2b
	.word %c1, 0
	.org 2b+%c2
.popsection" :  : "i" "fs/exec.c", "i" 592, "i" 12);
  __builtin_unreachable ();

  <bb 4>:
  _19 = find_vma (mm_8, new_start_13);
  if (_19 != vma_7(D))
    goto <bb 16>;
  else
    goto <bb 5>;

  <bb 5>:
  _20 = _19->vm_pgoff;
  _22 = vma_adjust (_19, new_start_13, old_end_10, _20, 0B);
  if (_22 != 0)
    goto <bb 6>;
  else
    goto <bb 7>;

  <bb 6>:
  goto <bb 16>;

  <bb 7>:
  length_11 = old_end_10 - old_start_9;
  _24 = move_page_tables (_19, old_start_9, _19, new_start_13, length_11, 0);
  if (_24 != length_11)
    goto <bb 6>;
  else
    goto <bb 8>;

  <bb 8>:
  lru_add_drain ();
  tlb_gather_mmu (&tlb, mm_8, old_start_9, old_end_10);
  if (old_start_9 < new_end_14)
    goto <bb 9>;
  else
    goto <bb 12>;

  <bb 9>:
  _27 = _19->vm_next;
  if (_27 != 0B)
    goto <bb 10>;
  else
    goto <bb 11>;

  <bb 10>:
  iftmp.16_28 = _27->vm_start;

  <bb 11>:
  # iftmp.16_2 = PHI <iftmp.16_28(10), 0(9)>
  free_pgd_range (&tlb, new_end_14, old_end_10, new_end_14, iftmp.16_2);
  goto <bb 15>;

  <bb 12>:
  _30 = _19->vm_next;
  if (_30 != 0B)
    goto <bb 13>;
  else
    goto <bb 14>;

  <bb 13>:
  iftmp.17_31 = _30->vm_start;

  <bb 14>:
  # iftmp.17_3 = PHI <iftmp.17_31(13), 0(12)>
  free_pgd_range (&tlb, old_start_9, old_end_10, new_end_14, iftmp.17_3);

  <bb 15>:
  tlb_finish_mmu (&tlb, old_start_9, old_end_10);
  _34 = _19->vm_pgoff;
  vma_adjust (_19, new_start_13, new_end_14, _34, 0B);

  <bb 16>:
  # _1 = PHI <-14(4), -12(6), _22(15)>
  tlb ={v} {CLOBBER};
  return _1;

}



;; Function setup_arg_pages (setup_arg_pages, funcdef_no=2866, decl_uid=30468, cgraph_uid=2867)

setup_arg_pages (struct linux_binprm * bprm, long unsigned int stack_top, int executable_stack)
{
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  long unsigned int rlim_stack;
  long unsigned int stack_size;
  long unsigned int stack_base;
  long unsigned int vm_flags;
  struct vm_area_struct * prev;
  struct vm_area_struct * vma;
  struct mm_struct * mm;
  long unsigned int stack_shift;
  long unsigned int ret;
  struct vm_area_struct * prev.15;
  long unsigned int mmap_min_addr.13;
  int _4;
  long unsigned int _18;
  long unsigned int _24;
  long unsigned int _25;
  long unsigned int _26;
  long unsigned int _27;
  int pretmp_28;
  int pretmp_29;
  long unsigned int _32;
  long unsigned int _33;
  long unsigned int _36;
  long unsigned int _37;
  long unsigned int _39;
  long unsigned int _40;
  struct rw_semaphore * _42;
  unsigned int _44;
  unsigned int _45;
  int prephitmp_49;
  long unsigned int _50;
  long unsigned int _53;
  long unsigned int _54;
  int _56;
  int _63;
  long unsigned int _65;
  long unsigned int _66;
  long unsigned int _68;
  long unsigned int _69;
  long unsigned int _73;
  struct mm_struct * _76;
  long unsigned int _77;
  int _80;
  struct signal_struct * _88;
  long long unsigned int _89;

  <bb 2>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___85 : "p" &current_task);
  mm_11 = pfo_ret___85->mm;
  vma_13 = bprm_12(D)->vma;
  prev = 0B;
  stack_top_17 = arch_align_stack (stack_top_15(D));
  _18 = stack_top_17 + 4095;
  stack_top_19 = _18 & 18446744073709547520;
  mmap_min_addr.13_20 = mmap_min_addr;
  if (stack_top_19 < mmap_min_addr.13_20)
    goto <bb 24>;
  else
    goto <bb 3>;

  <bb 3>:
  _24 = vma_13->vm_end;
  _25 = vma_13->vm_start;
  _26 = _24 - _25;
  _27 = stack_top_19 - mmap_min_addr.13_20;
  if (_26 >= _27)
    goto <bb 24>;
  else
    goto <bb 4>;

  <bb 4>:
  stack_shift_31 = _24 - stack_top_19;
  _32 = bprm_12(D)->p;
  _33 = _32 - stack_shift_31;
  bprm_12(D)->p = _33;
  mm_11->arg_start = _33;
  _36 = bprm_12(D)->loader;
  if (_36 != 0)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  _37 = _36 - stack_shift_31;
  bprm_12(D)->loader = _37;

  <bb 6>:
  _39 = bprm_12(D)->exec;
  _40 = _39 - stack_shift_31;
  bprm_12(D)->exec = _40;
  _42 = &mm_11->mmap_sem;
  down_write (_42);
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___86 : "p" &current_task);
  _44 = pfo_ret___86->personality;
  _45 = _44 & 4194304;
  if (_45 != 0)
    goto <bb 7>;
  else
    goto <bb 8>;

  <bb 7>:

  <bb 8>:
  # vm_flags_5 = PHI <1048951(7), 1048947(6)>
  if (executable_stack_46(D) == 2)
    goto <bb 11>;
  else
    goto <bb 9>;

  <bb 9>:
  if (executable_stack_46(D) == 1)
    goto <bb 11>;
  else
    goto <bb 10>;

  <bb 10>:

  <bb 11>:
  # vm_flags_2 = PHI <1048951(8), vm_flags_5(10), 1048947(9)>
  _50 = mm_11->def_flags;
  vm_flags_51 = _50 | 98304;
  vm_flags_52 = vm_flags_51 | vm_flags_2;
  _53 = vma_13->vm_end;
  _54 = vma_13->vm_start;
  _56 = mprotect_fixup (vma_13, &prev, _54, _53, vm_flags_52);
  ret_57 = (long unsigned int) _56;
  if (ret_57 != 0)
    goto <bb 12>;
  else
    goto <bb 13>;

  <bb 12>:
  pretmp_29 = _56;
  goto <bb 23> (out_unlock);

  <bb 13>:
  prev.15_58 = prev;
  if (vma_13 != prev.15_58)
    goto <bb 14>;
  else
    goto <bb 15>;

  <bb 14>:
  __asm__ __volatile__("1:	ud2
.pushsection __bug_table,"a"
2:	.long 1b - 2b, %c0 - 2b
	.word %c1, 0
	.org 2b+%c2
.popsection" :  : "i" "fs/exec.c", "i" 717, "i" 12);
  __builtin_unreachable ();

  <bb 15>:
  if (stack_shift_31 != 0)
    goto <bb 17>;
  else
    goto <bb 16>;

  <bb 16>:
  _65 = vma_13->vm_flags;
  _66 = _65 & 18446744073709453311;
  vma_13->vm_flags = _66;
  _68 = vma_13->vm_end;
  _69 = vma_13->vm_start;
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___87 : "p" &current_task);
  _88 = MEM[(const struct task_struct *)pfo_ret___87].signal;
  _89 ={v} MEM[(volatile __u64 *)_88].rlim[3].rlim_cur;
  rlim_stack_72 = _89 & 18446744073709547520;
  stack_size_70 = _68 + 131072;
  _73 = stack_size_70 - _69;
  if (rlim_stack_72 < _73)
    goto <bb 19>;
  else
    goto <bb 20>;

  <bb 17>:
  _63 = shift_arg_pages (vma_13, stack_shift_31);
  ret_64 = (long unsigned int) _63;
  if (ret_64 != 0)
    goto <bb 18>;
  else
    goto <bb 16>;

  <bb 18>:
  pretmp_28 = _63;
  goto <bb 23> (out_unlock);

  <bb 19>:
  stack_base_74 = _68 - rlim_stack_72;
  goto <bb 21>;

  <bb 20>:
  stack_base_75 = _69 + 18446744073709420544;

  <bb 21>:
  # stack_base_3 = PHI <stack_base_74(19), stack_base_75(20)>
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___90 : "p" &current_task);
  _76 = pfo_ret___90->mm;
  _77 = bprm_12(D)->p;
  _76->start_stack = _77;
  _80 = expand_stack (vma_13, stack_base_3);
  if (_80 != 0)
    goto <bb 22>;
  else
    goto <bb 23> (out_unlock);

  <bb 22>:

  # prephitmp_49 = PHI <pretmp_29(12), pretmp_28(18), _80(21), -14(22)>
out_unlock:
  up_write (_42);

  <bb 24>:
  # _4 = PHI <-12(3), prephitmp_49(23), -12(2)>
  prev ={v} {CLOBBER};
  return _4;

}



;; Function kernel_read (kernel_read, funcdef_no=2869, decl_uid=16294, cgraph_uid=2870)

kernel_read (struct file * file, loff_t offset, char * addr, long unsigned int count)
{
  long unsigned int old_fs$seg;
  u64 pfo_ret__;
  u64 pfo_ret__;
  u64 pfo_ret__;
  int result;
  loff_t pos;
  long int _9;
  long unsigned int _15;
  struct thread_info * _16;
  long unsigned int _18;
  struct thread_info * _19;
  long unsigned int _21;
  struct thread_info * _22;

  <bb 2>:
  pos = offset_2(D);
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___14 : "p" &cpu_tss.x86_tss.sp0);
  _15 = pfo_ret___14 + 18446744073709535232;
  _16 = (struct thread_info *) _15;
  old_fs$seg_12 = MEM[(struct thread_info *)_16 + 24B];
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___17 : "p" &cpu_tss.x86_tss.sp0);
  _18 = pfo_ret___17 + 18446744073709535232;
  _19 = (struct thread_info *) _18;
  _19->addr_limit.seg = 18446744073709551615;
  _9 = vfs_read (file_5(D), addr_6(D), count_7(D), &pos);
  result_10 = (int) _9;
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___20 : "p" &cpu_tss.x86_tss.sp0);
  _21 = pfo_ret___20 + 18446744073709535232;
  _22 = (struct thread_info *) _21;
  MEM[(struct thread_info *)_22 + 24B] = old_fs$seg_12;
  pos ={v} {CLOBBER};
  return result_10;

}



;; Function read_code (read_code, funcdef_no=2870, decl_uid=30486, cgraph_uid=2871)

read_code (struct file * file, long unsigned int addr, loff_t pos, size_t len)
{
  ssize_t res;
  char * addr.19;

  <bb 2>:
  addr.19_2 = (char *) addr_1(D);
  res_7 = vfs_read (file_4(D), addr.19_2, len_5(D), &pos);
  return res_7;

}



;; Function would_dump (would_dump, funcdef_no=2876, decl_uid=30463, cgraph_uid=2877)

would_dump (struct linux_binprm * bprm, struct file * file)
{
  struct inode * _4;
  int _6;
  unsigned int _8;
  unsigned int _9;

  <bb 2>:
  _4 = MEM[(const struct file *)file_3(D) + 32B];
  _6 = inode_permission (_4, 4);
  if (_6 < 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _8 = bprm_7(D)->interp_flags;
  _9 = _8 | 1;
  bprm_7(D)->interp_flags = _9;

  <bb 4>:
  return;

}



;; Function bprm_change_interp (bprm_change_interp, funcdef_no=2880, decl_uid=30471, cgraph_uid=2881)

bprm_change_interp (char * interp, struct linux_binprm * bprm)
{
  int _1;
  const char * _5;
  const char * _6;
  char * _10;

  <bb 2>:
  _5 = bprm_4(D)->interp;
  _6 = bprm_4(D)->filename;
  if (_5 != _6)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  kfree (_5);

  <bb 4>:
  _10 = kstrdup (interp_8(D), 208);
  bprm_4(D)->interp = _10;
  if (_10 == 0B)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:

  <bb 6>:
  # _1 = PHI <-12(5), 0(4)>
  return _1;

}



;; Function bprm_fill_uid (bprm_fill_uid, funcdef_no=2883, decl_uid=41065, cgraph_uid=2884)

bprm_fill_uid (struct linux_binprm * bprm)
{
  gid_t gid$val;
  uid_t uid$val;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct cred * _5;
  const struct cred * _6;
  struct cred * _8;
  const struct cred * _9;
  struct file * _11;
  struct vfsmount * _12;
  int _13;
  int _14;
  struct inode * _16;
  umode_t _17;
  short unsigned int _19;
  struct mutex * _20;
  short unsigned int _22;
  short unsigned int _24;
  unsigned int _25;
  unsigned int _26;
  struct cred * _28;
  unsigned int _30;
  unsigned int _31;
  struct cred * _33;
  long unsigned int _40;
  long unsigned int _41;
  short unsigned int _42;

  <bb 2>:
  _5 = bprm_4(D)->cred;
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___37 : "p" &current_task);
  _6 = pfo_ret___37->cred;
  _5->euid = _6->euid;
  _8 = bprm_4(D)->cred;
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___38 : "p" &current_task);
  _9 = pfo_ret___38->cred;
  _8->egid = _9->egid;
  _11 = bprm_4(D)->file;
  _12 = _11->f_path.mnt;
  _13 = _12->mnt_flags;
  _14 = _13 & 1;
  if (_14 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  goto <bb 10>;

  <bb 4>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___39 : "p" &current_task);
  _40 ={v} MEM[(const long unsigned int *)pfo_ret___39 + 976B];
  _41 = _40 & 1;
  if (_41 != 0)
    goto <bb 3>;
  else
    goto <bb 5>;

  <bb 5>:
  _16 = MEM[(const struct file *)_11 + 32B];
  _42 ={v} MEM[(volatile __u16 *)_16];
  _17 = _42 & 3072;
  if (_17 == 0)
    goto <bb 3>;
  else
    goto <bb 6>;

  <bb 6>:
  _20 = &_16->i_mutex;
  mutex_lock (_20);
  _22 = _16->i_mode;
  uid$val_36 = MEM[(struct inode *)_16 + 4B];
  gid$val_35 = MEM[(struct inode *)_16 + 8B];
  mutex_unlock (_20);
  _19 = _22 & 2048;
  if (_19 != 0)
    goto <bb 7>;
  else
    goto <bb 8>;

  <bb 7>:
  _25 = bprm_4(D)->per_clear;
  _26 = _25 | 7602176;
  bprm_4(D)->per_clear = _26;
  _28 = bprm_4(D)->cred;
  MEM[(struct cred *)_28 + 20B] = uid$val_36;

  <bb 8>:
  _24 = _22 & 1032;
  if (_24 == 1032)
    goto <bb 9>;
  else
    goto <bb 3>;

  <bb 9>:
  _30 = bprm_4(D)->per_clear;
  _31 = _30 | 7602176;
  bprm_4(D)->per_clear = _31;
  _33 = bprm_4(D)->cred;
  MEM[(struct cred *)_33 + 24B] = gid$val_35;

  <bb 10>:
  return;

}



;; Function audit_bprm (audit_bprm, funcdef_no=2495, decl_uid=35061, cgraph_uid=2495) (unlikely executed)

audit_bprm (struct linux_binprm * bprm)
{
  void * p;
  struct task_struct * pfo_ret__;
  int _10;

  <bb 2>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___8 : "p" &current_task);
  p_9 = pfo_ret___8->audit_context;
  if (p_9 == 0B)
    goto <bb 4>;
  else
    goto <bb 3>;

  <bb 3>:
  _10 = MEM[(int *)p_9];
  if (_10 != 0)
    goto <bb 4>;
  else
    goto <bb 5>;

  <bb 4>:
  return;

  <bb 5>:
  __audit_bprm (bprm_6(D));
  goto <bb 4>;

}



;; Function free_bprm (free_bprm, funcdef_no=2879, decl_uid=41035, cgraph_uid=2880)

free_bprm (struct linux_binprm * bprm)
{
  struct task_struct * pfo_ret__;
  struct cred * _6;
  struct signal_struct * _7;
  struct mutex * _8;
  struct cred * _10;
  struct file * _12;
  struct file * _14;
  const char * _16;
  const char * _17;
  struct inode * _21;
  struct atomic_t * _22;

  <bb 2>:
  _6 = bprm_5(D)->cred;
  if (_6 != 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___20 : "p" &current_task);
  _7 = pfo_ret___20->signal;
  _8 = &_7->cred_guard_mutex;
  mutex_unlock (_8);
  _10 = bprm_5(D)->cred;
  abort_creds (_10);

  <bb 4>:
  _12 = bprm_5(D)->file;
  if (_12 != 0B)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  _21 = MEM[(const struct file *)_12 + 32B];
  _22 = &_21->i_writecount;
  __asm__ __volatile__(".pushsection .smp_locks,"a"
.balign 4
.long 671f - .
.popsection
671:
	lock; incl %0" : "=m" _22->counter : "m" _22->counter);
  _14 = bprm_5(D)->file;
  fput (_14);

  <bb 6>:
  _16 = bprm_5(D)->interp;
  _17 = bprm_5(D)->filename;
  if (_16 != _17)
    goto <bb 7>;
  else
    goto <bb 8>;

  <bb 7>:
  kfree (_16);

  <bb 8>:
  kfree (bprm_5(D));
  return;

}



;; Function set_binfmt (set_binfmt, funcdef_no=2893, decl_uid=30481, cgraph_uid=2894)

set_binfmt (struct linux_binfmt * new)
{
  struct task_struct * pfo_ret__;
  struct mm_struct * mm;
  struct linux_binfmt * _5;
  struct module * _6;
  struct module * _10;

  <bb 2>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___12 : "p" &current_task);
  mm_4 = pfo_ret___12->mm;
  _5 = mm_4->binfmt;
  if (_5 != 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _6 = _5->module;
  module_put (_6);

  <bb 4>:
  mm_4->binfmt = new_8(D);
  if (new_8(D) != 0B)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  _10 = new_8(D)->module;
  __module_get (_10);

  <bb 6>:
  return;

}



;; Function acct_arg_size.isra.16 (acct_arg_size.isra.16, funcdef_no=2919, decl_uid=44049, cgraph_uid=1658)

acct_arg_size.isra.16 (long unsigned int * ISRA.316, long unsigned int pages)
{
  struct mm_struct * mm;
  long int diff;
  struct task_struct * pfo_ret__;
  long unsigned int _4;
  long unsigned int _6;
  _Bool _8;
  _Bool _9;
  _Bool _10;
  struct atomic_long_t * _11;

  <bb 2>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___1 : "p" &current_task);
  mm_2 = pfo_ret___1->mm;
  _4 = *ISRA.316_16(D);
  _6 = pages_5(D) - _4;
  diff_7 = (long int) _6;
  _8 = mm_2 == 0B;
  _9 = diff_7 == 0;
  _10 = _9 | _8;
  if (_10 != 0)
    goto <bb 4>;
  else
    goto <bb 3>;

  <bb 3>:
  *ISRA.316_16(D) = pages_5(D);
  _11 = &mm_2->rss_stat.count[1];
  __asm__ __volatile__(".pushsection .smp_locks,"a"
.balign 4
.long 671f - .
.popsection
671:
	lock; addq %1,%0" : "=m" MEM[(struct atomic64_t *)_11].counter : "er" diff_7, "m" MEM[(struct atomic64_t *)_11].counter);

  <bb 4>:
  return;

}



;; Function __register_binfmt (__register_binfmt, funcdef_no=2846, decl_uid=30442, cgraph_uid=2846)

__register_binfmt (struct linux_binfmt * fmt, int insert)
{
  int (*<T4b2d>) (struct linux_binprm *) _9;
  struct list_head * _17;
  struct list_head * _19;
  struct list_head * _22;
  struct list_head * _23;

  <bb 2>:
  if (fmt_4(D) == 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  __asm__ __volatile__("1:	ud2
.pushsection __bug_table,"a"
2:	.long 1b - 2b, %c0 - 2b
	.word %c1, 0
	.org 2b+%c2
.popsection" :  : "i" "fs/exec.c", "i" 76, "i" 12);
  __builtin_unreachable ();

  <bb 4>:
  _9 = fmt_4(D)->load_binary;
  if (_9 == 0B)
    goto <bb 5>;
  else
    goto <bb 10>;

  <bb 5>:
  warn_slowpath_null ("fs/exec.c", 77);
  goto <bb 9>;

  <bb 6>:
  _17 = &fmt_4(D)->lh;
  _22 = formats.next;
  _22->prev = _17;
  MEM[(struct list_head *)fmt_4(D)].next = _22;
  MEM[(struct list_head *)fmt_4(D)].prev = &formats;
  formats.next = _17;
  goto <bb 8>;

  <bb 7>:
  _19 = &fmt_4(D)->lh;
  _23 = formats.prev;
  formats.prev = _19;
  MEM[(struct list_head *)fmt_4(D)].next = &formats;
  MEM[(struct list_head *)fmt_4(D)].prev = _23;
  _23->next = _19;

  <bb 8>:
  __asm__ __volatile__("" :  :  : "memory");
  MEM[(volatile __u8 *)&binfmt_lock] ={v} 0;
  __asm__ __volatile__("" :  :  : "memory");

  <bb 9>:
  return;

  <bb 10>:
  _raw_write_lock (&binfmt_lock);
  if (insert_16(D) != 0)
    goto <bb 6>;
  else
    goto <bb 7>;

}



;; Function copy_strings.isra.27 (copy_strings.isra.27, funcdef_no=2930, decl_uid=44593, cgraph_uid=36)

copy_strings.isra.27 (int argc, bool ISRA.373, const char * const * ISRA.374, struct linux_binprm * bprm)
{
  struct page * page.11;
  struct page * page;
  int ret;
  long unsigned int size;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct page * kmapped_page;
  char * kaddr;
  long unsigned int kpos;
  int ret;
  const char * str;
  long unsigned int pos;
  int offset;
  int bytes_to_copy;
  long unsigned int __val_gu.6;
  long unsigned int __val_gu.7;
  const char * native;
  int __ret_gu;
  register long unsigned int __val_gu __asm__ (*%rdx);
  int __ret_gu;
  register long unsigned int __val_gu __asm__ (*%rdx);
  long unsigned int ptr.4;
  long unsigned int len.8;
  struct task_struct * pfo_ret__;
  long int page.12;
  long unsigned int n;
  long unsigned int _6;
  long unsigned int _7;
  const compat_uptr_t * _8;
  long unsigned int _11;
  void * _12;
  long unsigned int _13;
  long unsigned int _14;
  const char * const * _15;
  const char * _19;
  long unsigned int shifttmp_21;
  long int _24;
  long unsigned int _30;
  void * _32;
  long unsigned int _33;
  long unsigned int _34;
  long unsigned int _35;
  int _39;
  long unsigned int _40;
  unsigned int _42;
  int _43;
  int _50;
  unsigned int _54;
  long unsigned int _56;
  sizetype _58;
  long unsigned int _63;
  long int _67;
  long int _68;
  long long unsigned int _69;
  long long unsigned int _70;
  long unsigned int _71;
  sizetype _74;
  void * _76;
  unsigned int _77;
  struct mm_struct * _109;
  long int _111;
  struct vm_area_struct * _113;
  long unsigned int _114;
  long unsigned int _115;
  long unsigned int _117;
  long unsigned int * _118;
  struct signal_struct * _121;
  long unsigned int _122;
  long unsigned int _123;

  <bb 2>:
  goto <bb 30>;

  <bb 3>:
  if (ISRA.373_107(D) != 0)
    goto <bb 4>;
  else
    goto <bb 6>;

  <bb 4>:
  _6 = (long unsigned int) argc_5;
  _7 = _6 * 4;
  _8 = ISRA.374_108(D) + _7;
  __asm__ __volatile__("call __get_user_%P3" : "=a" __ret_gu_9, "=r" __val_gu : "0" _8, "i" 4);
  __val_gu.6_10 = __val_gu;
  if (__ret_gu_9 != 0)
    goto <bb 34>;
  else
    goto <bb 5>;

  <bb 5>:
  _11 = __val_gu.6_10 & 4294967295;
  _12 = (void *) _11;
  goto <bb 8>;

  <bb 6>:
  _13 = (long unsigned int) argc_5;
  _14 = _13 * 8;
  _15 = ISRA.374_108(D) + _14;
  __asm__ __volatile__("call __get_user_%P3" : "=a" __ret_gu_16, "=r" __val_gu : "0" _15, "i" 8);
  __val_gu.7_17 = __val_gu;
  if (__ret_gu_16 != 0)
    goto <bb 34>;
  else
    goto <bb 7>;

  <bb 7>:
  native_18 = (const char *) __val_gu.7_17;

  <bb 8>:
  # _19 = PHI <native_18(7), _12(5)>
  ptr.4_20 = (long unsigned int) _19;
  if (ptr.4_20 > 18446744073709547520)
    goto <bb 31> (out);
  else
    goto <bb 9>;

  <bb 9>:
  _24 = strnlen_user (_19, 131072);
  bytes_to_copy_25 = (int) _24;
  if (bytes_to_copy_25 == 0)
    goto <bb 31> (out);
  else
    goto <bb 10>;

  <bb 10>:
  len.8_26 = (long unsigned int) bytes_to_copy_25;
  if (len.8_26 > 131072)
    goto <bb 31> (out);
  else
    goto <bb 11>;

  <bb 11>:
  pos_28 = bprm_27(D)->p;
  str_29 = _19 + len.8_26;
  _30 = pos_28 - len.8_26;
  bprm_27(D)->p = _30;
  if (bytes_to_copy_25 > 0)
    goto <bb 12>;
  else
    goto <bb 29>;

  <bb 12>:

  <bb 13>:
  # pos_137 = PHI <pos_57(28), pos_28(12)>
  # bytes_to_copy_36 = PHI <bytes_to_copy_61(28), bytes_to_copy_25(12)>
  # str_37 = PHI <str_60(28), str_29(12)>
  # kmapped_page_44 = PHI <kmapped_page_82(28), kmapped_page_85(12)>
  # kpos_45 = PHI <kpos_84(28), kpos_87(12)>
  # kaddr_138 = PHI <kaddr_75(28), kaddr_86(12)>
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___31 : "p" &current_task);
  _32 = pfo_ret___31->stack;
  _33 ={v} MEM[(const long unsigned int *)_32 + 8B];
  _34 = _33 >> 2;
  _35 = _34 & 1;
  _39 = (int) _35;
  if (_39 != 0)
    goto <bb 14>;
  else
    goto <bb 35>;

  <bb 14>:
  _40 = MEM[(struct sigset_t *)pfo_ret___31 + 1584B].sig[0];
  shifttmp_21 = _40 & 256;
  if (shifttmp_21 != 0)
    goto <bb 31> (out);
  else
    goto <bb 35>;

  <bb 15>:

  <bb 16>:
  # bytes_to_copy_53 = PHI <bytes_to_copy_51(15), 4096(35)>
  bytes_to_copy_135 = MIN_EXPR <bytes_to_copy_53, bytes_to_copy_36>;
  offset_55 = bytes_to_copy_53 - bytes_to_copy_135;
  _56 = (long unsigned int) bytes_to_copy_135;
  pos_57 = pos_137 - _56;
  _58 = -_56;
  str_60 = str_37 + _58;
  bytes_to_copy_61 = bytes_to_copy_36 - bytes_to_copy_135;
  if (kmapped_page_44 == 0B)
    goto <bb 18>;
  else
    goto <bb 17>;

  <bb 17>:
  _63 = pos_57 & 18446744073709547520;
  if (_63 != kpos_45)
    goto <bb 18>;
  else
    goto <bb 26>;

  <bb 18>:
  _109 = bprm_27(D)->mm;
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___110 : "p" &current_task);
  _111 = get_user_pages (pfo_ret___110, _109, pos_57, 1, 1, 1, &page, 0B);
  ret_112 = (int) _111;
  if (ret_112 <= 0)
    goto <bb 36>;
  else
    goto <bb 19>;

  <bb 19>:
  _113 = bprm_27(D)->vma;
  _114 = _113->vm_end;
  _115 = _113->vm_start;
  size_116 = _114 - _115;
  _117 = size_116 >> 12;
  _118 = &MEM[(struct linux_binprm *)bprm_27(D) + 136B];
  acct_arg_size.isra.16 (_118, _117);
  if (size_116 <= 131072)
    goto <bb 20>;
  else
    goto <bb 21>;

  <bb 20>:
  kmapped_page_119 = page;
  page ={v} {CLOBBER};
  if (kmapped_page_119 == 0B)
    goto <bb 31> (out);
  else
    goto <bb 23>;

  <bb 21>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___120 : "p" &current_task);
  _121 = pfo_ret___120->signal;
  _122 ={v} MEM[(volatile __kernel_ulong_t *)_121 + 728B];
  _123 = _122 >> 2;
  if (size_116 > _123)
    goto <bb 22>;
  else
    goto <bb 20>;

  <bb 22>:
  page.11_124 = page;
  put_page (page.11_124);
  goto <bb 36>;

  <bb 23>:
  if (kmapped_page_44 != 0B)
    goto <bb 24>;
  else
    goto <bb 25>;

  <bb 24>:
  put_page (kmapped_page_44);

  <bb 25>:
  _cond_resched ();
  page.12_66 = (long int) kmapped_page_119;
  _67 = page.12_66 + 24189255811072;
  _68 = _67 /[ex] 64;
  _69 = (long long unsigned int) _68;
  _70 = _69 << 12;
  _71 = _70 + 18446612132314218496;
  kaddr_72 = (char *) _71;
  kpos_73 = pos_57 & 18446744073709547520;

  <bb 26>:
  # kmapped_page_82 = PHI <kmapped_page_44(17), kmapped_page_119(25)>
  # kaddr_75 = PHI <kaddr_138(17), kaddr_72(25)>
  # kpos_84 = PHI <kpos_45(17), kpos_73(25)>
  _74 = (sizetype) offset_55;
  _76 = kaddr_75 + _74;
  _77 = (unsigned int) bytes_to_copy_135;
  n_78 = _copy_from_user (_76, str_60, _77);
  if (n_78 != 0)
    goto <bb 32>;
  else
    goto <bb 27>;

  <bb 27>:
  if (bytes_to_copy_61 > 0)
    goto <bb 28>;
  else
    goto <bb 29>;

  <bb 28>:
  goto <bb 13>;

  <bb 29>:
  # kmapped_page_132 = PHI <kmapped_page_82(27), kmapped_page_85(11)>
  # kpos_46 = PHI <kpos_84(27), kpos_87(11)>
  # kaddr_38 = PHI <kaddr_75(27), kaddr_86(11)>

  <bb 30>:
  # argc_79 = PHI <argc_88(D)(2), argc_5(29)>
  # kmapped_page_85 = PHI <0B(2), kmapped_page_132(29)>
  # kaddr_86 = PHI <0B(2), kaddr_38(29)>
  # kpos_87 = PHI <0(2), kpos_46(29)>
  argc_5 = argc_79 + -1;
  _42 = (unsigned int) argc_5;
  _54 = _42 + 1;
  argc_41 = (int) _54;
  if (argc_41 > 0)
    goto <bb 3>;
  else
    goto <bb 31> (out);

  # kmapped_page_80 = PHI <kmapped_page_85(8), kmapped_page_85(9), kmapped_page_85(10), kmapped_page_44(14), kmapped_page_44(20), kmapped_page_44(36), kmapped_page_85(30), kmapped_page_85(34)>
  # ret_81 = PHI <-14(8), -14(9), -7(10), -514(14), -7(20), -7(36), 0(30), -14(34)>
out:
  if (kmapped_page_80 != 0B)
    goto <bb 32>;
  else
    goto <bb 33>;

  <bb 32>:
  # kmapped_page_4 = PHI <kmapped_page_80(31), kmapped_page_82(26)>
  # ret_22 = PHI <ret_81(31), -14(26)>
  put_page (kmapped_page_4);

  <bb 33>:
  # ret_23 = PHI <ret_81(31), ret_22(32)>
  return ret_23;

  <bb 34>:
  goto <bb 31> (out);

  <bb 35>:
  _cond_resched ();
  _50 = (int) pos_137;
  bytes_to_copy_51 = _50 & 4095;
  if (bytes_to_copy_51 == 0)
    goto <bb 16>;
  else
    goto <bb 15>;

  <bb 36>:
  page ={v} {CLOBBER};
  goto <bb 31> (out);

}



;; Function copy_strings_kernel (copy_strings_kernel, funcdef_no=2864, decl_uid=30475, cgraph_uid=2865)

copy_strings_kernel (int argc, const char * const * __argv, struct linux_binprm * bprm)
{
  long unsigned int oldfs$seg;
  u64 pfo_ret__;
  u64 pfo_ret__;
  u64 pfo_ret__;
  int r;
  long unsigned int _11;
  struct thread_info * _12;
  long unsigned int _14;
  struct thread_info * _15;
  long unsigned int _17;
  struct thread_info * _18;

  <bb 2>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___10 : "p" &cpu_tss.x86_tss.sp0);
  _11 = pfo_ret___10 + 18446744073709535232;
  _12 = (struct thread_info *) _11;
  oldfs$seg_9 = MEM[(struct thread_info *)_12 + 24B];
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___13 : "p" &cpu_tss.x86_tss.sp0);
  _14 = pfo_ret___13 + 18446744073709535232;
  _15 = (struct thread_info *) _14;
  _15->addr_limit.seg = 18446744073709551615;
  r_7 = copy_strings.isra.27 (argc_4(D), 0, __argv_2(D), bprm_5(D));
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___16 : "p" &cpu_tss.x86_tss.sp0);
  _17 = pfo_ret___16 + 18446744073709535232;
  _18 = (struct thread_info *) _17;
  MEM[(struct thread_info *)_18 + 24B] = oldfs$seg_9;
  return r_7;

}



;; Function load_mm_ldt (load_mm_ldt, funcdef_no=2685, decl_uid=38347, cgraph_uid=2685) (unlikely executed)

load_mm_ldt (struct mm_struct * mm)
{
  long unsigned int __ptr;
  int pscr_ret__;
  struct ldt_desc ldt;
  unsigned int cpu;
  long unsigned int addr.69;
  struct ldt_struct * ldt;
  int _9;
  unsigned int _10;
  struct desc_struct * _11;
  long long unsigned int _15;
  unsigned int _21;
  unsigned int _22;
  long unsigned int _25;
  long unsigned int _26;
  struct gdt_page * _27;
  short unsigned int _29;
  short unsigned int _30;
  long long unsigned int _31;
  unsigned char _32;
  unsigned int _35;
  <unnamed-unsigned:4> _37;
  long long unsigned int _38;
  long long unsigned int _39;
  unsigned char _40;
  long long unsigned int _41;
  unsigned int _42;

  <bb 2>:
  _15 ={v} MEM[(volatile __u64 *)mm_2(D) + 728B];
  ldt_5 = (struct ldt_struct *) _15;
  if (ldt_5 != 0B)
    goto <bb 3>;
  else
    goto <bb 6>;

  <bb 3>:
  _9 = ldt_5->size;
  _10 = (unsigned int) _9;
  _11 = ldt_5->entries;
  if (_10 == 0)
    goto <bb 4>;
  else
    goto <bb 5>;

  <bb 4>:
  __asm__ __volatile__("lldt %w0" :  : "q" 0);
  goto <bb 7>;

  <bb 5>:
  __asm__("movl %%gs:%1,%0" : "=r" pscr_ret___19 : "m" cpu_number);
  cpu_20 = (unsigned int) pscr_ret___19;
  _21 = _10 * 8;
  _22 = _21 + 4294967295;
  addr.69_23 = (long unsigned int) _11;
  memset (&ldt, 0, 16);
  _29 = (short unsigned int) _22;
  ldt.limit0 = _29;
  _30 = (short unsigned int) addr.69_23;
  ldt.base0 = _30;
  _31 = addr.69_23 >> 16;
  _32 = (unsigned char) _31;
  ldt.base1 = _32;
  ldt.type = 2;
  ldt.p = 1;
  _35 = _22 >> 16;
  _37 = (<unnamed-unsigned:4>) _35;
  ldt.limit1 = _37;
  _38 = _31 & 65535;
  _39 = _38 >> 8;
  _40 = (unsigned char) _39;
  ldt.base2 = _40;
  _41 = addr.69_23 >> 32;
  _42 = (unsigned int) _41;
  ldt.base3 = _42;
  __asm__("" : "=r" __ptr_24 : "0" &gdt_page);
  _25 = __per_cpu_offset[cpu_20];
  _26 = _25 + __ptr_24;
  _27 = (struct gdt_page *) _26;
  MEM[(char * {ref-all})_27 + 80B] = MEM[(char * {ref-all})&ldt];
  __asm__ __volatile__("lldt %w0" :  : "q" 80);
  ldt ={v} {CLOBBER};
  goto <bb 7>;

  <bb 6>:
  __asm__ __volatile__("lldt %w0" :  : "q" 0);

  <bb 7>:
  return;

}



;; Function ptrace_event.constprop.37 (ptrace_event.constprop.37, funcdef_no=2945, decl_uid=45403, cgraph_uid=1226) (unlikely executed)

ptrace_event.constprop.37 (long unsigned int message)
{
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  unsigned int _2;
  unsigned int _6;
  unsigned int _12;
  unsigned int _13;

  <bb 2>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___1 : "p" &current_task);
  _2 = pfo_ret___1->ptrace;
  _6 = _2 & 128;
  if (_6 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___19 : "p" &current_task);
  pfo_ret___19->ptrace_message = message_10(D);
  ptrace_notify (1029);
  goto <bb 6>;

  <bb 4>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___11 : "p" &current_task);
  _12 = pfo_ret___11->ptrace;
  _13 = _12 & 65537;
  if (_13 == 1)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___14 : "p" &current_task);
  send_sig (5, pfo_ret___14, 0);

  <bb 6>:
  return;

}



;; Function __raw_read_unlock.constprop.42 (__raw_read_unlock.constprop.42, funcdef_no=2940, decl_uid=45408, cgraph_uid=1922)

__raw_read_unlock.constprop.42 ()
{
  int __ret;

  <bb 2>:
  __asm__ __volatile__(".pushsection .smp_locks,"a"
.balign 4
.long 671f - .
.popsection
671:
	lock; xaddl %0, %1
" : "=r" __ret_2, "=m" MEM[(struct atomic_t *)&binfmt_lock].counter : "0" -256, "m" MEM[(struct atomic_t *)&binfmt_lock].counter : "cc", "memory", "memory");
  __asm__ __volatile__("" :  :  : "memory");
  return;

}



;; Function count.isra.25.constprop.43 (count.isra.25.constprop.43, funcdef_no=2939, decl_uid=45409, cgraph_uid=2216)

count.isra.25.constprop.43 (bool ISRA.364, const char * const * ISRA.365)
{
  struct task_struct * pfo_ret__;
  long unsigned int ptr.4;
  register long unsigned int __val_gu __asm__ (*%rdx);
  int __ret_gu;
  register long unsigned int __val_gu __asm__ (*%rdx);
  int __ret_gu;
  const char * native;
  long unsigned int __val_gu.7;
  long unsigned int __val_gu.6;
  int i;
  long unsigned int _8;
  long unsigned int _9;
  const compat_uptr_t * _10;
  long unsigned int _13;
  void * _14;
  long unsigned int _15;
  long unsigned int _16;
  const char * const * _17;
  const char * _21;
  long unsigned int shifttmp_23;
  void * _28;
  long unsigned int _29;
  long unsigned int _30;
  long unsigned int _31;
  int _35;
  long unsigned int _36;
  int _39;
  int _45;

  <bb 2>:
  if (ISRA.365_1(D) != 0B)
    goto <bb 3>;
  else
    goto <bb 14>;

  <bb 3>:

  <bb 4>:
  # i_7 = PHI <0(3), i_26(16)>
  if (ISRA.364_3(D) != 0)
    goto <bb 5>;
  else
    goto <bb 7>;

  <bb 5>:
  _8 = (long unsigned int) i_7;
  _9 = _8 * 4;
  _10 = ISRA.365_1(D) + _9;
  __asm__ __volatile__("call __get_user_%P3" : "=a" __ret_gu_11, "=r" __val_gu : "0" _10, "i" 4);
  __val_gu.6_12 = __val_gu;
  if (__ret_gu_11 != 0)
    goto <bb 15>;
  else
    goto <bb 6>;

  <bb 6>:
  _13 = __val_gu.6_12 & 4294967295;
  _14 = (void *) _13;
  goto <bb 9>;

  <bb 7>:
  _15 = (long unsigned int) i_7;
  _16 = _15 * 8;
  _17 = ISRA.365_1(D) + _16;
  __asm__ __volatile__("call __get_user_%P3" : "=a" __ret_gu_18, "=r" __val_gu : "0" _17, "i" 8);
  __val_gu.7_19 = __val_gu;
  if (__ret_gu_18 != 0)
    goto <bb 15>;
  else
    goto <bb 8>;

  <bb 8>:
  native_20 = (const char *) __val_gu.7_19;

  <bb 9>:
  # _21 = PHI <native_20(8), _14(6)>
  if (_21 == 0B)
    goto <bb 14>;
  else
    goto <bb 10>;

  <bb 10>:
  ptr.4_22 = (long unsigned int) _21;
  if (ptr.4_22 > 18446744073709547520)
    goto <bb 14>;
  else
    goto <bb 11>;

  <bb 11>:
  if (i_7 == 2147483647)
    goto <bb 14>;
  else
    goto <bb 12>;

  <bb 12>:
  i_26 = i_7 + 1;
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___27 : "p" &current_task);
  _28 = pfo_ret___27->stack;
  _29 ={v} MEM[(const long unsigned int *)_28 + 8B];
  _30 = _29 >> 2;
  _31 = _30 & 1;
  _35 = (int) _31;
  if (_35 != 0)
    goto <bb 13>;
  else
    goto <bb 16>;

  <bb 13>:
  _36 = MEM[(struct sigset_t *)pfo_ret___27 + 1584B].sig[0];
  shifttmp_23 = _36 & 256;
  if (shifttmp_23 != 0)
    goto <bb 14>;
  else
    goto <bb 16>;

  <bb 14>:
  # _45 = PHI <-14(10), -7(11), -514(13), i_7(9), 0(2), -14(15)>
  return _45;

  <bb 15>:
  goto <bb 14>;

  <bb 16>:
  _cond_resched ();
  goto <bb 4>;

}



;; Function check_unsafe_exec.isra.21 (check_unsafe_exec.isra.21, funcdef_no=2924, decl_uid=44123, cgraph_uid=2632)

check_unsafe_exec.isra.21 (int * ISRA.323)
{
  struct task_struct * t;
  unsigned int n_fs;
  struct task_struct * pfo_ret__;
  const struct list_head * __mptr;
  struct list_head * __ptr;
  struct list_head * __ptr.152;
  unsigned int _2;
  unsigned int _3;
  int _5;
  int _6;
  int _7;
  int _8;
  long unsigned int _10;
  long unsigned int _11;
  int _12;
  int _13;
  struct fs_struct * _14;
  struct raw_spinlock * _15;
  struct fs_struct * _17;
  struct fs_struct * _18;
  long long unsigned int _23;
  struct fs_struct * _25;
  int _26;
  unsigned int _27;
  int _28;
  int _29;
  struct fs_struct * _30;

  <bb 2>:
  __asm__("movq %%gs:%P1,%0" : "=r" t_1 : "p" &current_task);
  _2 = t_1->ptrace;
  if (_2 != 0)
    goto <bb 3>;
  else
    goto <bb 6>;

  <bb 3>:
  _3 = _2 & 4;
  if (_3 != 0)
    goto <bb 4>;
  else
    goto <bb 5>;

  <bb 4>:
  _5 = *ISRA.323_50(D);
  _6 = _5 | 4;
  *ISRA.323_50(D) = _6;
  goto <bb 6>;

  <bb 5>:
  _7 = *ISRA.323_50(D);
  _8 = _7 | 2;
  *ISRA.323_50(D) = _8;

  <bb 6>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___9 : "p" &current_task);
  _10 ={v} MEM[(const long unsigned int *)pfo_ret___9 + 976B];
  _11 = _10 & 1;
  if (_11 != 0)
    goto <bb 7>;
  else
    goto <bb 8>;

  <bb 7>:
  _12 = *ISRA.323_50(D);
  _13 = _12 | 8;
  *ISRA.323_50(D) = _13;

  <bb 8>:
  _14 = t_1->fs;
  _15 = &MEM[(struct spinlock_t *)_14 + 4B].D.5408.rlock;
  _raw_spin_lock (_15);
  __asm__ __volatile__("" :  :  : "memory");
  goto <bb 12>;

  <bb 9>:
  _17 = MEM[(struct task_struct *)__mptr_16 + -1200B].fs;
  _18 = t_1->fs;
  if (_17 == _18)
    goto <bb 10>;
  else
    goto <bb 11>;

  <bb 10>:
  n_fs_20 = n_fs_19 + 1;

  <bb 11>:
  # n_fs_32 = PHI <n_fs_19(9), n_fs_20(10)>

  <bb 12>:
  # t_21 = PHI <t_24(11), t_1(8)>
  # n_fs_19 = PHI <n_fs_32(11), 1(8)>
  __ptr.152_22 = MEM[(const struct task_struct *)t_21].thread_group.next;
  __ptr = __ptr.152_22;
  _23 ={v} MEM[(volatile __u64 *)&__ptr];
  __mptr_16 = (const struct list_head *) _23;
  __ptr ={v} {CLOBBER};
  t_24 = &MEM[(void *)__mptr_16 + -1200B];
  if (t_1 != t_24)
    goto <bb 9>;
  else
    goto <bb 13>;

  <bb 13>:
  # n_fs_54 = PHI <n_fs_19(12)>
  __asm__ __volatile__("" :  :  : "memory");
  _25 = t_1->fs;
  _26 = _25->users;
  _27 = (unsigned int) _26;
  if (_27 > n_fs_54)
    goto <bb 14>;
  else
    goto <bb 15>;

  <bb 14>:
  _28 = *ISRA.323_50(D);
  _29 = _28 | 1;
  *ISRA.323_50(D) = _29;
  goto <bb 16>;

  <bb 15>:
  _25->in_exec = 1;

  <bb 16>:
  _30 = t_1->fs;
  __asm__ __volatile__("" :  :  : "memory");
  MEM[(volatile __u8 *)_30 + 4B] ={v} 0;
  __asm__ __volatile__("" :  :  : "memory");
  return;

}



;; Function get_task_comm (get_task_comm, funcdef_no=2873, decl_uid=23336, cgraph_uid=2874)

get_task_comm (char * buf, struct task_struct * tsk)
{
  char[16] * _4;
  struct raw_spinlock * _8;

  <bb 2>:
  _8 = &MEM[(struct spinlock_t *)tsk_2(D) + 1680B].D.5408.rlock;
  _raw_spin_lock (_8);
  _4 = &tsk_2(D)->comm;
  strncpy (buf_5(D), _4, 16);
  __asm__ __volatile__("" :  :  : "memory");
  MEM[(volatile __u8 *)tsk_2(D) + 1680B] ={v} 0;
  __asm__ __volatile__("" :  :  : "memory");
  return buf_5(D);

}



;; Function remove_arg_zero (remove_arg_zero, funcdef_no=2885, decl_uid=30454, cgraph_uid=2886)

remove_arg_zero (struct linux_binprm * bprm)
{
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct page * page;
  int ret;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  long int page.12;
  long unsigned int offset;
  int ret;
  int _1;
  int _7;
  long unsigned int _12;
  int _16;
  int _17;
  long int _19;
  long int _20;
  long long unsigned int _21;
  long long unsigned int _22;
  long unsigned int _23;
  long unsigned int _27;
  long unsigned int _28;
  char _30;
  long unsigned int _31;
  long unsigned int _32;
  int _33;
  int _34;
  struct mm_struct * _37;
  long int _39;
  sizetype _41;
  struct page * _53;
  int _56;
  int _57;
  int _59;

  <bb 2>:
  _7 = bprm_6(D)->argc;
  if (_7 == 0)
    goto <bb 16>;
  else
    goto <bb 3>;

  <bb 3>:

  <bb 4>:
  _12 = bprm_6(D)->p;
  offset_13 = _12 & 4095;
  _37 = bprm_6(D)->mm;
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___38 : "p" &current_task);
  _39 = get_user_pages (pfo_ret___38, _37, _12, 1, 0, 1, &page, 0B);
  ret_40 = (int) _39;
  if (ret_40 <= 0)
    goto <bb 17>;
  else
    goto <bb 5>;

  <bb 5>:
  _53 = page;
  page ={v} {CLOBBER};
  if (_53 == 0B)
    goto <bb 15> (out);
  else
    goto <bb 6>;

  <bb 6>:
  __asm__ __volatile__("" :  :  : "memory");
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___15 : "p" &current_task);
  _16 = pfo_ret___15->pagefault_disabled;
  _17 = _16 + 1;
  pfo_ret___15->pagefault_disabled = _17;
  __asm__ __volatile__("" :  :  : "memory");
  page.12_18 = (long int) _53;
  _19 = page.12_18 + 24189255811072;
  _20 = _19 /[ex] 64;
  _21 = (long long unsigned int) _20;
  _22 = _21 << 12;
  _23 = _22 + 18446612132314218496;
  goto <bb 9>;

  <bb 7>:
  offset_26 = offset_70 + 1;
  _27 = bprm_6(D)->p;
  _28 = _27 + 1;
  bprm_6(D)->p = _28;
  if (offset_26 != 4096)
    goto <bb 8>;
  else
    goto <bb 10>;

  <bb 8>:

  <bb 9>:
  # offset_70 = PHI <offset_26(8), offset_13(6)>
  _41 = _23 + offset_70;
  _30 = MEM[base: 0B, base: _41, offset: 0B];
  if (_30 != 0)
    goto <bb 7>;
  else
    goto <bb 10>;

  <bb 10>:
  # offset_68 = PHI <offset_70(9), offset_26(7)>
  __asm__ __volatile__("" :  :  : "memory");
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___55 : "p" &current_task);
  _56 = pfo_ret___55->pagefault_disabled;
  _57 = _56 + -1;
  pfo_ret___55->pagefault_disabled = _57;
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___58 : "p" &current_task);
  _59 = pfo_ret___58->pagefault_disabled;
  if (_59 < 0)
    goto <bb 11>;
  else
    goto <bb 12>;

  <bb 11>:
  warn_slowpath_null ("include/linux/uaccess.h", 15);

  <bb 12>:
  __asm__ __volatile__("" :  :  : "memory");
  put_page (_53);
  if (offset_68 == 4096)
    goto <bb 13>;
  else
    goto <bb 14>;

  <bb 13>:
  goto <bb 4>;

  <bb 14>:
  _31 = bprm_6(D)->p;
  _32 = _31 + 1;
  bprm_6(D)->p = _32;
  _33 = bprm_6(D)->argc;
  _34 = _33 + -1;
  bprm_6(D)->argc = _34;

  # ret_36 = PHI <-14(5), 0(14), -14(17)>
out:

  <bb 16>:
  # _1 = PHI <_7(2), ret_36(15)>
  return _1;

  <bb 17>:
  page ={v} {CLOBBER};
  goto <bb 15> (out);

}



;; Function bprm_mm_init (bprm_mm_init, funcdef_no=2860, decl_uid=40793, cgraph_uid=2861)

bprm_mm_init (struct linux_binprm * bprm)
{
  struct kmem_cache * vm_area_cachep.157;
  long unsigned int iftmp.158;
  int err;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct mm_struct * mm;
  int _2;
  void * _17;
  struct rw_semaphore * _18;
  unsigned int _21;
  unsigned int _22;
  struct list_head * _24;
  long unsigned int _26;
  long unsigned int _27;
  struct atomic_t * _30;
  int _57;

  <bb 2>:
  mm_8 = mm_alloc ();
  bprm_9(D)->mm = mm_8;
  if (mm_8 == 0B)
    goto <bb 10>;
  else
    goto <bb 3>;

  <bb 3>:
  vm_area_cachep.157_16 = vm_area_cachep;
  _17 = kmem_cache_alloc (vm_area_cachep.157_16, 32976);
  bprm_9(D)->vma = _17;
  if (_17 == 0B)
    goto <bb 11>;
  else
    goto <bb 4>;

  <bb 4>:
  _18 = &mm_8->mmap_sem;
  down_write (_18);
  MEM[(struct vm_area_struct *)_17].vm_mm = mm_8;
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___19 : "p" &current_task);
  MEM[(struct vm_area_struct *)_17].vm_end = 140737488351232;
  MEM[(struct vm_area_struct *)_17].vm_start = 140737488347136;
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___20 : "p" &current_task);
  _21 = pfo_ret___20->personality;
  _22 = _21 & 4194304;
  if (_22 != 0)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:

  <bb 6>:
  # iftmp.158_23 = PHI <1147255(5), 1147251(4)>
  MEM[(struct vm_area_struct *)_17].vm_flags = iftmp.158_23;
  MEM[(struct vm_area_struct *)_17].vm_page_prot = vm_get_page_prot (iftmp.158_23);
  _24 = &MEM[(struct vm_area_struct *)_17].anon_vma_chain;
  MEM[(struct list_head *)_17 + 120B].next = _24;
  MEM[(struct list_head *)_17 + 120B].prev = _24;
  err_25 = insert_vm_struct (mm_8, _17);
  if (err_25 != 0)
    goto <bb 8> (err);
  else
    goto <bb 7>;

  <bb 7>:
  mm_8->total_vm = 1;
  mm_8->stack_vm = 1;
  up_write (_18);
  _26 = MEM[(struct vm_area_struct *)_17].vm_end;
  _27 = _26 + 18446744073709551608;
  bprm_9(D)->p = _27;
  goto <bb 10>;

err:
  up_write (_18);
  bprm_9(D)->vma = 0B;
  vm_area_cachep.157_28 = vm_area_cachep;
  kmem_cache_free (vm_area_cachep.157_28, _17);
  goto <bb 11>;

  <bb 9>:
  __asm__ __volatile__("");

  <bb 10>:
  # _2 = PHI <0(7), _57(12), -12(2), _57(9)>
  return _2;

  <bb 11>:
  # _57 = PHI <err_25(8), -12(3)>
  bprm_9(D)->mm = 0B;
  _30 = &mm_8->mm_count;
  __asm__ __volatile__ goto(".pushsection .smp_locks,"a"
.balign 4
.long 671f - .
.popsection
671:
	lock; decl %0; je %l1" :  : "m" _30->counter : "memory" : "cc_label" <L9>);
  goto <bb 9>;

<L9>:
  __mmdrop (mm_8);
  goto <bb 10>;

}



;; Function flush_old_exec (flush_old_exec, funcdef_no=2875, decl_uid=30458, cgraph_uid=2876)

flush_old_exec (struct linux_binprm * bprm)
{
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  u64 pfo_ret__;
  long unsigned int cr4;
  long unsigned int cr4;
  void (*<T5858>) (void *, int, long unsigned int) it_func.49;
  struct tracepoint_func * it_func_ptr;
  void * __data;
  unsigned int cpu.38;
  int oldbit;
  int pscr_ret__;
  const struct cpumask * cpu_online_mask.41;
  long unsigned int cr4;
  long unsigned int cr4;
  void (*<T5858>) (void *, int, long unsigned int) it_func.49;
  struct tracepoint_func * it_func_ptr;
  void * __data;
  unsigned int cpu.38;
  int oldbit;
  int pscr_ret__;
  const struct cpumask * cpu_online_mask.41;
  long unsigned int pgdir.39;
  long unsigned int x;
  long unsigned int y;
  long unsigned int iftmp.40;
  int oldbit;
  long unsigned int pgdir.39;
  long unsigned int x;
  long unsigned int y;
  long unsigned int iftmp.40;
  struct mm_struct * pscr_ret__;
  int pscr_ret__;
  unsigned int cpu;
  struct task_struct * tsk;
  struct mm_struct * old_mm;
  struct mm_struct * active_mm;
  struct task_struct * pfo_ret__;
  long unsigned int _max1;
  long int val;
  long int val;
  struct kmem_cache * sighand_cachep.26;
  struct signal_struct * sig;
  struct sighand_struct * oldsighand;
  struct task_struct * leader;
  struct sighand_struct * newsighand;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  int __ret;
  struct task_struct * pfo_ret__;
  int _2;
  long unsigned int[1] * _4;
  struct file * _9;
  struct mm_struct * _10;
  long unsigned int * _12;
  struct mm_struct * _14;
  struct list_head * _22;
  struct list_head * _23;
  struct raw_spinlock * _24;
  struct task_struct * _25;
  unsigned int _26;
  unsigned int _27;
  int _29;
  int _30;
  int _31;
  long unsigned int _33;
  int _36;
  void * prephitmp_40;
  int _44;
  int _45;
  int _47;
  long unsigned int _52;
  int _55;
  void * prephitmp_59;
  long long unsigned int _63;
  long long unsigned int _64;
  struct signal_struct * _65;
  struct signal_struct * _66;
  struct pid * _70;
  struct pid * _71;
  int _75;
  struct pid * _76;
  struct list_head * _77;
  struct list_head * _78;
  struct list_head * _79;
  long long unsigned int _80;
  struct list_head * _81;
  struct list_head * _82;
  struct list_head * _83;
  struct list_head * _84;
  struct list_head * _85;
  struct list_head * _86;
  int _87;
  unsigned int _91;
  struct task_struct * _95;
  int _96;
  struct k_sigaction[64] * _99;
  struct k_sigaction[64] * _100;
  struct raw_spinlock * _101;
  long long unsigned int _102;
  int _103;
  struct rw_semaphore * _112;
  struct core_state * _113;
  struct raw_spinlock * _117;
  struct mm_struct * _119;
  struct vm_area_struct *[4] * _120;
  struct rw_semaphore * _121;
  struct signal_struct * _125;
  int prephitmp_128;
  long unsigned int _129;
  long unsigned int _132;
  long unsigned int _133;
  long unsigned int _134;
  long unsigned int _135;
  struct pgd_t * _143;
  struct ldt_struct * _150;
  struct ldt_struct * _151;
  const long unsigned int[1] * _159;
  long int _160;
  int _162;
  struct pgd_t * _163;
  long unsigned int[1] * _169;
  long int _170;
  void * pretmp_171;
  const long unsigned int[1] * _182;
  long int _184;
  long long unsigned int _186;
  void * _193;
  int _207;
  long unsigned int _209;
  long unsigned int _211;
  void * pretmp_214;
  long unsigned int shifttmp_217;
  long unsigned int shifttmp_220;
  const long unsigned int[1] * _225;
  long int _227;
  long long unsigned int _229;
  void * _236;
  int _239;
  long unsigned int _241;
  long unsigned int _243;
  struct atomic_t * _244;
  long unsigned int _250;
  struct thread_info * _251;
  unsigned int _253;
  unsigned int _254;
  unsigned int _256;
  unsigned int _257;
  unsigned int _258;
  unsigned int _259;

  <bb 2>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___18 : "p" &current_task);
  sig_20 = pfo_ret___18->signal;
  oldsighand_21 = pfo_ret___18->sighand;
  _22 = &pfo_ret___18->thread_group;
  _23 = MEM[(const struct list_head *)pfo_ret___18 + 1200B].next;
  if (_22 == _23)
    goto <bb 26> (no_thread_group);
  else
    goto <bb 3>;

  <bb 3>:
  _24 = &MEM[(struct spinlock_t *)oldsighand_21 + 2056B].D.5408.rlock;
  _raw_spin_lock_irq (_24);
  _25 = MEM[(const struct signal_struct *)sig_20 + 96B];
  _26 = MEM[(const struct signal_struct *)sig_20 + 108B];
  _27 = _26 & 4;
  if (_27 != 0)
    goto <bb 80>;
  else
    goto <bb 4>;

  <bb 4>:
  if (_25 != 0B)
    goto <bb 80>;
  else
    goto <bb 81>;

  <bb 5>:
  _31 = _29 + -1;
  sig_20->notify_count = _31;

  <bb 6>:
  # prephitmp_128 = PHI <_29(81), _31(5)>
  if (prephitmp_128 != 0)
    goto <bb 8>;
  else
    goto <bb 7>;

  <bb 7>:
  __asm__ __volatile__("" :  :  : "memory");
  MEM[(volatile __u8 *)oldsighand_21 + 2056B] ={v} 0;
  __asm__ __volatile__("sti" :  :  : "memory");
  __asm__ __volatile__("" :  :  : "memory");
  _45 = pfo_ret___18->exit_signal;
  if (_45 < 0)
    goto <bb 12>;
  else
    goto <bb 25>;

  <bb 8>:

  <bb 9>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___32 : "p" &current_task);
  pfo_ret___32->state ={v} 130;
  __asm__ __volatile__("" :  :  : "memory");
  MEM[(volatile __u8 *)oldsighand_21 + 2056B] ={v} 0;
  __asm__ __volatile__("sti" :  :  : "memory");
  __asm__ __volatile__("" :  :  : "memory");
  schedule ();
  _33 = MEM[(struct sigset_t *)pfo_ret___18 + 1584B].sig[0];
  shifttmp_217 = _33 & 256;
  if (shifttmp_217 != 0)
    goto <bb 31>;
  else
    goto <bb 10>;

  <bb 10>:
  _raw_spin_lock_irq (_24);
  _44 = sig_20->notify_count;
  if (_44 != 0)
    goto <bb 11>;
  else
    goto <bb 7>;

  <bb 11>:
  goto <bb 9>;

  <bb 12>:
  leader_46 = pfo_ret___18->group_leader;

  <bb 13>:
  _cond_resched ();
  cgroup_threadgroup_change_begin (pfo_ret___18);
  _raw_write_lock_irq (&tasklist_lock);
  sig_20->notify_count = -1;
  _47 = leader_46->exit_state;
  if (_47 != 0)
    goto <bb 16>;
  else
    goto <bb 14>;

  <bb 14>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___51 : "p" &current_task);
  pfo_ret___51->state ={v} 130;
  __asm__ __volatile__("" :  :  : "memory");
  MEM[(volatile __u8 *)&tasklist_lock] ={v} 0;
  __asm__ __volatile__("sti" :  :  : "memory");
  __asm__ __volatile__("" :  :  : "memory");
  cgroup_threadgroup_change_end (pfo_ret___18);
  schedule ();
  _52 = MEM[(struct sigset_t *)pfo_ret___18 + 1584B].sig[0];
  shifttmp_220 = _52 & 256;
  if (shifttmp_220 != 0)
    goto <bb 31>;
  else
    goto <bb 15>;

  <bb 15>:
  goto <bb 13>;

  <bb 16>:
  _63 = leader_46->start_time;
  pfo_ret___18->start_time = _63;
  _64 = leader_46->real_start_time;
  pfo_ret___18->real_start_time = _64;
  _65 = leader_46->signal;
  _66 = pfo_ret___18->signal;
  if (_65 != _66)
    goto <bb 17>;
  else
    goto <bb 18>;

  <bb 17>:
  __asm__ __volatile__("1:	ud2
.pushsection __bug_table,"a"
2:	.long 1b - 2b, %c0 - 2b
	.word %c1, 0
	.org 2b+%c2
.popsection" :  : "i" "fs/exec.c", "i" 969, "i" 12);
  __builtin_unreachable ();

  <bb 18>:
  _70 = pfo_ret___18->pids[0].pid;
  _71 = _65->leader_pid;
  if (_70 == _71)
    goto <bb 19>;
  else
    goto <bb 20>;

  <bb 19>:
  __asm__ __volatile__("1:	ud2
.pushsection __bug_table,"a"
2:	.long 1b - 2b, %c0 - 2b
	.word %c1, 0
	.org 2b+%c2
.popsection" :  : "i" "fs/exec.c", "i" 970, "i" 12);
  __builtin_unreachable ();

  <bb 20>:
  _75 = leader_46->pid;
  pfo_ret___18->pid = _75;
  _76 = leader_46->pids[0].pid;
  change_pid (pfo_ret___18, 0, _76);
  transfer_pid (leader_46, pfo_ret___18, 1);
  transfer_pid (leader_46, pfo_ret___18, 2);
  _77 = &pfo_ret___18->tasks;
  _78 = MEM[(struct list_head *)leader_46 + 792B].next;
  MEM[(struct list_head *)pfo_ret___18 + 792B].next = _78;
  _79 = MEM[(struct list_head *)leader_46 + 792B].prev;
  MEM[(struct list_head *)pfo_ret___18 + 792B].prev = _79;
  __asm__ __volatile__("" :  :  : "memory");
  _80 = (long long unsigned int) _77;
  _81 = MEM[(struct list_head *)pfo_ret___18 + 792B].prev;
  MEM[(volatile __u64 *)_81] ={v} _80;
  _82 = MEM[(struct list_head *)pfo_ret___18 + 792B].next;
  _82->prev = _77;
  MEM[(struct list_head *)leader_46 + 792B].prev = -2401263026318605824B;
  _83 = &pfo_ret___18->sibling;
  _84 = &leader_46->sibling;
  _85 = MEM[(struct list_head *)leader_46 + 1072B].next;
  MEM[(struct list_head *)pfo_ret___18 + 1072B].next = _85;
  _85->prev = _83;
  _86 = MEM[(struct list_head *)leader_46 + 1072B].prev;
  MEM[(struct list_head *)pfo_ret___18 + 1072B].prev = _86;
  _86->next = _83;
  MEM[(struct list_head *)leader_46 + 1072B].next = _84;
  MEM[(struct list_head *)leader_46 + 1072B].prev = _84;
  pfo_ret___18->group_leader = pfo_ret___18;
  leader_46->group_leader = pfo_ret___18;
  pfo_ret___18->exit_signal = 17;
  leader_46->exit_signal = -1;
  _87 = leader_46->exit_state;
  if (_87 != 32)
    goto <bb 21>;
  else
    goto <bb 22>;

  <bb 21>:
  __asm__ __volatile__("1:	ud2
.pushsection __bug_table,"a"
2:	.long 1b - 2b, %c0 - 2b
	.word %c1, 0
	.org 2b+%c2
.popsection" :  : "i" "fs/exec.c", "i" 997, "i" 12);
  __builtin_unreachable ();

  <bb 22>:
  leader_46->exit_state = 16;
  _91 = leader_46->ptrace;
  if (_91 != 0)
    goto <bb 23>;
  else
    goto <bb 24>;

  <bb 23>:
  _95 = leader_46->parent;
  __wake_up_parent (leader_46, _95);

  <bb 24>:
  __asm__ __volatile__("" :  :  : "memory");
  MEM[(volatile __u8 *)&tasklist_lock] ={v} 0;
  __asm__ __volatile__("sti" :  :  : "memory");
  __asm__ __volatile__("" :  :  : "memory");
  cgroup_threadgroup_change_end (pfo_ret___18);
  release_task (leader_46);

  <bb 25>:
  sig_20->group_exit_task = 0B;
  sig_20->notify_count = 0;

no_thread_group:
  pfo_ret___18->exit_signal = 17;
  exit_itimers (sig_20);
  flush_itimer_signals ();
  _96 ={v} MEM[(const int *)oldsighand_21];
  if (_96 != 1)
    goto <bb 27>;
  else
    goto <bb 29>;

  <bb 27>:
  sighand_cachep.26_97 = sighand_cachep;
  newsighand_98 = kmem_cache_alloc (sighand_cachep.26_97, 208);
  if (newsighand_98 == 0B)
    goto <bb 82>;
  else
    goto <bb 28>;

  <bb 28>:
  MEM[(struct atomic_t *)newsighand_98].counter = 1;
  _99 = &oldsighand_21->action;
  _100 = &newsighand_98->action;
  memcpy (_100, _99, 2048);
  _raw_write_lock_irq (&tasklist_lock);
  _101 = &MEM[(struct spinlock_t *)oldsighand_21 + 2056B].D.5408.rlock;
  _raw_spin_lock (_101);
  __asm__ __volatile__("" :  :  : "memory");
  _102 = (long long unsigned int) newsighand_98;
  MEM[(volatile __u64 *)pfo_ret___18 + 1536B] ={v} _102;
  __asm__ __volatile__("" :  :  : "memory");
  MEM[(volatile __u8 *)oldsighand_21 + 2056B] ={v} 0;
  __asm__ __volatile__("" :  :  : "memory");
  __asm__ __volatile__("" :  :  : "memory");
  MEM[(volatile __u8 *)&tasklist_lock] ={v} 0;
  __asm__ __volatile__("sti" :  :  : "memory");
  __asm__ __volatile__("" :  :  : "memory");
  __cleanup_sighand (oldsighand_21);

  <bb 29>:
  _103 = pfo_ret___18->exit_signal;
  if (_103 < 0)
    goto <bb 30>;
  else
    goto <bb 83>;

  <bb 30>:
  __asm__ __volatile__("1:	ud2
.pushsection __bug_table,"a"
2:	.long 1b - 2b, %c0 - 2b
	.word %c1, 0
	.org 2b+%c2
.popsection" :  : "i" "fs/exec.c", "i" 1046, "i" 12);
  __builtin_unreachable ();

  <bb 31>:
  _raw_read_lock (&tasklist_lock);
  sig_20->group_exit_task = 0B;
  sig_20->notify_count = 0;
  __asm__ __volatile__(".pushsection .smp_locks,"a"
.balign 4
.long 671f - .
.popsection
671:
	lock; xaddl %0, %1
" : "=r" __ret_107, "=m" MEM[(struct atomic_t *)&tasklist_lock].counter : "0" -256, "m" MEM[(struct atomic_t *)&tasklist_lock].counter : "cc", "memory", "memory");
  __asm__ __volatile__("" :  :  : "memory");
  goto <bb 82>;

  <bb 32>:
  sync_mm_rss (old_mm_111);
  _112 = &old_mm_111->mmap_sem;
  down_read (_112);
  _113 = old_mm_111->core_state;
  if (_113 != 0B)
    goto <bb 33>;
  else
    goto <bb 34>;

  <bb 33>:
  up_read (_112);
  goto <bb 79>;

  <bb 34>:
  _117 = &MEM[(struct spinlock_t *)tsk_109 + 1680B].D.5408.rlock;
  _raw_spin_lock (_117);
  active_mm_118 = tsk_109->active_mm;
  tsk_109->mm = _14;
  tsk_109->active_mm = _14;
  __asm__("movl %%gs:%1,%0" : "=r" pscr_ret___137 : "m" cpu_number);
  cpu_138 = (unsigned int) pscr_ret___137;
  if (_14 != active_mm_118)
    goto <bb 35>;
  else
    goto <bb 52>;

  <bb 35>:
  __asm__("movl %1,%%gs:%0" : "=m" cpu_tlbstate.state : "ri" 1, "m" cpu_tlbstate.state);
  __asm__("movq %1,%%gs:%0" : "=m" cpu_tlbstate.active_mm : "re" _14, "m" cpu_tlbstate.active_mm);
  _169 = &MEM[(struct cpumask *)_14 + 720B].bits;
  _170 = (long int) cpu_138;
  __asm__ __volatile__(".pushsection .smp_locks,"a"
.balign 4
.long 671f - .
.popsection
671:
	lock; bts %1,%0" : "=m" MEM[(volatile long int *)_169] : "Ir" _170, "m" MEM[(volatile long int *)_169] : "memory");
  _143 = _14->pgd;
  pgdir.39_144 = (long unsigned int) _143;
  y_145 = pgdir.39_144 + 2147483648;
  if (pgdir.39_144 > y_145)
    goto <bb 36>;
  else
    goto <bb 37>;

  <bb 36>:
  iftmp.40_146 = phys_base;

  <bb 37>:
  # iftmp.40_147 = PHI <131939247849472(35), iftmp.40_146(36)>
  x_148 = iftmp.40_147 + y_145;
  __asm__ __volatile__("mov %0,%%cr3" :  : "r" x_148, "m" __force_order);
  __asm__ __volatile__ goto("1:.byte 0x0f,0x1f,0x44,0x00,0
	.pushsection __jump_table,  "aw" 
	 .balign 8 
	 .quad 1b, %l2, %c0 + %c1 
	.popsection 
	" :  : "i" &__tracepoint_tlb_flush.key, "i" 0 :  : "l_yes" <L16>);

  <bb 38>:
  __asm__ __volatile__("");
  goto <bb 88>;

  <bb 39>:
  __asm__ __volatile__("" :  :  : "memory");
  _186 ={v} MEM[(volatile __u64 *)&__tracepoint_tlb_flush + 48B];
  it_func_ptr_187 = (struct tracepoint_func *) _186;
  if (it_func_ptr_187 != 0B)
    goto <bb 41>;
  else
    goto <bb 40>;

  <bb 40>:
  __asm__ __volatile__("" :  :  : "memory");
  goto <bb 88>;

  <bb 41>:
  pretmp_214 = it_func_ptr_187->func;

  <bb 42>:
  # it_func_ptr_188 = PHI <it_func_ptr_187(41), it_func_ptr_192(43)>
  # prephitmp_59 = PHI <pretmp_214(41), _193(43)>
  __data_190 = MEM[base: it_func_ptr_188, offset: 8B];
  it_func.49_191 = (void (*<T5858>) (void *, int, long unsigned int)) prephitmp_59;
  it_func.49_191 (__data_190, 0, 18446744073709551615);
  it_func_ptr_192 = it_func_ptr_188 + 16;
  _193 = MEM[base: it_func_ptr_192, offset: 0B];
  if (_193 != 0B)
    goto <bb 43>;
  else
    goto <bb 40>;

  <bb 43>:
  goto <bb 42>;

  <bb 44>:
  __asm__ __volatile__("");
  _207 ={v} MEM[(const int *)_14 + 792B];
  if (_207 != 0)
    goto <bb 45> (<L21>);
  else
    goto <bb 47>;

<L21>:
  __asm__("movq %%gs:%1,%0" : "=r" cr4_208 : "m" cpu_tlbstate.cr4);
  _209 = cr4_208 | 256;
  if (cr4_208 != _209)
    goto <bb 46>;
  else
    goto <bb 49>;

  <bb 46>:
  __asm__("movq %1,%%gs:%0" : "=m" cpu_tlbstate.cr4 : "re" _209, "m" cpu_tlbstate.cr4);
  __asm__ __volatile__("mov %0,%%cr4" :  : "r" _209, "m" __force_order);
  goto <bb 49>;

  <bb 47>:
  __asm__("movq %%gs:%1,%0" : "=r" cr4_210 : "m" cpu_tlbstate.cr4);
  _211 = cr4_210 & 18446744073709551359;
  if (cr4_210 != _211)
    goto <bb 48>;
  else
    goto <bb 49>;

  <bb 48>:
  __asm__("movq %1,%%gs:%0" : "=m" cpu_tlbstate.cr4 : "re" _211, "m" cpu_tlbstate.cr4);
  __asm__ __volatile__("mov %0,%%cr4" :  : "r" _211, "m" __force_order);

  <bb 49>:
  _150 = active_mm_118->context.ldt;
  _151 = _14->context.ldt;
  if (_150 != _151)
    goto <bb 51>;
  else
    goto <bb 50>;

  <bb 50>:
  goto <bb 71>;

  <bb 51>:
  load_mm_ldt (_14);
  goto <bb 71>;

  <bb 52>:
  __asm__("movl %1,%%gs:%0" : "=m" cpu_tlbstate.state : "ri" 1, "m" cpu_tlbstate.state);
  __asm__("movq %%gs:%1,%0" : "=r" pscr_ret___155 : "m" cpu_tlbstate.active_mm);
  if (_14 != pscr_ret___155)
    goto <bb 53>;
  else
    goto <bb 54>;

  <bb 53>:
  __asm__ __volatile__("1:	ud2
.pushsection __bug_table,"a"
2:	.long 1b - 2b, %c0 - 2b
	.word %c1, 0
	.org 2b+%c2
.popsection" :  : "i" "./arch/x86/include/asm/mmu_context.h", "i" 149, "i" 12);
  __builtin_unreachable ();

  <bb 54>:
  _159 = &MEM[(const struct cpumask *)_14 + 720B].bits;
  _160 = (long int) cpu_138;
  __asm__ __volatile__("bt %2,%1
	sbb %0,%0" : "=r" oldbit_161 : "m" MEM[(long unsigned int *)_159], "Ir" _160);
  if (oldbit_161 == 0)
    goto <bb 55>;
  else
    goto <bb 50>;

  <bb 55>:
  __asm__ __volatile__(".pushsection .smp_locks,"a"
.balign 4
.long 671f - .
.popsection
671:
	lock; bts %1,%0" : "=m" MEM[(volatile long int *)_159] : "Ir" _160, "m" MEM[(volatile long int *)_159] : "memory");
  _163 = _14->pgd;
  pgdir.39_164 = (long unsigned int) _163;
  y_165 = pgdir.39_164 + 2147483648;
  if (pgdir.39_164 > y_165)
    goto <bb 56>;
  else
    goto <bb 57>;

  <bb 56>:
  iftmp.40_166 = phys_base;

  <bb 57>:
  # iftmp.40_167 = PHI <131939247849472(55), iftmp.40_166(56)>
  x_168 = iftmp.40_167 + y_165;
  __asm__ __volatile__("mov %0,%%cr3" :  : "r" x_168, "m" __force_order);
  __asm__ __volatile__ goto("1:.byte 0x0f,0x1f,0x44,0x00,0
	.pushsection __jump_table,  "aw" 
	 .balign 8 
	 .quad 1b, %l2, %c0 + %c1 
	.popsection 
	" :  : "i" &__tracepoint_tlb_flush.key, "i" 0 :  : "l_yes" <L18>);

  <bb 58>:
  __asm__ __volatile__("");
  goto <bb 64>;

  <bb 59>:
  __asm__ __volatile__("" :  :  : "memory");
  _229 ={v} MEM[(volatile __u64 *)&__tracepoint_tlb_flush + 48B];
  it_func_ptr_230 = (struct tracepoint_func *) _229;
  if (it_func_ptr_230 != 0B)
    goto <bb 61>;
  else
    goto <bb 60>;

  <bb 60>:
  __asm__ __volatile__("" :  :  : "memory");
  goto <bb 64>;

  <bb 61>:
  pretmp_171 = it_func_ptr_230->func;

  <bb 62>:
  # it_func_ptr_231 = PHI <it_func_ptr_230(61), it_func_ptr_235(63)>
  # prephitmp_40 = PHI <pretmp_171(61), _236(63)>
  __data_233 = MEM[base: it_func_ptr_231, offset: 8B];
  it_func.49_234 = (void (*<T5858>) (void *, int, long unsigned int)) prephitmp_40;
  it_func.49_234 (__data_233, 0, 18446744073709551615);
  it_func_ptr_235 = it_func_ptr_231 + 16;
  _236 = MEM[base: it_func_ptr_235, offset: 0B];
  if (_236 != 0B)
    goto <bb 63>;
  else
    goto <bb 60>;

  <bb 63>:
  goto <bb 62>;

  <bb 64>:
  __asm__ __volatile__ goto("1:.byte 0x0f,0x1f,0x44,0x00,0
	.pushsection __jump_table,  "aw" 
	 .balign 8 
	 .quad 1b, %l2, %c0 + %c1 
	.popsection 
	" :  : "i" &rdpmc_always_available, "i" 0 :  : "l_yes" <L22>);

  <bb 65>:
  __asm__ __volatile__("");
  _239 ={v} MEM[(const int *)_14 + 792B];
  if (_239 != 0)
    goto <bb 66> (<L22>);
  else
    goto <bb 68>;

<L22>:
  __asm__("movq %%gs:%1,%0" : "=r" cr4_240 : "m" cpu_tlbstate.cr4);
  _241 = cr4_240 | 256;
  if (cr4_240 != _241)
    goto <bb 67>;
  else
    goto <bb 70>;

  <bb 67>:
  __asm__("movq %1,%%gs:%0" : "=m" cpu_tlbstate.cr4 : "re" _241, "m" cpu_tlbstate.cr4);
  __asm__ __volatile__("mov %0,%%cr4" :  : "r" _241, "m" __force_order);
  goto <bb 70>;

  <bb 68>:
  __asm__("movq %%gs:%1,%0" : "=r" cr4_242 : "m" cpu_tlbstate.cr4);
  _243 = cr4_242 & 18446744073709551359;
  if (cr4_242 != _243)
    goto <bb 69>;
  else
    goto <bb 70>;

  <bb 69>:
  __asm__("movq %1,%%gs:%0" : "=m" cpu_tlbstate.cr4 : "re" _243, "m" cpu_tlbstate.cr4);
  __asm__ __volatile__("mov %0,%%cr4" :  : "r" _243, "m" __force_order);

  <bb 70>:
  load_mm_ldt (_14);

  <bb 71>:
  _119 = tsk_109->mm;
  _119->vmacache_seqnum = 0;
  _120 = &tsk_109->vmacache;
  memset (_120, 0, 32);
  __asm__ __volatile__("" :  :  : "memory");
  MEM[(volatile __u8 *)tsk_109 + 1680B] ={v} 0;
  __asm__ __volatile__("" :  :  : "memory");
  if (old_mm_111 != 0B)
    goto <bb 72>;
  else
    goto <bb 77>;

  <bb 72>:
  _121 = &old_mm_111->mmap_sem;
  up_read (_121);
  if (old_mm_111 != active_mm_118)
    goto <bb 73>;
  else
    goto <bb 74>;

  <bb 73>:
  __asm__ __volatile__("1:	ud2
.pushsection __bug_table,"a"
2:	.long 1b - 2b, %c0 - 2b
	.word %c1, 0
	.org 2b+%c2
.popsection" :  : "i" "fs/exec.c", "i" 877, "i" 12);
  __builtin_unreachable ();

  <bb 74>:
  _125 = tsk_109->signal;
  _max1_126 = old_mm_111->hiwater_rss;
  val_127 ={v} MEM[(const long int *)old_mm_111 + 688B];
  val_142 = MAX_EXPR <val_127, 0>;
  _129 = (long unsigned int) val_142;
  val_130 ={v} MEM[(const long int *)old_mm_111 + 696B];
  val_152 = MAX_EXPR <val_130, 0>;
  _132 = (long unsigned int) val_152;
  _133 = _132 + _129;
  _134 = MAX_EXPR <_133, _max1_126>;
  _135 = MEM[(long unsigned int *)_125 + 600B];
  if (_134 > _135)
    goto <bb 75>;
  else
    goto <bb 76>;

  <bb 75>:
  MEM[(long unsigned int *)_125 + 600B] = _134;

  <bb 76>:
  mmput (old_mm_111);
  goto <bb 87>;

  <bb 77>:
  _244 = &active_mm_118->mm_count;
  __asm__ __volatile__ goto(".pushsection .smp_locks,"a"
.balign 4
.long 671f - .
.popsection
671:
	lock; decl %0; je %l1" :  : "m" _244->counter : "memory" : "cc_label" <L20>);

  <bb 78>:
  __asm__ __volatile__("");
  goto <bb 87>;

  <bb 79>:
  # _2 = PHI <0(87), -4(33), _162(82)>
  return _2;

  <bb 80>:
  __asm__ __volatile__("" :  :  : "memory");
  MEM[(volatile __u8 *)oldsighand_21 + 2056B] ={v} 0;
  __asm__ __volatile__("sti" :  :  : "memory");
  __asm__ __volatile__("" :  :  : "memory");
  goto <bb 82>;

  <bb 81>:
  sig_20->group_exit_task = pfo_ret___18;
  _29 = zap_other_threads (pfo_ret___18);
  sig_20->notify_count = _29;
  _30 = pfo_ret___18->exit_signal;
  if (_30 < 0)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 82>:
  # _162 = PHI <-11(31), -12(27), -11(80)>
  goto <bb 79>;

  <bb 83>:
  _9 = bprm_8(D)->file;
  _10 = bprm_8(D)->mm;
  set_mm_exe_file (_10, _9);
  _12 = &MEM[(struct linux_binprm *)bprm_8(D) + 136B];
  acct_arg_size.isra.16 (_12, 0);
  _14 = bprm_8(D)->mm;
  __asm__("movq %%gs:%P1,%0" : "=r" tsk_109 : "p" &current_task);
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___110 : "p" &current_task);
  old_mm_111 = pfo_ret___110->mm;
  mm_release (tsk_109, old_mm_111);
  if (old_mm_111 != 0B)
    goto <bb 32>;
  else
    goto <bb 34>;

<L16>:
  cpu_online_mask.41_180 = cpu_online_mask;
  __asm__("movl %%gs:%1,%0" : "=r" pscr_ret___181 : "m" cpu_number);
  _182 = &cpu_online_mask.41_180->bits;
  cpu.38_183 = (unsigned int) pscr_ret___181;
  _184 = (long int) cpu.38_183;
  __asm__ __volatile__("bt %2,%1
	sbb %0,%0" : "=r" oldbit_185 : "m" MEM[(long unsigned int *)_182], "Ir" _184);
  if (oldbit_185 == 0)
    goto <bb 88>;
  else
    goto <bb 39>;

<L18>:
  cpu_online_mask.41_223 = cpu_online_mask;
  __asm__("movl %%gs:%1,%0" : "=r" pscr_ret___224 : "m" cpu_number);
  _225 = &cpu_online_mask.41_223->bits;
  cpu.38_226 = (unsigned int) pscr_ret___224;
  _227 = (long int) cpu.38_226;
  __asm__ __volatile__("bt %2,%1
	sbb %0,%0" : "=r" oldbit_228 : "m" MEM[(long unsigned int *)_225], "Ir" _227);
  if (oldbit_228 == 0)
    goto <bb 64>;
  else
    goto <bb 59>;

<L20>:
  __mmdrop (active_mm_118);

  <bb 87>:
  bprm_8(D)->mm = 0B;
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___249 : "p" &cpu_tss.x86_tss.sp0);
  _250 = pfo_ret___249 + 18446744073709535232;
  _251 = (struct thread_info *) _250;
  _251->addr_limit.seg = 140737488351232;
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___252 : "p" &current_task);
  _253 = pfo_ret___252->flags;
  _254 = _253 & 4221534143;
  pfo_ret___252->flags = _254;
  flush_thread ();
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___255 : "p" &current_task);
  _256 = pfo_ret___255->personality;
  _257 = bprm_8(D)->per_clear;
  _258 = ~_257;
  _259 = _258 & _256;
  pfo_ret___255->personality = _259;
  goto <bb 79>;

  <bb 88>:
  _4 = &MEM[(struct cpumask *)active_mm_118 + 720B].bits;
  __asm__ __volatile__(".pushsection .smp_locks,"a"
.balign 4
.long 671f - .
.popsection
671:
	lock; btr %1,%0" : "=m" MEM[(volatile long int *)_4] : "Ir" _170, "m" MEM[(volatile long int *)_4]);
  __asm__ __volatile__ goto("1:.byte 0x0f,0x1f,0x44,0x00,0
	.pushsection __jump_table,  "aw" 
	 .balign 8 
	 .quad 1b, %l2, %c0 + %c1 
	.popsection 
	" :  : "i" &rdpmc_always_available, "i" 0 :  : "l_yes" <L21>);
  goto <bb 44>;

}



;; Function do_open_execat (do_open_execat, funcdef_no=2867, decl_uid=40901, cgraph_uid=2868)

do_open_execat (int fd, struct filename * name, int flags)
{
  struct path * path;
  __u32 mask;
  struct dentry * dentry;
  volatile u32 * __ptr;
  int v;
  long unsigned int ptr.4;
  struct open_flags open_exec_flags;
  struct file * file;
  struct file * _2;
  int _15;
  int _16;
  int _18;
  int _19;
  int _20;
  struct inode * _26;
  short unsigned int _27;
  const char * _30;
  char _31;
  short unsigned int _40;
  struct vfsmount * _41;
  int _42;
  int _43;
  struct super_block * _44;
  long unsigned int _45;
  long unsigned int _46;
  void * prephitmp_51;
  int _52;
  struct inode * _61;
  short unsigned int _62;
  short unsigned int _63;

  <bb 2>:
  open_exec_flags = {};
  open_exec_flags.open_flag = 32800;
  open_exec_flags.acc_mode = 33;
  open_exec_flags.intent = 256;
  open_exec_flags.lookup_flags = 1;
  _15 = flags_14(D) & -4353;
  if (_15 != 0)
    goto <bb 19>;
  else
    goto <bb 3>;

  <bb 3>:
  _16 = flags_14(D) & 256;
  if (_16 != 0)
    goto <bb 4>;
  else
    goto <bb 5>;

  <bb 4>:
  open_exec_flags.lookup_flags = 0;

  <bb 5>:
  _18 = flags_14(D) & 4096;
  if (_18 != 0)
    goto <bb 6>;
  else
    goto <bb 7>;

  <bb 6>:
  _19 = open_exec_flags.lookup_flags;
  _20 = _19 | 16384;
  open_exec_flags.lookup_flags = _20;

  <bb 7>:
  file_25 = do_filp_open (fd_22(D), name_23(D), &open_exec_flags);
  ptr.4_36 = (long unsigned int) file_25;
  if (ptr.4_36 > 18446744073709547520)
    goto <bb 19>;
  else
    goto <bb 8>;

  <bb 8>:
  _26 = MEM[(const struct file *)file_25 + 32B];
  _27 = _26->i_mode;
  _40 = _27 & 61440;
  if (_40 != 32768)
    goto <bb 18> (exit);
  else
    goto <bb 9>;

  <bb 9>:
  _41 = MEM[(const struct path *)file_25 + 16B].mnt;
  _42 = _41->mnt_flags;
  _43 = _42 & 4;
  if (_43 != 0)
    goto <bb 18> (exit);
  else
    goto <bb 10>;

  <bb 10>:
  _44 = _41->mnt_sb;
  _45 = _44->s_iflags;
  _46 = _45 & 2;
  if (_46 != 0)
    goto <bb 18> (exit);
  else
    goto <bb 11>;

  <bb 11>:

  <bb 12>:
  # v_78 = PHI <v_54(14), 0(11)>
  _52 = v_78 + -1;
  __ptr_53 = &MEM[(struct atomic_t *)_26 + 320B].counter;
  __asm__ __volatile__(".pushsection .smp_locks,"a"
.balign 4
.long 671f - .
.popsection
671:
	lock; cmpxchgl %2,%1" : "=a" v_54, "=m" *__ptr_53 : "r" _52, "0" v_78, "m" *__ptr_53 : "memory");
  if (v_78 == v_54)
    goto <bb 20>;
  else
    goto <bb 13>;

  <bb 13>:
  if (v_54 <= 0)
    goto <bb 14>;
  else
    goto <bb 18> (exit);

  <bb 14>:
  goto <bb 12>;

  <bb 15>:
  path_60 = &file_25->f_path;
  _61 = MEM[(const struct file *)file_25 + 32B];
  _62 = _61->i_mode;
  _63 = _62 & 61440;
  if (_63 == 16384)
    goto <bb 17>;
  else
    goto <bb 16>;

  <bb 16>:

  <bb 17>:
  # mask_65 = PHI <32(16), 1073741856(15)>
  dentry_64 = MEM[(struct path *)file_25 + 16B].dentry;
  __fsnotify_parent (path_60, dentry_64, mask_65);
  fsnotify (_61, mask_65, path_60, 1, 0B, 0);
  goto <bb 19>;

  # prephitmp_51 = PHI <-13B(9), -26B(13), -13B(8), -13B(10)>
exit:
  fput (file_25);

  <bb 19>:
  # _2 = PHI <-22B(2), file_25(20), prephitmp_51(18), file_25(7), file_25(17)>
  open_exec_flags ={v} {CLOBBER};
  return _2;

  <bb 20>:
  _30 = name_23(D)->name;
  _31 = *_30;
  if (_31 != 0)
    goto <bb 15>;
  else
    goto <bb 19>;

}



;; Function open_exec (open_exec, funcdef_no=2868, decl_uid=16306, cgraph_uid=2869)

open_exec (const char * name)
{
  long unsigned int ptr.4;
  struct file * f;

  <bb 2>:
  f_6 = getname_kernel (name_4(D));
  ptr.4_10 = (long unsigned int) f_6;
  if (ptr.4_10 <= 18446744073709547520)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  f_8 = do_open_execat (-100, f_6, 0);
  putname (f_6);

  <bb 4>:
  # f_1 = PHI <f_6(2), f_8(3)>
  return f_1;

}



;; Function path_noexec (path_noexec, funcdef_no=2849, decl_uid=16999, cgraph_uid=2849)

path_noexec (const struct path * path)
{
  struct vfsmount * _4;
  int _5;
  int _6;
  struct super_block * _7;
  long unsigned int _8;
  long unsigned int _9;
  _Bool _11;
  bool pretmp_13;
  bool prephitmp_14;

  <bb 2>:
  _4 = path_3(D)->mnt;
  _5 = _4->mnt_flags;
  _6 = _5 & 4;
  if (_6 != 0)
    goto <bb 4>;
  else
    goto <bb 3>;

  <bb 3>:
  _7 = _4->mnt_sb;
  _8 = _7->s_iflags;
  _9 = _8 & 2;
  _11 = _9 != 0;
  pretmp_13 = _11;

  <bb 4>:
  # prephitmp_14 = PHI <pretmp_13(3), 1(2)>
  return prephitmp_14;

}



;; Function SyS_uselib (SyS_uselib, funcdef_no=2850, decl_uid=40719, cgraph_uid=2851)

SyS_uselib (long int library)
{
  struct path * path;
  struct dentry * dentry;
  struct linux_binfmt * fmt;
  struct file * file;
  struct filename * tmp;
  int error;
  long unsigned int ptr.4;
  long unsigned int ptr.4;
  int __ret;
  int __ret;
  static const struct open_flags uselib_flags = {.open_flag=32800, .acc_mode=37, .intent=256, .lookup_flags=1};
  const char * library.1;
  long int _7;
  long int _14;
  long int prephitmp_17;
  struct inode * _20;
  short unsigned int _21;
  short unsigned int _22;
  struct vfsmount * _23;
  int _24;
  int _25;
  struct super_block * _26;
  long unsigned int _27;
  long unsigned int _28;
  long int pretmp_29;
  long int pretmp_30;
  int (*<T2508>) (struct file *) _33;
  struct module * _34;
  _Bool _35;
  int (*<T2508>) (struct file *) _37;
  struct module * _39;
  struct list_head * _41;
  long int prephitmp_45;
  long int pretmp_46;
  struct list_head * _52;
  long int prephitmp_54;

  <bb 2>:
  library.1_2 = (const char *) library_1(D);
  tmp_6 = getname (library.1_2);
  ptr.4_9 = (long unsigned int) tmp_6;
  if (ptr.4_9 > 18446744073709547520)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _7 = (long int) tmp_6;
  error_8 = (int) _7;
  pretmp_30 = (long int) error_8;
  goto <bb 18> (out);

  <bb 4>:
  file_13 = do_filp_open (-100, tmp_6, &uselib_flags);
  putname (tmp_6);
  ptr.4_16 = (long unsigned int) file_13;
  if (ptr.4_16 > 18446744073709547520)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  _14 = (long int) file_13;
  error_15 = (int) _14;
  pretmp_29 = (long int) error_15;
  goto <bb 18> (out);

  <bb 6>:
  _20 = MEM[(const struct file *)file_13 + 32B];
  _21 = _20->i_mode;
  _22 = _21 & 61440;
  if (_22 != 32768)
    goto <bb 17> (exit);
  else
    goto <bb 7>;

  <bb 7>:
  _23 = MEM[(const struct path *)file_13 + 16B].mnt;
  _24 = _23->mnt_flags;
  _25 = _24 & 4;
  if (_25 != 0)
    goto <bb 17> (exit);
  else
    goto <bb 8>;

  <bb 8>:
  _26 = _23->mnt_sb;
  _27 = _26->s_iflags;
  _28 = _27 & 2;
  if (_28 != 0)
    goto <bb 17> (exit);
  else
    goto <bb 19>;

  <bb 9>:

  <bb 10>:
  # fmt_5 = PHI <fmt_40(9), fmt_31(20)>
  _33 = fmt_5->load_shlib;
  if (_33 == 0B)
    goto <bb 11>;
  else
    goto <bb 12>;

  <bb 11>:
  fmt_40 = fmt_5->lh.next;
  _41 = &fmt_40->lh;
  if (_41 != &formats)
    goto <bb 9>;
  else
    goto <bb 15>;

  <bb 12>:
  _34 = fmt_5->module;
  _35 = try_module_get (_34);
  if (_35 != 0)
    goto <bb 13>;
  else
    goto <bb 11>;

  <bb 13>:
  __asm__ __volatile__(".pushsection .smp_locks,"a"
.balign 4
.long 671f - .
.popsection
671:
	lock; xaddl %0, %1
" : "=r" __ret_36, "=m" MEM[(struct atomic_t *)&binfmt_lock].counter : "0" -256, "m" MEM[(struct atomic_t *)&binfmt_lock].counter : "cc", "memory", "memory");
  __asm__ __volatile__("" :  :  : "memory");
  _37 = fmt_5->load_shlib;
  error_38 = _37 (file_13);
  _raw_read_lock (&binfmt_lock);
  _39 = MEM[(struct linux_binfmt *)fmt_5 + 16B];
  module_put (_39);
  if (error_38 != -8)
    goto <bb 14>;
  else
    goto <bb 11>;

  <bb 14>:
  # error_51 = PHI <error_38(13)>
  pretmp_46 = (long int) error_51;
  goto <bb 16>;

  <bb 15>:

  <bb 16>:
  # prephitmp_45 = PHI <pretmp_46(14), -8(15)>
  __asm__ __volatile__(".pushsection .smp_locks,"a"
.balign 4
.long 671f - .
.popsection
671:
	lock; xaddl %0, %1
" : "=r" __ret_42, "=m" MEM[(struct atomic_t *)&binfmt_lock].counter : "0" -256, "m" MEM[(struct atomic_t *)&binfmt_lock].counter : "cc", "memory", "memory");
  __asm__ __volatile__("" :  :  : "memory");

  # prephitmp_54 = PHI <-22(6), -13(8), prephitmp_45(16), -13(7)>
exit:
  fput (file_13);

  # prephitmp_17 = PHI <pretmp_30(3), pretmp_29(5), prephitmp_54(17)>
out:
  return prephitmp_17;

  <bb 19>:
  path_49 = &file_13->f_path;
  dentry_53 = MEM[(struct path *)file_13 + 16B].dentry;
  __fsnotify_parent (path_49, dentry_53, 32);
  fsnotify (_20, 32, path_49, 1, 0B, 0);
  _raw_read_lock (&binfmt_lock);
  fmt_31 = formats.next;
  _52 = &fmt_31->lh;
  if (_52 != &formats)
    goto <bb 20>;
  else
    goto <bb 15>;

  <bb 20>:
  goto <bb 10>;

}



;; Function __set_task_comm (__set_task_comm, funcdef_no=2874, decl_uid=23329, cgraph_uid=2875)

__set_task_comm (struct task_struct * tsk, const char * buf, bool exec)
{
  void (*<T6078>) (void *, struct task_struct *, const char *) it_func.23;
  struct tracepoint_func * it_func_ptr;
  void * __data;
  char[16] * _6;
  int _10;
  struct raw_spinlock * _12;
  long long unsigned int _16;
  void * _23;
  void * pretmp_34;
  void * prephitmp_35;

  <bb 2>:
  _12 = &MEM[(struct spinlock_t *)tsk_2(D) + 1680B].D.5408.rlock;
  _raw_spin_lock (_12);
  __asm__ __volatile__ goto("1:.byte 0x0f,0x1f,0x44,0x00,0
	.pushsection __jump_table,  "aw" 
	 .balign 8 
	 .quad 1b, %l2, %c0 + %c1 
	.popsection 
	" :  : "i" &__tracepoint_task_rename.key, "i" 0 :  : "l_yes" <L2>);

  <bb 3>:
  __asm__ __volatile__("");
  goto <bb 7>;

  <bb 4>:

  <bb 5>:
  # it_func_ptr_18 = PHI <it_func_ptr_17(9), it_func_ptr_22(4)>
  # prephitmp_35 = PHI <pretmp_34(9), _23(4)>
  __data_20 = MEM[base: it_func_ptr_18, offset: 8B];
  it_func.23_21 = (void (*<T6078>) (void *, struct task_struct *, const char *)) prephitmp_35;
  it_func.23_21 (__data_20, tsk_2(D), buf_4(D));
  it_func_ptr_22 = it_func_ptr_18 + 16;
  _23 = MEM[base: it_func_ptr_22, offset: 0B];
  if (_23 != 0B)
    goto <bb 4>;
  else
    goto <bb 6>;

  <bb 6>:
  __asm__ __volatile__("" :  :  : "memory");

  <bb 7>:
  _6 = &tsk_2(D)->comm;
  strlcpy (_6, buf_4(D), 16);
  __asm__ __volatile__("" :  :  : "memory");
  MEM[(volatile __u8 *)tsk_2(D) + 1680B] ={v} 0;
  __asm__ __volatile__("" :  :  : "memory");
  _10 = (int) exec_9(D);
  perf_event_comm (tsk_2(D), _10);
  return;

<L2>:
  __asm__ __volatile__("" :  :  : "memory");
  _16 ={v} MEM[(volatile __u64 *)&__tracepoint_task_rename + 48B];
  it_func_ptr_17 = (struct tracepoint_func *) _16;
  if (it_func_ptr_17 != 0B)
    goto <bb 9>;
  else
    goto <bb 6>;

  <bb 9>:
  pretmp_34 = it_func_ptr_17->func;
  goto <bb 5>;

}



;; Function prepare_bprm_creds (prepare_bprm_creds, funcdef_no=2878, decl_uid=30477, cgraph_uid=2879)

prepare_bprm_creds (struct linux_binprm * bprm)
{
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  int _1;
  struct signal_struct * _4;
  struct mutex * _5;
  int _7;
  struct cred * _9;
  struct signal_struct * _19;
  struct mutex * _20;

  <bb 2>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___16 : "p" &current_task);
  _4 = pfo_ret___16->signal;
  _5 = &_4->cred_guard_mutex;
  _7 = mutex_lock_interruptible (_5);
  if (_7 != 0)
    goto <bb 5>;
  else
    goto <bb 3>;

  <bb 3>:
  _9 = prepare_exec_creds ();
  bprm_10(D)->cred = _9;
  if (_9 != 0B)
    goto <bb 5>;
  else
    goto <bb 4>;

  <bb 4>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___18 : "p" &current_task);
  _19 = pfo_ret___18->signal;
  _20 = &_19->cred_guard_mutex;
  mutex_unlock (_20);

  <bb 5>:
  # _1 = PHI <-513(2), _7(3), -12(4)>
  return _1;

}



;; Function do_execve (do_execve, funcdef_no=2889, decl_uid=23299, cgraph_uid=2890)

do_execve (struct filename * filename, const char * const * __argv, const char * const * __envp)
{
  struct task_struct * pfo_ret__;
  struct files_struct * displaced.82;
  struct file * file;
  struct files_struct * displaced;
  int retval;
  long unsigned int ptr.4;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  long unsigned int ptr.4;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  bool need_retry;
  struct linux_binfmt * fmt;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  pid_t old_pid;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  long int _11;
  int _12;
  unsigned int _14;
  unsigned int _15;
  const struct cred * _17;
  struct user_struct * _18;
  int _19;
  long unsigned int _20;
  unsigned int _23;
  unsigned int _24;
  int * _28;
  long int _31;
  const char * _39;
  char[128] * _54;
  struct file * _55;
  const char * * _58;
  long unsigned int _60;
  int _61;
  int _63;
  struct task_struct * _68;
  struct pid_namespace * _69;
  unsigned int _72;
  struct module * _76;
  _Bool _77;
  unsigned int _78;
  unsigned int _79;
  int (*<T4b2d>) (struct linux_binprm *) _80;
  struct module * _82;
  unsigned int _83;
  unsigned int _84;
  struct mm_struct * _85;
  struct file * _87;
  struct list_head * _89;
  char _91;
  unsigned char _92;
  unsigned char _93;
  _Bool _94;
  unsigned char _95;
  _Bool _96;
  _Bool _97;
  char _98;
  unsigned char _99;
  unsigned char _100;
  _Bool _101;
  unsigned char _102;
  _Bool _103;
  _Bool _104;
  char _105;
  unsigned char _106;
  unsigned char _107;
  _Bool _108;
  unsigned char _109;
  _Bool _110;
  _Bool _111;
  char _112;
  unsigned char _113;
  unsigned char _114;
  _Bool _115;
  unsigned char _116;
  _Bool _117;
  _Bool _118;
  short unsigned int _119;
  int _120;
  int _121;
  long unsigned int _124;
  struct fs_struct * _127;
  struct mm_struct * _133;
  long unsigned int * _134;
  struct mm_struct * _135;
  struct fs_struct * _137;
  int _140;
  struct list_head * _213;
  struct signal_struct * _215;
  long long unsigned int _216;
  struct kmem_cache * _296;
  void * _297;
  pid_t _307;

  <bb 2>:
  ptr.4_7 = (long unsigned int) filename_4(D);
  if (ptr.4_7 > 18446744073709547520)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _11 = (long int) filename_4(D);
  _12 = (int) _11;
  goto <bb 51>;

  <bb 4>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___13 : "p" &current_task);
  _14 = pfo_ret___13->flags;
  _15 = _14 & 4096;
  if (_15 != 0)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___16 : "p" &current_task);
  _17 = pfo_ret___16->cred;
  _18 = _17->user;
  _19 ={v} MEM[(const int *)_18 + 4B];
  _20 = (long unsigned int) _19;
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___214 : "p" &current_task);
  _215 = MEM[(const struct task_struct *)pfo_ret___214].signal;
  _216 ={v} MEM[(volatile __u64 *)_215].rlim[6].rlim_cur;
  if (_20 > _216)
    goto <bb 50> (out_ret);
  else
    goto <bb 6>;

  <bb 6>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___22 : "p" &current_task);
  _23 = pfo_ret___22->flags;
  _24 = _23 & 4294963199;
  pfo_ret___22->flags = _24;
  retval_25 = unshare_files (&displaced);
  if (retval_25 != 0)
    goto <bb 50> (out_ret);
  else
    goto <bb 7>;

  <bb 7>:
  _296 = kmalloc_caches[8];
  _297 = kmem_cache_alloc_trace (_296, 32976, 240);
  if (_297 == 0B)
    goto <bb 48> (out_files);
  else
    goto <bb 8>;

  <bb 8>:
  retval_27 = prepare_bprm_creds (_297);
  if (retval_27 != 0)
    goto <bb 47> (out_free);
  else
    goto <bb 9>;

  <bb 9>:
  _28 = &MEM[(struct linux_binprm *)_297 + 184B];
  check_unsafe_exec.isra.21 (_28);
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___29 : "p" &current_task);
  pfo_ret___29->in_execve = 1;
  file_30 = do_open_execat (-100, filename_4(D), 0);
  ptr.4_33 = (long unsigned int) file_30;
  if (ptr.4_33 > 18446744073709547520)
    goto <bb 10>;
  else
    goto <bb 11>;

  <bb 10>:
  _31 = (long int) file_30;
  retval_32 = (int) _31;
  goto <bb 46> (out_unmark);

  <bb 11>:
  sched_exec ();
  MEM[(struct linux_binprm *)_297].file = file_30;
  _39 = filename_4(D)->name;
  MEM[(struct linux_binprm *)_297].filename = _39;
  MEM[(struct linux_binprm *)_297].interp = _39;
  retval_50 = bprm_mm_init (_297);
  if (retval_50 != 0)
    goto <bb 46> (out_unmark);
  else
    goto <bb 12>;

  <bb 12>:
  retval_51 = count.isra.25.constprop.43 (0, __argv_2(D));
  MEM[(struct linux_binprm *)_297].argc = retval_51;
  if (retval_51 < 0)
    goto <bb 44> (out);
  else
    goto <bb 13>;

  <bb 13>:
  retval_52 = count.isra.25.constprop.43 (0, __envp_3(D));
  MEM[(struct linux_binprm *)_297].envc = retval_52;
  if (retval_52 < 0)
    goto <bb 44> (out);
  else
    goto <bb 14>;

  <bb 14>:
  bprm_fill_uid (_297);
  retval_53 = security_bprm_set_creds (_297);
  if (retval_53 != 0)
    goto <bb 16>;
  else
    goto <bb 15>;

  <bb 15>:
  MEM[(struct linux_binprm *)_297].cred_prepared = 1;
  _54 = &MEM[(struct linux_binprm *)_297].buf;
  memset (_54, 0, 128);
  _55 = MEM[(struct linux_binprm *)_297].file;
  retval_56 = kernel_read (_55, 0, _54, 128);

  <bb 16>:
  # retval_57 = PHI <retval_53(14), retval_56(15)>
  if (retval_57 < 0)
    goto <bb 44> (out);
  else
    goto <bb 17>;

  <bb 17>:
  _58 = &MEM[(struct linux_binprm *)_297].filename;
  retval_59 = copy_strings_kernel (1, _58, _297);
  if (retval_59 < 0)
    goto <bb 44> (out);
  else
    goto <bb 18>;

  <bb 18>:
  _60 = MEM[(struct linux_binprm *)_297].p;
  MEM[(struct linux_binprm *)_297].exec = _60;
  _61 = MEM[(struct linux_binprm *)_297].envc;
  retval_62 = copy_strings.isra.27 (_61, 0, __envp_3(D), _297);
  if (retval_62 < 0)
    goto <bb 44> (out);
  else
    goto <bb 19>;

  <bb 19>:
  _63 = MEM[(struct linux_binprm *)_297].argc;
  retval_64 = copy_strings.isra.27 (_63, 0, __argv_2(D), _297);
  if (retval_64 < 0)
    goto <bb 44> (out);
  else
    goto <bb 20>;

  <bb 20>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___65 : "p" &current_task);
  old_pid_66 = pfo_ret___65->pid;
  __asm__ __volatile__("" :  :  : "memory");
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___67 : "p" &current_task);
  _68 = pfo_ret___67->parent;
  _69 = task_active_pid_ns (_68);
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___70 : "p" &current_task);
  _307 = __task_pid_nr_ns (pfo_ret___70, 0, _69);
  __asm__ __volatile__("" :  :  : "memory");
  _72 = MEM[(struct linux_binprm *)_297].recursion_depth;
  if (_72 > 5)
    goto <bb 52>;
  else
    goto <bb 21>;

  <bb 21>:
  retval_73 = security_bprm_check (_297);
  if (retval_73 != 0)
    goto <bb 41>;
  else
    goto <bb 22>;

  <bb 22>:

  # need_retry_90 = PHI <1(22), 0(40)>
  # retval_141 = PHI <-2(22), retval_295(40)>
retry:
  _raw_read_lock (&binfmt_lock);
  fmt_74 = formats.next;
  _213 = &fmt_74->lh;
  if (_213 != &formats)
    goto <bb 24>;
  else
    goto <bb 34>;

  <bb 24>:

  <bb 25>:
  # fmt_227 = PHI <fmt_88(33), fmt_74(24)>
  # retval_302 = PHI <retval_143(33), retval_141(24)>
  _76 = fmt_227->module;
  _77 = try_module_get (_76);
  if (_77 != 0)
    goto <bb 26>;
  else
    goto <bb 32>;

  <bb 26>:
  __raw_read_unlock.constprop.42 ();
  _78 = MEM[(struct linux_binprm *)_297].recursion_depth;
  _79 = _78 + 1;
  MEM[(struct linux_binprm *)_297].recursion_depth = _79;
  _80 = fmt_227->load_binary;
  retval_81 = _80 (_297);
  _raw_read_lock (&binfmt_lock);
  _82 = MEM[(struct linux_binfmt *)fmt_227 + 16B];
  module_put (_82);
  _83 = MEM[(struct linux_binprm *)_297].recursion_depth;
  _84 = _83 + 4294967295;
  MEM[(struct linux_binprm *)_297].recursion_depth = _84;
  if (retval_81 < 0)
    goto <bb 27>;
  else
    goto <bb 31>;

  <bb 27>:
  _85 = MEM[(struct linux_binprm *)_297].mm;
  if (_85 == 0B)
    goto <bb 28>;
  else
    goto <bb 29>;

  <bb 28>:
  __raw_read_unlock.constprop.42 ();
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___86 : "p" &current_task);
  force_sigsegv (11, pfo_ret___86);
  goto <bb 52>;

  <bb 29>:
  if (retval_81 != -8)
    goto <bb 31>;
  else
    goto <bb 30>;

  <bb 30>:
  _87 = MEM[(struct linux_binprm *)_297].file;
  if (_87 == 0B)
    goto <bb 31>;
  else
    goto <bb 32>;

  <bb 31>:
  # retval_217 = PHI <retval_81(26), retval_81(30), retval_81(29)>
  __raw_read_unlock.constprop.42 ();
  goto <bb 41>;

  <bb 32>:
  # retval_143 = PHI <retval_302(25), retval_81(30)>
  fmt_88 = fmt_227->lh.next;
  _89 = &fmt_88->lh;
  if (_89 != &formats)
    goto <bb 33>;
  else
    goto <bb 34>;

  <bb 33>:
  goto <bb 25>;

  <bb 34>:
  # retval_295 = PHI <retval_143(32), retval_141(23)>
  __raw_read_unlock.constprop.42 ();
  if (need_retry_90 != 0)
    goto <bb 35>;
  else
    goto <bb 41>;

  <bb 35>:
  _91 = MEM[(struct linux_binprm *)_297].buf[0];
  _92 = (unsigned char) _91;
  _93 = _92 + 247;
  _94 = _93 <= 1;
  _95 = _92 + 224;
  _96 = _95 <= 94;
  _97 = _96 | _94;
  if (_97 != 0)
    goto <bb 36>;
  else
    goto <bb 39>;

  <bb 36>:
  _98 = MEM[(struct linux_binprm *)_297].buf[1];
  _99 = (unsigned char) _98;
  _100 = _99 + 247;
  _101 = _100 <= 1;
  _102 = _99 + 224;
  _103 = _102 <= 94;
  _104 = _103 | _101;
  if (_104 != 0)
    goto <bb 37>;
  else
    goto <bb 39>;

  <bb 37>:
  _105 = MEM[(struct linux_binprm *)_297].buf[2];
  _106 = (unsigned char) _105;
  _107 = _106 + 247;
  _108 = _107 <= 1;
  _109 = _106 + 224;
  _110 = _109 <= 94;
  _111 = _110 | _108;
  if (_111 != 0)
    goto <bb 38>;
  else
    goto <bb 39>;

  <bb 38>:
  _112 = MEM[(struct linux_binprm *)_297].buf[3];
  _113 = (unsigned char) _112;
  _114 = _113 + 247;
  _115 = _114 <= 1;
  _116 = _113 + 224;
  _117 = _116 <= 94;
  _118 = _117 | _115;
  if (_118 != 0)
    goto <bb 41>;
  else
    goto <bb 39>;

  <bb 39>:
  _119 = MEM[(ushort *)_297 + 2B];
  _120 = (int) _119;
  _121 = __request_module (1, "binfmt-%04x", _120);
  if (_121 < 0)
    goto <bb 41>;
  else
    goto <bb 40>;

  <bb 40>:
  goto <bb 23> (retry);

  <bb 41>:
  # retval_122 = PHI <retval_295(38), retval_73(21), retval_295(39), retval_217(31), retval_295(34)>
  if (retval_122 >= 0)
    goto <bb 42>;
  else
    goto <bb 53>;

  <bb 42>:
  audit_bprm (_297);
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___123 : "p" &current_task);
  trace_sched_process_exec (pfo_ret___123, old_pid_66, _297);
  _124 = (long unsigned int) _307;
  ptrace_event.constprop.37 (_124);
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___125 : "p" &current_task);
  proc_exec_connector (pfo_ret___125);
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___126 : "p" &current_task);
  _127 = pfo_ret___126->fs;
  _127->in_exec = 0;
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___128 : "p" &current_task);
  pfo_ret___128->in_execve = 0;
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___129 : "p" &current_task);
  acct_update_integrals (pfo_ret___129);
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___130 : "p" &current_task);
  free_bprm (_297);
  kfree (0B);
  putname (filename_4(D));
  displaced.82_132 = displaced;
  if (displaced.82_132 != 0B)
    goto <bb 43>;
  else
    goto <bb 51>;

  <bb 43>:
  put_files_struct (displaced.82_132);
  goto <bb 51>;

  # retval_144 = PHI <retval_51(12), retval_52(13), retval_57(16), retval_59(17), retval_62(18), retval_64(19), retval_224(53)>
out:
  _133 = MEM[(struct linux_binprm *)_297].mm;
  if (_133 != 0B)
    goto <bb 45>;
  else
    goto <bb 46> (out_unmark);

  <bb 45>:
  _134 = &MEM[(struct linux_binprm *)_297 + 136B];
  acct_arg_size.isra.16 (_134, 0);
  _135 = MEM[(struct linux_binprm *)_297].mm;
  mmput (_135);

  # retval_145 = PHI <retval_32(10), retval_144(45), retval_50(11), retval_144(44)>
out_unmark:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___136 : "p" &current_task);
  _137 = pfo_ret___136->fs;
  _137->in_exec = 0;
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___138 : "p" &current_task);
  pfo_ret___138->in_execve = 0;

  # retval_146 = PHI <retval_27(8), retval_145(46)>
out_free:
  free_bprm (_297);
  kfree (0B);

  # retval_147 = PHI <-12(7), retval_146(47)>
out_files:
  displaced.82_139 = displaced;
  if (displaced.82_139 != 0B)
    goto <bb 49>;
  else
    goto <bb 50> (out_ret);

  <bb 49>:
  reset_files_struct (displaced.82_139);

  # retval_148 = PHI <-11(5), retval_25(6), retval_147(48), retval_147(49)>
out_ret:
  putname (filename_4(D));

  <bb 51>:
  # _140 = PHI <_12(3), retval_122(43), retval_148(50), retval_122(42)>
  displaced ={v} {CLOBBER};
  return _140;

  <bb 52>:
  # retval_229 = PHI <retval_81(28), -40(20)>

  <bb 53>:
  # retval_224 = PHI <retval_229(52), retval_122(41)>
  goto <bb 44> (out);

}



;; Function do_execveat (do_execveat, funcdef_no=2890, decl_uid=23305, cgraph_uid=2891)

do_execveat (int fd, struct filename * filename, const char * const * __argv, const char * const * __envp, int flags)
{
  int oldbit;
  struct task_struct * pfo_ret__;
  struct files_struct * displaced.82;
  char * pathbuf;
  struct file * file;
  struct files_struct * displaced;
  int retval;
  struct fdtable * ________p1;
  long unsigned int ptr.4;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  long unsigned int ptr.4;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  bool need_retry;
  struct linux_binfmt * fmt;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  pid_t old_pid;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  const char * prephitmp_8;
  long int _13;
  int _14;
  unsigned int _16;
  unsigned int _17;
  const struct cred * _19;
  struct user_struct * _20;
  int _21;
  long unsigned int _22;
  unsigned int _25;
  unsigned int _26;
  int * _30;
  long int _33;
  const char * _39;
  char _40;
  struct files_struct * _46;
  long long unsigned int _47;
  long unsigned int * _49;
  unsigned int _51;
  unsigned int _52;
  char[128] * _58;
  struct file * _59;
  const char * * _62;
  long unsigned int _64;
  int _65;
  int _67;
  struct task_struct * _72;
  struct pid_namespace * _73;
  unsigned int _76;
  struct module * _80;
  _Bool _81;
  unsigned int _82;
  unsigned int _83;
  int (*<T4b2d>) (struct linux_binprm *) _84;
  struct module * _86;
  unsigned int _87;
  unsigned int _88;
  struct mm_struct * _89;
  struct file * _91;
  struct list_head * _93;
  char _95;
  unsigned char _96;
  unsigned char _97;
  _Bool _98;
  unsigned char _99;
  _Bool _100;
  _Bool _101;
  char _102;
  unsigned char _103;
  unsigned char _104;
  _Bool _105;
  unsigned char _106;
  _Bool _107;
  _Bool _108;
  char _109;
  unsigned char _110;
  unsigned char _111;
  _Bool _112;
  unsigned char _113;
  _Bool _114;
  _Bool _115;
  char _116;
  unsigned char _117;
  unsigned char _118;
  _Bool _119;
  unsigned char _120;
  _Bool _121;
  _Bool _122;
  short unsigned int _123;
  int _124;
  int _125;
  long unsigned int _128;
  struct fs_struct * _131;
  struct mm_struct * _137;
  long unsigned int * _138;
  struct mm_struct * _139;
  struct fs_struct * _141;
  int _145;
  const char * pretmp_155;
  struct list_head * _240;
  struct signal_struct * _242;
  long long unsigned int _243;
  const char * prephitmp_315;
  struct kmem_cache * _323;
  void * _324;
  long int _347;
  pid_t _351;

  <bb 2>:
  ptr.4_9 = (long unsigned int) filename_5(D);
  if (ptr.4_9 > 18446744073709547520)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _13 = (long int) filename_5(D);
  _14 = (int) _13;
  goto <bb 62>;

  <bb 4>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___15 : "p" &current_task);
  _16 = pfo_ret___15->flags;
  _17 = _16 & 4096;
  if (_17 != 0)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___18 : "p" &current_task);
  _19 = pfo_ret___18->cred;
  _20 = _19->user;
  _21 ={v} MEM[(const int *)_20 + 4B];
  _22 = (long unsigned int) _21;
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___241 : "p" &current_task);
  _242 = MEM[(const struct task_struct *)pfo_ret___241].signal;
  _243 ={v} MEM[(volatile __u64 *)_242].rlim[6].rlim_cur;
  if (_22 > _243)
    goto <bb 61> (out_ret);
  else
    goto <bb 6>;

  <bb 6>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___24 : "p" &current_task);
  _25 = pfo_ret___24->flags;
  _26 = _25 & 4294963199;
  pfo_ret___24->flags = _26;
  retval_27 = unshare_files (&displaced);
  if (retval_27 != 0)
    goto <bb 61> (out_ret);
  else
    goto <bb 7>;

  <bb 7>:
  _323 = kmalloc_caches[8];
  _324 = kmem_cache_alloc_trace (_323, 32976, 240);
  if (_324 == 0B)
    goto <bb 59> (out_files);
  else
    goto <bb 8>;

  <bb 8>:
  retval_29 = prepare_bprm_creds (_324);
  if (retval_29 != 0)
    goto <bb 58> (out_free);
  else
    goto <bb 9>;

  <bb 9>:
  _30 = &MEM[(struct linux_binprm *)_324 + 184B];
  check_unsafe_exec.isra.21 (_30);
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___31 : "p" &current_task);
  pfo_ret___31->in_execve = 1;
  file_32 = do_open_execat (fd_4(D), filename_5(D), flags_6(D));
  ptr.4_35 = (long unsigned int) file_32;
  if (ptr.4_35 > 18446744073709547520)
    goto <bb 10>;
  else
    goto <bb 11>;

  <bb 10>:
  _33 = (long int) file_32;
  retval_34 = (int) _33;
  goto <bb 57> (out_unmark);

  <bb 11>:
  sched_exec ();
  MEM[(struct linux_binprm *)_324].file = file_32;
  if (fd_4(D) == -100)
    goto <bb 12>;
  else
    goto <bb 13>;

  <bb 12>:
  pretmp_155 = filename_5(D)->name;
  goto <bb 14>;

  <bb 13>:
  _39 = filename_5(D)->name;
  _40 = *_39;
  if (_40 == 47)
    goto <bb 14>;
  else
    goto <bb 15>;

  <bb 14>:
  # prephitmp_8 = PHI <pretmp_155(12), _39(13)>
  MEM[(struct linux_binprm *)_324].filename = prephitmp_8;
  goto <bb 22>;

  <bb 15>:
  if (_40 == 0)
    goto <bb 16>;
  else
    goto <bb 17>;

  <bb 16>:
  pathbuf_42 = kasprintf (524496, "/dev/fd/%d", fd_4(D));
  goto <bb 18>;

  <bb 17>:
  pathbuf_43 = kasprintf (524496, "/dev/fd/%d/%s", fd_4(D), _39);

  <bb 18>:
  # pathbuf_44 = PHI <pathbuf_42(16), pathbuf_43(17)>
  if (pathbuf_44 == 0B)
    goto <bb 57> (out_unmark);
  else
    goto <bb 19>;

  <bb 19>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___45 : "p" &current_task);
  _46 = pfo_ret___45->files;
  _47 ={v} MEM[(volatile __u64 *)_46 + 32B];
  ________p1_48 = (struct fdtable *) _47;
  _49 = MEM[(const struct fdtable *)________p1_48 + 16B];
  _347 = (long int) fd_4(D);
  __asm__ __volatile__("bt %2,%1
	sbb %0,%0" : "=r" oldbit_348 : "m" *_49, "Ir" _347);
  if (oldbit_348 != 0)
    goto <bb 20>;
  else
    goto <bb 21>;

  <bb 20>:
  _51 = MEM[(struct linux_binprm *)_324].interp_flags;
  _52 = _51 | 4;
  MEM[(struct linux_binprm *)_324].interp_flags = _52;

  <bb 21>:
  MEM[(struct linux_binprm *)_324].filename = pathbuf_44;

  <bb 22>:
  # pathbuf_135 = PHI <0B(14), pathbuf_44(21)>
  # prephitmp_315 = PHI <prephitmp_8(14), pathbuf_44(21)>
  MEM[(struct linux_binprm *)_324].interp = prephitmp_315;
  retval_54 = bprm_mm_init (_324);
  if (retval_54 != 0)
    goto <bb 57> (out_unmark);
  else
    goto <bb 23>;

  <bb 23>:
  retval_55 = count.isra.25.constprop.43 (0, __argv_2(D));
  MEM[(struct linux_binprm *)_324].argc = retval_55;
  if (retval_55 < 0)
    goto <bb 55> (out);
  else
    goto <bb 24>;

  <bb 24>:
  retval_56 = count.isra.25.constprop.43 (0, __envp_3(D));
  MEM[(struct linux_binprm *)_324].envc = retval_56;
  if (retval_56 < 0)
    goto <bb 55> (out);
  else
    goto <bb 25>;

  <bb 25>:
  bprm_fill_uid (_324);
  retval_57 = security_bprm_set_creds (_324);
  if (retval_57 != 0)
    goto <bb 27>;
  else
    goto <bb 26>;

  <bb 26>:
  MEM[(struct linux_binprm *)_324].cred_prepared = 1;
  _58 = &MEM[(struct linux_binprm *)_324].buf;
  memset (_58, 0, 128);
  _59 = MEM[(struct linux_binprm *)_324].file;
  retval_60 = kernel_read (_59, 0, _58, 128);

  <bb 27>:
  # retval_61 = PHI <retval_57(25), retval_60(26)>
  if (retval_61 < 0)
    goto <bb 55> (out);
  else
    goto <bb 28>;

  <bb 28>:
  _62 = &MEM[(struct linux_binprm *)_324].filename;
  retval_63 = copy_strings_kernel (1, _62, _324);
  if (retval_63 < 0)
    goto <bb 55> (out);
  else
    goto <bb 29>;

  <bb 29>:
  _64 = MEM[(struct linux_binprm *)_324].p;
  MEM[(struct linux_binprm *)_324].exec = _64;
  _65 = MEM[(struct linux_binprm *)_324].envc;
  retval_66 = copy_strings.isra.27 (_65, 0, __envp_3(D), _324);
  if (retval_66 < 0)
    goto <bb 55> (out);
  else
    goto <bb 30>;

  <bb 30>:
  _67 = MEM[(struct linux_binprm *)_324].argc;
  retval_68 = copy_strings.isra.27 (_67, 0, __argv_2(D), _324);
  if (retval_68 < 0)
    goto <bb 55> (out);
  else
    goto <bb 31>;

  <bb 31>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___69 : "p" &current_task);
  old_pid_70 = pfo_ret___69->pid;
  __asm__ __volatile__("" :  :  : "memory");
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___71 : "p" &current_task);
  _72 = pfo_ret___71->parent;
  _73 = task_active_pid_ns (_72);
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___74 : "p" &current_task);
  _351 = __task_pid_nr_ns (pfo_ret___74, 0, _73);
  __asm__ __volatile__("" :  :  : "memory");
  _76 = MEM[(struct linux_binprm *)_324].recursion_depth;
  if (_76 > 5)
    goto <bb 63>;
  else
    goto <bb 32>;

  <bb 32>:
  retval_77 = security_bprm_check (_324);
  if (retval_77 != 0)
    goto <bb 52>;
  else
    goto <bb 33>;

  <bb 33>:

  # need_retry_94 = PHI <1(33), 0(51)>
  # retval_146 = PHI <-2(33), retval_50(51)>
retry:
  _raw_read_lock (&binfmt_lock);
  fmt_78 = formats.next;
  _240 = &fmt_78->lh;
  if (_240 != &formats)
    goto <bb 35>;
  else
    goto <bb 45>;

  <bb 35>:

  <bb 36>:
  # fmt_164 = PHI <fmt_92(44), fmt_78(35)>
  # retval_254 = PHI <retval_148(44), retval_146(35)>
  _80 = fmt_164->module;
  _81 = try_module_get (_80);
  if (_81 != 0)
    goto <bb 37>;
  else
    goto <bb 43>;

  <bb 37>:
  __raw_read_unlock.constprop.42 ();
  _82 = MEM[(struct linux_binprm *)_324].recursion_depth;
  _83 = _82 + 1;
  MEM[(struct linux_binprm *)_324].recursion_depth = _83;
  _84 = fmt_164->load_binary;
  retval_85 = _84 (_324);
  _raw_read_lock (&binfmt_lock);
  _86 = MEM[(struct linux_binfmt *)fmt_164 + 16B];
  module_put (_86);
  _87 = MEM[(struct linux_binprm *)_324].recursion_depth;
  _88 = _87 + 4294967295;
  MEM[(struct linux_binprm *)_324].recursion_depth = _88;
  if (retval_85 < 0)
    goto <bb 38>;
  else
    goto <bb 42>;

  <bb 38>:
  _89 = MEM[(struct linux_binprm *)_324].mm;
  if (_89 == 0B)
    goto <bb 39>;
  else
    goto <bb 40>;

  <bb 39>:
  __raw_read_unlock.constprop.42 ();
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___90 : "p" &current_task);
  force_sigsegv (11, pfo_ret___90);
  goto <bb 63>;

  <bb 40>:
  if (retval_85 != -8)
    goto <bb 42>;
  else
    goto <bb 41>;

  <bb 41>:
  _91 = MEM[(struct linux_binprm *)_324].file;
  if (_91 == 0B)
    goto <bb 42>;
  else
    goto <bb 43>;

  <bb 42>:
  # retval_333 = PHI <retval_85(37), retval_85(41), retval_85(40)>
  __raw_read_unlock.constprop.42 ();
  goto <bb 52>;

  <bb 43>:
  # retval_148 = PHI <retval_254(36), retval_85(41)>
  fmt_92 = fmt_164->lh.next;
  _93 = &fmt_92->lh;
  if (_93 != &formats)
    goto <bb 44>;
  else
    goto <bb 45>;

  <bb 44>:
  goto <bb 36>;

  <bb 45>:
  # retval_50 = PHI <retval_148(43), retval_146(34)>
  __raw_read_unlock.constprop.42 ();
  if (need_retry_94 != 0)
    goto <bb 46>;
  else
    goto <bb 52>;

  <bb 46>:
  _95 = MEM[(struct linux_binprm *)_324].buf[0];
  _96 = (unsigned char) _95;
  _97 = _96 + 247;
  _98 = _97 <= 1;
  _99 = _96 + 224;
  _100 = _99 <= 94;
  _101 = _100 | _98;
  if (_101 != 0)
    goto <bb 47>;
  else
    goto <bb 50>;

  <bb 47>:
  _102 = MEM[(struct linux_binprm *)_324].buf[1];
  _103 = (unsigned char) _102;
  _104 = _103 + 247;
  _105 = _104 <= 1;
  _106 = _103 + 224;
  _107 = _106 <= 94;
  _108 = _107 | _105;
  if (_108 != 0)
    goto <bb 48>;
  else
    goto <bb 50>;

  <bb 48>:
  _109 = MEM[(struct linux_binprm *)_324].buf[2];
  _110 = (unsigned char) _109;
  _111 = _110 + 247;
  _112 = _111 <= 1;
  _113 = _110 + 224;
  _114 = _113 <= 94;
  _115 = _114 | _112;
  if (_115 != 0)
    goto <bb 49>;
  else
    goto <bb 50>;

  <bb 49>:
  _116 = MEM[(struct linux_binprm *)_324].buf[3];
  _117 = (unsigned char) _116;
  _118 = _117 + 247;
  _119 = _118 <= 1;
  _120 = _117 + 224;
  _121 = _120 <= 94;
  _122 = _121 | _119;
  if (_122 != 0)
    goto <bb 52>;
  else
    goto <bb 50>;

  <bb 50>:
  _123 = MEM[(ushort *)_324 + 2B];
  _124 = (int) _123;
  _125 = __request_module (1, "binfmt-%04x", _124);
  if (_125 < 0)
    goto <bb 52>;
  else
    goto <bb 51>;

  <bb 51>:
  goto <bb 34> (retry);

  <bb 52>:
  # retval_126 = PHI <retval_50(49), retval_77(32), retval_50(50), retval_333(42), retval_50(45)>
  if (retval_126 >= 0)
    goto <bb 53>;
  else
    goto <bb 64>;

  <bb 53>:
  audit_bprm (_324);
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___127 : "p" &current_task);
  trace_sched_process_exec (pfo_ret___127, old_pid_70, _324);
  _128 = (long unsigned int) _351;
  ptrace_event.constprop.37 (_128);
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___129 : "p" &current_task);
  proc_exec_connector (pfo_ret___129);
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___130 : "p" &current_task);
  _131 = pfo_ret___130->fs;
  _131->in_exec = 0;
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___132 : "p" &current_task);
  pfo_ret___132->in_execve = 0;
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___133 : "p" &current_task);
  acct_update_integrals (pfo_ret___133);
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___134 : "p" &current_task);
  free_bprm (_324);
  kfree (pathbuf_135);
  putname (filename_5(D));
  displaced.82_136 = displaced;
  if (displaced.82_136 != 0B)
    goto <bb 54>;
  else
    goto <bb 62>;

  <bb 54>:
  put_files_struct (displaced.82_136);
  goto <bb 62>;

  # retval_149 = PHI <retval_55(23), retval_56(24), retval_61(27), retval_63(28), retval_66(29), retval_68(30), retval_252(64)>
out:
  _137 = MEM[(struct linux_binprm *)_324].mm;
  if (_137 != 0B)
    goto <bb 56>;
  else
    goto <bb 57> (out_unmark);

  <bb 56>:
  _138 = &MEM[(struct linux_binprm *)_324 + 136B];
  acct_arg_size.isra.16 (_138, 0);
  _139 = MEM[(struct linux_binprm *)_324].mm;
  mmput (_139);

  # pathbuf_150 = PHI <0B(10), pathbuf_44(18), pathbuf_135(22), pathbuf_135(55), pathbuf_135(56)>
  # retval_151 = PHI <retval_34(10), -12(18), retval_54(22), retval_149(55), retval_149(56)>
out_unmark:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___140 : "p" &current_task);
  _141 = pfo_ret___140->fs;
  _141->in_exec = 0;
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___142 : "p" &current_task);
  pfo_ret___142->in_execve = 0;

  # pathbuf_143 = PHI <0B(8), pathbuf_150(57)>
  # retval_152 = PHI <retval_29(8), retval_151(57)>
out_free:
  free_bprm (_324);
  kfree (pathbuf_143);

  # retval_153 = PHI <-12(7), retval_152(58)>
out_files:
  displaced.82_144 = displaced;
  if (displaced.82_144 != 0B)
    goto <bb 60>;
  else
    goto <bb 61> (out_ret);

  <bb 60>:
  reset_files_struct (displaced.82_144);

  # retval_154 = PHI <-11(5), retval_27(6), retval_153(59), retval_153(60)>
out_ret:
  putname (filename_5(D));

  <bb 62>:
  # _145 = PHI <_14(3), retval_126(54), retval_154(61), retval_126(53)>
  displaced ={v} {CLOBBER};
  return _145;

  <bb 63>:
  # retval_257 = PHI <retval_85(39), -40(31)>

  <bb 64>:
  # retval_252 = PHI <retval_257(63), retval_126(52)>
  goto <bb 55> (out);

}



;; Function set_dumpable (set_dumpable, funcdef_no=2894, decl_uid=22300, cgraph_uid=2895)

set_dumpable (struct mm_struct * mm, int value)
{
  long unsigned int __new;
  long unsigned int __old;
  long unsigned int __ret;
  unsigned int value.166;
  long unsigned int pretmp_6;
  long unsigned int * pretmp_7;
  long unsigned int _13;

  <bb 2>:
  value.166_5 = (unsigned int) value_4(D);
  if (value.166_5 > 2)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  warn_slowpath_null ("fs/exec.c", 1701);
  goto <bb 7>;

  <bb 4>:
  pretmp_6 = (long unsigned int) value_4(D);
  pretmp_7 = &mm_11(D)->flags;

  <bb 5>:
  __old_12 ={v} MEM[(volatile long unsigned int *)mm_11(D) + 800B];
  _13 = __old_12 & 18446744073709551612;
  __new_15 = pretmp_6 | _13;
  __asm__ __volatile__(".pushsection .smp_locks,"a"
.balign 4
.long 671f - .
.popsection
671:
	lock; cmpxchgq %2,%1" : "=a" __ret_19, "=m" MEM[(volatile u64 *)pretmp_7] : "r" __new_15, "0" __old_12, "m" MEM[(volatile u64 *)pretmp_7] : "memory");
  if (__old_12 != __ret_19)
    goto <bb 6>;
  else
    goto <bb 7>;

  <bb 6>:
  goto <bb 5>;

  <bb 7>:
  return;

}



;; Function setup_new_exec (setup_new_exec, funcdef_no=2877, decl_uid=30460, cgraph_uid=2878)

setup_new_exec (struct linux_binprm * bprm)
{
  gid_t right;
  gid_t left;
  uid_t right;
  uid_t left;
  gid_t right;
  gid_t left;
  uid_t right;
  uid_t left;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  u64 pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  const char * iftmp.77;
  const char * tail;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  long unsigned int iftmp.75;
  int suid_dumpable.74;
  struct mm_struct * _6;
  const struct cred * _10;
  const struct cred * _11;
  const struct cred * _12;
  const struct cred * _13;
  struct mm_struct * _14;
  struct mm_struct * _17;
  const char * _21;
  struct mm_struct * _23;
  unsigned int _25;
  unsigned int _26;
  const struct cred * _28;
  struct cred * _29;
  const struct cred * _30;
  struct file * _31;
  unsigned int _33;
  unsigned int _34;
  struct mm_struct * _36;
  unsigned int _39;
  unsigned int _40;
  struct files_struct * _43;
  long unsigned int _60;
  struct thread_info * _61;
  long unsigned int _62;
  long unsigned int _63;
  long unsigned int _64;

  <bb 2>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___45 : "p" &current_task);
  _6 = pfo_ret___45->mm;
  arch_pick_mmap_layout (_6);
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___46 : "p" &current_task);
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___47 : "p" &current_task);
  pfo_ret___47->sas_ss_size = 0;
  pfo_ret___46->sas_ss_sp = 0;
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___48 : "p" &current_task);
  _10 = pfo_ret___48->cred;
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___49 : "p" &current_task);
  _11 = pfo_ret___49->cred;
  left_80 = MEM[(const struct cred *)_11 + 20B];
  right_79 = MEM[(const struct cred *)_10 + 4B];
  if (right_79 == left_80)
    goto <bb 3>;
  else
    goto <bb 5>;

  <bb 3>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___50 : "p" &current_task);
  _12 = pfo_ret___50->cred;
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___51 : "p" &current_task);
  _13 = pfo_ret___51->cred;
  left_78 = MEM[(const struct cred *)_13 + 24B];
  right_77 = MEM[(const struct cred *)_12 + 8B];
  if (right_77 == left_78)
    goto <bb 4>;
  else
    goto <bb 5>;

  <bb 4>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___52 : "p" &current_task);
  _14 = pfo_ret___52->mm;
  set_dumpable (_14, 1);
  goto <bb 6>;

  <bb 5>:
  suid_dumpable.74_16 = suid_dumpable;
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___53 : "p" &current_task);
  _17 = pfo_ret___53->mm;
  set_dumpable (_17, suid_dumpable.74_16);

  <bb 6>:
  perf_event_exec ();
  _21 = bprm_20(D)->filename;
  tail_54 = strrchr (_21, 47);
  if (tail_54 != 0B)
    goto <bb 7>;
  else
    goto <bb 8>;

  <bb 7>:
  iftmp.77_55 = tail_54 + 1;

  <bb 8>:
  # iftmp.77_56 = PHI <_21(6), iftmp.77_55(7)>
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___57 : "p" &current_task);
  __set_task_comm (pfo_ret___57, iftmp.77_56, 1);
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___58 : "p" &current_task);
  _23 = pfo_ret___58->mm;
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___59 : "p" &cpu_tss.x86_tss.sp0);
  _60 = pfo_ret___59 + 18446744073709535232;
  _61 = (struct thread_info *) _60;
  _62 ={v} MEM[(const long unsigned int *)_61 + 8B];
  _63 = _62 >> 29;
  _64 = _63 & 1;
  if (_64 != 0)
    goto <bb 9>;
  else
    goto <bb 11>;

  <bb 9>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___65 : "p" &current_task);
  _25 = pfo_ret___65->personality;
  _26 = _25 & 134217728;
  if (_26 != 0)
    goto <bb 10>;
  else
    goto <bb 11>;

  <bb 10>:

  <bb 11>:
  # iftmp.75_1 = PHI <4294959104(9), 140737488351232(8), 3221225472(10)>
  _23->task_size = iftmp.75_1;
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___66 : "p" &current_task);
  _28 = pfo_ret___66->cred;
  _29 = bprm_20(D)->cred;
  left_76 = MEM[(struct cred *)_29 + 4B];
  right_75 = MEM[(const struct cred *)_28 + 20B];
  if (right_75 != left_76)
    goto <bb 13>;
  else
    goto <bb 12>;

  <bb 12>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___67 : "p" &current_task);
  _30 = pfo_ret___67->cred;
  left_74 = MEM[(struct cred *)_29 + 8B];
  right_73 = MEM[(const struct cred *)_30 + 24B];
  if (right_73 != left_74)
    goto <bb 13>;
  else
    goto <bb 14>;

  <bb 13>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___68 : "p" &current_task);
  pfo_ret___68->pdeath_signal = 0;
  goto <bb 16>;

  <bb 14>:
  _31 = bprm_20(D)->file;
  would_dump (bprm_20(D), _31);
  _33 = bprm_20(D)->interp_flags;
  _34 = _33 & 1;
  if (_34 != 0)
    goto <bb 15>;
  else
    goto <bb 16>;

  <bb 15>:
  suid_dumpable.74_35 = suid_dumpable;
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___69 : "p" &current_task);
  _36 = pfo_ret___69->mm;
  set_dumpable (_36, suid_dumpable.74_35);

  <bb 16>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___70 : "p" &current_task);
  _39 = pfo_ret___70->self_exec_id;
  _40 = _39 + 1;
  pfo_ret___70->self_exec_id = _40;
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___71 : "p" &current_task);
  flush_signal_handlers (pfo_ret___71, 0);
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___72 : "p" &current_task);
  _43 = pfo_ret___72->files;
  do_close_on_exec (_43);
  return;

}



;; Function SyS_execve (SyS_execve, funcdef_no=2895, decl_uid=41240, cgraph_uid=2897)

SyS_execve (long int filename, long int argv, long int envp)
{
  struct task_struct * pfo_ret__;
  struct files_struct * displaced.82;
  struct file * file;
  struct files_struct * displaced;
  int retval;
  long unsigned int ptr.4;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  long unsigned int ptr.4;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  bool need_retry;
  struct linux_binfmt * fmt;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  pid_t old_pid;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  const char * filename.169;
  const char * const * argv.168;
  const char * const * envp.167;
  struct filename * _10;
  long int _15;
  int _16;
  unsigned int _18;
  unsigned int _19;
  const struct cred * _21;
  struct user_struct * _22;
  int _23;
  long unsigned int _24;
  unsigned int _27;
  unsigned int _28;
  int * _32;
  long int _35;
  const char * _41;
  char[128] * _46;
  struct file * _47;
  const char * * _50;
  long unsigned int _52;
  int _53;
  int _55;
  struct task_struct * _60;
  struct pid_namespace * _61;
  long int pretmp_63;
  unsigned int _64;
  long int pretmp_67;
  struct module * _68;
  _Bool _69;
  unsigned int _70;
  unsigned int _71;
  int (*<T4b2d>) (struct linux_binprm *) _72;
  struct module * _74;
  unsigned int _75;
  unsigned int _76;
  struct mm_struct * _77;
  struct file * _79;
  struct list_head * _81;
  char _83;
  unsigned char _84;
  unsigned char _85;
  _Bool _86;
  unsigned char _87;
  _Bool _88;
  _Bool _89;
  char _90;
  unsigned char _91;
  unsigned char _92;
  _Bool _93;
  unsigned char _94;
  _Bool _95;
  _Bool _96;
  char _97;
  unsigned char _98;
  unsigned char _99;
  _Bool _100;
  unsigned char _101;
  _Bool _102;
  _Bool _103;
  char _104;
  unsigned char _105;
  unsigned char _106;
  _Bool _107;
  unsigned char _108;
  _Bool _109;
  _Bool _110;
  short unsigned int _111;
  int _112;
  int _113;
  long unsigned int _116;
  struct fs_struct * _119;
  struct mm_struct * _124;
  long unsigned int * _125;
  struct mm_struct * _126;
  struct fs_struct * _128;
  long int pretmp_136;
  struct signal_struct * _144;
  long long unsigned int _145;
  struct list_head * _148;
  struct kmem_cache * _225;
  void * _226;
  long int prephitmp_234;
  pid_t _236;
  long int pretmp_237;
  long int prephitmp_239;
  long int pretmp_243;
  long int prephitmp_246;

  <bb 2>:
  filename.169_6 = (const char *) filename_5(D);
  _10 = getname (filename.169_6);
  ptr.4_11 = (long unsigned int) _10;
  if (ptr.4_11 > 18446744073709547520)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _15 = (long int) _10;
  _16 = (int) _15;
  pretmp_136 = (long int) _16;
  goto <bb 53>;

  <bb 4>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___17 : "p" &current_task);
  _18 = pfo_ret___17->flags;
  _19 = _18 & 4096;
  if (_19 != 0)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___20 : "p" &current_task);
  _21 = pfo_ret___20->cred;
  _22 = _21->user;
  _23 ={v} MEM[(const int *)_22 + 4B];
  _24 = (long unsigned int) _23;
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___143 : "p" &current_task);
  _144 = MEM[(const struct task_struct *)pfo_ret___143].signal;
  _145 ={v} MEM[(volatile __u64 *)_144].rlim[6].rlim_cur;
  if (_24 > _145)
    goto <bb 52> (out_ret);
  else
    goto <bb 6>;

  <bb 6>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___26 : "p" &current_task);
  _27 = pfo_ret___26->flags;
  _28 = _27 & 4294963199;
  pfo_ret___26->flags = _28;
  retval_29 = unshare_files (&displaced);
  if (retval_29 != 0)
    goto <bb 7>;
  else
    goto <bb 8>;

  <bb 7>:
  pretmp_237 = (long int) retval_29;
  goto <bb 52> (out_ret);

  <bb 8>:
  _225 = kmalloc_caches[8];
  _226 = kmem_cache_alloc_trace (_225, 32976, 240);
  if (_226 == 0B)
    goto <bb 50> (out_files);
  else
    goto <bb 9>;

  <bb 9>:
  retval_31 = prepare_bprm_creds (_226);
  if (retval_31 != 0)
    goto <bb 49> (out_free);
  else
    goto <bb 10>;

  <bb 10>:
  _32 = &MEM[(struct linux_binprm *)_226 + 184B];
  check_unsafe_exec.isra.21 (_32);
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___33 : "p" &current_task);
  pfo_ret___33->in_execve = 1;
  file_34 = do_open_execat (-100, _10, 0);
  ptr.4_37 = (long unsigned int) file_34;
  if (ptr.4_37 > 18446744073709547520)
    goto <bb 11>;
  else
    goto <bb 12>;

  <bb 11>:
  _35 = (long int) file_34;
  retval_36 = (int) _35;
  goto <bb 48> (out_unmark);

  <bb 12>:
  sched_exec ();
  MEM[(struct linux_binprm *)_226].file = file_34;
  _41 = _10->name;
  MEM[(struct linux_binprm *)_226].filename = _41;
  MEM[(struct linux_binprm *)_226].interp = _41;
  retval_42 = bprm_mm_init (_226);
  if (retval_42 != 0)
    goto <bb 48> (out_unmark);
  else
    goto <bb 13>;

  <bb 13>:
  argv.168_4 = (const char * const *) argv_3(D);
  retval_43 = count.isra.25.constprop.43 (0, argv.168_4);
  MEM[(struct linux_binprm *)_226].argc = retval_43;
  if (retval_43 < 0)
    goto <bb 46> (out);
  else
    goto <bb 14>;

  <bb 14>:
  envp.167_2 = (const char * const *) envp_1(D);
  retval_44 = count.isra.25.constprop.43 (0, envp.167_2);
  MEM[(struct linux_binprm *)_226].envc = retval_44;
  if (retval_44 < 0)
    goto <bb 46> (out);
  else
    goto <bb 15>;

  <bb 15>:
  bprm_fill_uid (_226);
  retval_45 = security_bprm_set_creds (_226);
  if (retval_45 != 0)
    goto <bb 17>;
  else
    goto <bb 16>;

  <bb 16>:
  MEM[(struct linux_binprm *)_226].cred_prepared = 1;
  _46 = &MEM[(struct linux_binprm *)_226].buf;
  memset (_46, 0, 128);
  _47 = MEM[(struct linux_binprm *)_226].file;
  retval_48 = kernel_read (_47, 0, _46, 128);

  <bb 17>:
  # retval_49 = PHI <retval_45(15), retval_48(16)>
  if (retval_49 < 0)
    goto <bb 46> (out);
  else
    goto <bb 18>;

  <bb 18>:
  _50 = &MEM[(struct linux_binprm *)_226].filename;
  retval_51 = copy_strings_kernel (1, _50, _226);
  if (retval_51 < 0)
    goto <bb 46> (out);
  else
    goto <bb 19>;

  <bb 19>:
  _52 = MEM[(struct linux_binprm *)_226].p;
  MEM[(struct linux_binprm *)_226].exec = _52;
  _53 = MEM[(struct linux_binprm *)_226].envc;
  retval_54 = copy_strings.isra.27 (_53, 0, envp.167_2, _226);
  if (retval_54 < 0)
    goto <bb 46> (out);
  else
    goto <bb 20>;

  <bb 20>:
  _55 = MEM[(struct linux_binprm *)_226].argc;
  retval_56 = copy_strings.isra.27 (_55, 0, argv.168_4, _226);
  if (retval_56 < 0)
    goto <bb 46> (out);
  else
    goto <bb 21>;

  <bb 21>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___57 : "p" &current_task);
  old_pid_58 = pfo_ret___57->pid;
  __asm__ __volatile__("" :  :  : "memory");
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___59 : "p" &current_task);
  _60 = pfo_ret___59->parent;
  _61 = task_active_pid_ns (_60);
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___62 : "p" &current_task);
  _236 = __task_pid_nr_ns (pfo_ret___62, 0, _61);
  __asm__ __volatile__("" :  :  : "memory");
  _64 = MEM[(struct linux_binprm *)_226].recursion_depth;
  if (_64 > 5)
    goto <bb 54>;
  else
    goto <bb 22>;

  <bb 22>:
  retval_65 = security_bprm_check (_226);
  if (retval_65 != 0)
    goto <bb 42>;
  else
    goto <bb 23>;

  <bb 23>:

  # need_retry_82 = PHI <1(23), 0(41)>
  # retval_135 = PHI <-2(23), retval_179(41)>
retry:
  _raw_read_lock (&binfmt_lock);
  fmt_66 = formats.next;
  _148 = &fmt_66->lh;
  if (_148 != &formats)
    goto <bb 25>;
  else
    goto <bb 35>;

  <bb 25>:

  <bb 26>:
  # fmt_249 = PHI <fmt_80(34), fmt_66(25)>
  # retval_250 = PHI <retval_137(34), retval_135(25)>
  _68 = fmt_249->module;
  _69 = try_module_get (_68);
  if (_69 != 0)
    goto <bb 27>;
  else
    goto <bb 33>;

  <bb 27>:
  __raw_read_unlock.constprop.42 ();
  _70 = MEM[(struct linux_binprm *)_226].recursion_depth;
  _71 = _70 + 1;
  MEM[(struct linux_binprm *)_226].recursion_depth = _71;
  _72 = fmt_249->load_binary;
  retval_73 = _72 (_226);
  _raw_read_lock (&binfmt_lock);
  _74 = MEM[(struct linux_binfmt *)fmt_249 + 16B];
  module_put (_74);
  _75 = MEM[(struct linux_binprm *)_226].recursion_depth;
  _76 = _75 + 4294967295;
  MEM[(struct linux_binprm *)_226].recursion_depth = _76;
  if (retval_73 < 0)
    goto <bb 28>;
  else
    goto <bb 32>;

  <bb 28>:
  _77 = MEM[(struct linux_binprm *)_226].mm;
  if (_77 == 0B)
    goto <bb 29>;
  else
    goto <bb 30>;

  <bb 29>:
  __raw_read_unlock.constprop.42 ();
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___78 : "p" &current_task);
  force_sigsegv (11, pfo_ret___78);
  goto <bb 54>;

  <bb 30>:
  if (retval_73 != -8)
    goto <bb 32>;
  else
    goto <bb 31>;

  <bb 31>:
  _79 = MEM[(struct linux_binprm *)_226].file;
  if (_79 == 0B)
    goto <bb 32>;
  else
    goto <bb 33>;

  <bb 32>:
  # retval_133 = PHI <retval_73(27), retval_73(31), retval_73(30)>
  __raw_read_unlock.constprop.42 ();
  goto <bb 42>;

  <bb 33>:
  # retval_137 = PHI <retval_250(26), retval_73(31)>
  fmt_80 = fmt_249->lh.next;
  _81 = &fmt_80->lh;
  if (_81 != &formats)
    goto <bb 34>;
  else
    goto <bb 35>;

  <bb 34>:
  goto <bb 26>;

  <bb 35>:
  # retval_179 = PHI <retval_137(33), retval_135(24)>
  __raw_read_unlock.constprop.42 ();
  if (need_retry_82 != 0)
    goto <bb 36>;
  else
    goto <bb 42>;

  <bb 36>:
  _83 = MEM[(struct linux_binprm *)_226].buf[0];
  _84 = (unsigned char) _83;
  _85 = _84 + 247;
  _86 = _85 <= 1;
  _87 = _84 + 224;
  _88 = _87 <= 94;
  _89 = _88 | _86;
  if (_89 != 0)
    goto <bb 37>;
  else
    goto <bb 40>;

  <bb 37>:
  _90 = MEM[(struct linux_binprm *)_226].buf[1];
  _91 = (unsigned char) _90;
  _92 = _91 + 247;
  _93 = _92 <= 1;
  _94 = _91 + 224;
  _95 = _94 <= 94;
  _96 = _95 | _93;
  if (_96 != 0)
    goto <bb 38>;
  else
    goto <bb 40>;

  <bb 38>:
  _97 = MEM[(struct linux_binprm *)_226].buf[2];
  _98 = (unsigned char) _97;
  _99 = _98 + 247;
  _100 = _99 <= 1;
  _101 = _98 + 224;
  _102 = _101 <= 94;
  _103 = _102 | _100;
  if (_103 != 0)
    goto <bb 39>;
  else
    goto <bb 40>;

  <bb 39>:
  _104 = MEM[(struct linux_binprm *)_226].buf[3];
  _105 = (unsigned char) _104;
  _106 = _105 + 247;
  _107 = _106 <= 1;
  _108 = _105 + 224;
  _109 = _108 <= 94;
  _110 = _109 | _107;
  if (_110 != 0)
    goto <bb 42>;
  else
    goto <bb 40>;

  <bb 40>:
  _111 = MEM[(ushort *)_226 + 2B];
  _112 = (int) _111;
  _113 = __request_module (1, "binfmt-%04x", _112);
  if (_113 < 0)
    goto <bb 42>;
  else
    goto <bb 41>;

  <bb 41>:
  goto <bb 24> (retry);

  <bb 42>:
  # retval_114 = PHI <retval_179(39), retval_65(22), retval_179(40), retval_133(32), retval_179(35)>
  if (retval_114 >= 0)
    goto <bb 43>;
  else
    goto <bb 55>;

  <bb 43>:
  audit_bprm (_226);
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___115 : "p" &current_task);
  trace_sched_process_exec (pfo_ret___115, old_pid_58, _226);
  _116 = (long unsigned int) _236;
  ptrace_event.constprop.37 (_116);
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___117 : "p" &current_task);
  proc_exec_connector (pfo_ret___117);
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___118 : "p" &current_task);
  _119 = pfo_ret___118->fs;
  _119->in_exec = 0;
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___120 : "p" &current_task);
  pfo_ret___120->in_execve = 0;
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___121 : "p" &current_task);
  acct_update_integrals (pfo_ret___121);
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___122 : "p" &current_task);
  free_bprm (_226);
  kfree (0B);
  putname (_10);
  displaced.82_123 = displaced;
  if (displaced.82_123 != 0B)
    goto <bb 45>;
  else
    goto <bb 44>;

  <bb 44>:
  pretmp_67 = (long int) retval_114;
  goto <bb 53>;

  <bb 45>:
  put_files_struct (displaced.82_123);
  pretmp_243 = (long int) retval_114;
  goto <bb 53>;

  # retval_138 = PHI <retval_43(13), retval_44(14), retval_49(17), retval_51(18), retval_54(19), retval_56(20), retval_247(55)>
out:
  _124 = MEM[(struct linux_binprm *)_226].mm;
  if (_124 != 0B)
    goto <bb 47>;
  else
    goto <bb 48> (out_unmark);

  <bb 47>:
  _125 = &MEM[(struct linux_binprm *)_226 + 136B];
  acct_arg_size.isra.16 (_125, 0);
  _126 = MEM[(struct linux_binprm *)_226].mm;
  mmput (_126);

  # retval_139 = PHI <retval_36(11), retval_42(12), retval_138(46), retval_138(47)>
out_unmark:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___127 : "p" &current_task);
  _128 = pfo_ret___127->fs;
  _128->in_exec = 0;
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___129 : "p" &current_task);
  pfo_ret___129->in_execve = 0;

  # retval_140 = PHI <retval_31(9), retval_139(48)>
out_free:
  free_bprm (_226);
  kfree (0B);
  pretmp_63 = (long int) retval_140;

  # prephitmp_234 = PHI <-12(8), pretmp_63(49)>
out_files:
  displaced.82_130 = displaced;
  if (displaced.82_130 != 0B)
    goto <bb 51>;
  else
    goto <bb 52> (out_ret);

  <bb 51>:
  reset_files_struct (displaced.82_130);

  # prephitmp_239 = PHI <-11(5), pretmp_237(7), prephitmp_234(50), prephitmp_234(51)>
out_ret:
  putname (_10);

  <bb 53>:
  # prephitmp_246 = PHI <pretmp_136(3), pretmp_67(44), pretmp_243(45), prephitmp_239(52)>
  displaced ={v} {CLOBBER};
  return prephitmp_246;

  <bb 54>:
  # retval_252 = PHI <retval_73(29), -40(21)>

  <bb 55>:
  # retval_247 = PHI <retval_252(54), retval_114(42)>
  goto <bb 46> (out);

}



;; Function SyS_execveat (SyS_execveat, funcdef_no=2897, decl_uid=41278, cgraph_uid=2900)

SyS_execveat (long int fd, long int filename, long int argv, long int envp, long int flags)
{
  int oldbit;
  struct task_struct * pfo_ret__;
  int lookup_flags;
  struct files_struct * displaced.82;
  char * pathbuf;
  struct file * file;
  struct files_struct * displaced;
  int retval;
  struct fdtable * ________p1;
  long unsigned int ptr.4;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  long unsigned int ptr.4;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  bool need_retry;
  struct linux_binfmt * fmt;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  pid_t old_pid;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  const char * filename.172;
  const char * const * argv.171;
  const char * const * envp.170;
  int _2;
  int _10;
  long int pretmp_13;
  int _14;
  struct filename * _16;
  long int _21;
  int _22;
  unsigned int _24;
  unsigned int _25;
  const struct cred * _27;
  struct user_struct * _28;
  int _29;
  long unsigned int _30;
  unsigned int _33;
  unsigned int _34;
  int * _38;
  long int _41;
  const char * _47;
  char _48;
  struct files_struct * _54;
  long long unsigned int _55;
  long unsigned int * _57;
  unsigned int _59;
  unsigned int _60;
  char[128] * _66;
  struct file * _67;
  const char * * _70;
  long unsigned int _72;
  int _73;
  int _75;
  struct task_struct * _80;
  struct pid_namespace * _81;
  long int prephitmp_83;
  unsigned int _84;
  struct module * _88;
  _Bool _89;
  unsigned int _90;
  unsigned int _91;
  int (*<T4b2d>) (struct linux_binprm *) _92;
  struct module * _94;
  unsigned int _95;
  unsigned int _96;
  struct mm_struct * _97;
  struct file * _99;
  struct list_head * _101;
  char _103;
  unsigned char _104;
  unsigned char _105;
  _Bool _106;
  unsigned char _107;
  _Bool _108;
  _Bool _109;
  char _110;
  unsigned char _111;
  unsigned char _112;
  _Bool _113;
  unsigned char _114;
  _Bool _115;
  _Bool _116;
  char _117;
  unsigned char _118;
  unsigned char _119;
  _Bool _120;
  unsigned char _121;
  _Bool _122;
  _Bool _123;
  char _124;
  unsigned char _125;
  unsigned char _126;
  _Bool _127;
  unsigned char _128;
  _Bool _129;
  _Bool _130;
  short unsigned int _131;
  int _132;
  int _133;
  long unsigned int _136;
  struct fs_struct * _139;
  struct mm_struct * _145;
  long unsigned int * _146;
  struct mm_struct * _147;
  struct fs_struct * _149;
  long int pretmp_156;
  long int prephitmp_158;
  struct signal_struct * _167;
  long long unsigned int _168;
  long int pretmp_172;
  struct list_head * _241;
  struct kmem_cache * _248;
  void * _249;
  long int prephitmp_261;
  long int pretmp_262;
  long int pretmp_263;
  long int pretmp_264;
  long int pretmp_265;
  long int prephitmp_266;
  const char * prephitmp_267;
  const char * pretmp_268;
  const char * prephitmp_269;
  long int pretmp_270;
  long int _272;
  pid_t _276;
  long int pretmp_287;
  long int prephitmp_299;

  <bb 2>:
  _2 = (int) flags_1(D);
  filename.172_8 = (const char *) filename_7(D);
  _14 = _2 & 4096;
  if (_14 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:

  <bb 4>:
  # lookup_flags_15 = PHI <16384(3), 0(2)>
  _16 = getname_flags (filename.172_8, lookup_flags_15, 0B);
  ptr.4_17 = (long unsigned int) _16;
  if (ptr.4_17 > 18446744073709547520)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  _21 = (long int) _16;
  _22 = (int) _21;
  pretmp_270 = (long int) _22;
  goto <bb 69>;

  <bb 6>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___23 : "p" &current_task);
  _24 = pfo_ret___23->flags;
  _25 = _24 & 4096;
  if (_25 != 0)
    goto <bb 7>;
  else
    goto <bb 8>;

  <bb 7>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___26 : "p" &current_task);
  _27 = pfo_ret___26->cred;
  _28 = _27->user;
  _29 ={v} MEM[(const int *)_28 + 4B];
  _30 = (long unsigned int) _29;
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___166 : "p" &current_task);
  _167 = MEM[(const struct task_struct *)pfo_ret___166].signal;
  _168 ={v} MEM[(volatile __u64 *)_167].rlim[6].rlim_cur;
  if (_30 > _168)
    goto <bb 68> (out_ret);
  else
    goto <bb 8>;

  <bb 8>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___32 : "p" &current_task);
  _33 = pfo_ret___32->flags;
  _34 = _33 & 4294963199;
  pfo_ret___32->flags = _34;
  retval_35 = unshare_files (&displaced);
  if (retval_35 != 0)
    goto <bb 9>;
  else
    goto <bb 10>;

  <bb 9>:
  pretmp_156 = (long int) retval_35;
  goto <bb 68> (out_ret);

  <bb 10>:
  _248 = kmalloc_caches[8];
  _249 = kmem_cache_alloc_trace (_248, 32976, 240);
  if (_249 == 0B)
    goto <bb 66> (out_files);
  else
    goto <bb 11>;

  <bb 11>:
  retval_37 = prepare_bprm_creds (_249);
  if (retval_37 != 0)
    goto <bb 12>;
  else
    goto <bb 13>;

  <bb 12>:
  pretmp_172 = (long int) retval_37;
  goto <bb 65> (out_free);

  <bb 13>:
  _10 = (int) fd_9(D);
  _38 = &MEM[(struct linux_binprm *)_249 + 184B];
  check_unsafe_exec.isra.21 (_38);
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___39 : "p" &current_task);
  pfo_ret___39->in_execve = 1;
  file_40 = do_open_execat (_10, _16, _2);
  ptr.4_43 = (long unsigned int) file_40;
  if (ptr.4_43 > 18446744073709547520)
    goto <bb 14>;
  else
    goto <bb 15>;

  <bb 14>:
  _41 = (long int) file_40;
  retval_42 = (int) _41;
  pretmp_262 = (long int) retval_42;
  goto <bb 64> (out_unmark);

  <bb 15>:
  sched_exec ();
  MEM[(struct linux_binprm *)_249].file = file_40;
  if (_10 == -100)
    goto <bb 16>;
  else
    goto <bb 17>;

  <bb 16>:
  pretmp_268 = _16->name;
  goto <bb 18>;

  <bb 17>:
  _47 = _16->name;
  _48 = *_47;
  if (_48 == 47)
    goto <bb 18>;
  else
    goto <bb 19>;

  <bb 18>:
  # prephitmp_269 = PHI <pretmp_268(16), _47(17)>
  MEM[(struct linux_binprm *)_249].filename = prephitmp_269;
  goto <bb 26>;

  <bb 19>:
  if (_48 == 0)
    goto <bb 20>;
  else
    goto <bb 21>;

  <bb 20>:
  pathbuf_50 = kasprintf (524496, "/dev/fd/%d", _10);
  goto <bb 22>;

  <bb 21>:
  pathbuf_51 = kasprintf (524496, "/dev/fd/%d/%s", _10, _47);

  <bb 22>:
  # pathbuf_52 = PHI <pathbuf_50(20), pathbuf_51(21)>
  if (pathbuf_52 == 0B)
    goto <bb 64> (out_unmark);
  else
    goto <bb 23>;

  <bb 23>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___53 : "p" &current_task);
  _54 = pfo_ret___53->files;
  _55 ={v} MEM[(volatile __u64 *)_54 + 32B];
  ________p1_56 = (struct fdtable *) _55;
  _57 = MEM[(const struct fdtable *)________p1_56 + 16B];
  _272 = (long int) _10;
  __asm__ __volatile__("bt %2,%1
	sbb %0,%0" : "=r" oldbit_273 : "m" *_57, "Ir" _272);
  if (oldbit_273 != 0)
    goto <bb 24>;
  else
    goto <bb 25>;

  <bb 24>:
  _59 = MEM[(struct linux_binprm *)_249].interp_flags;
  _60 = _59 | 4;
  MEM[(struct linux_binprm *)_249].interp_flags = _60;

  <bb 25>:
  MEM[(struct linux_binprm *)_249].filename = pathbuf_52;

  <bb 26>:
  # pathbuf_143 = PHI <0B(18), pathbuf_52(25)>
  # prephitmp_267 = PHI <prephitmp_269(18), pathbuf_52(25)>
  MEM[(struct linux_binprm *)_249].interp = prephitmp_267;
  retval_62 = bprm_mm_init (_249);
  if (retval_62 != 0)
    goto <bb 27>;
  else
    goto <bb 28>;

  <bb 27>:
  pretmp_263 = (long int) retval_62;
  goto <bb 64> (out_unmark);

  <bb 28>:
  argv.171_6 = (const char * const *) argv_5(D);
  retval_63 = count.isra.25.constprop.43 (0, argv.171_6);
  MEM[(struct linux_binprm *)_249].argc = retval_63;
  if (retval_63 < 0)
    goto <bb 61> (out);
  else
    goto <bb 29>;

  <bb 29>:
  envp.170_4 = (const char * const *) envp_3(D);
  retval_64 = count.isra.25.constprop.43 (0, envp.170_4);
  MEM[(struct linux_binprm *)_249].envc = retval_64;
  if (retval_64 < 0)
    goto <bb 61> (out);
  else
    goto <bb 30>;

  <bb 30>:
  bprm_fill_uid (_249);
  retval_65 = security_bprm_set_creds (_249);
  if (retval_65 != 0)
    goto <bb 32>;
  else
    goto <bb 31>;

  <bb 31>:
  MEM[(struct linux_binprm *)_249].cred_prepared = 1;
  _66 = &MEM[(struct linux_binprm *)_249].buf;
  memset (_66, 0, 128);
  _67 = MEM[(struct linux_binprm *)_249].file;
  retval_68 = kernel_read (_67, 0, _66, 128);

  <bb 32>:
  # retval_69 = PHI <retval_65(30), retval_68(31)>
  if (retval_69 < 0)
    goto <bb 61> (out);
  else
    goto <bb 33>;

  <bb 33>:
  _70 = &MEM[(struct linux_binprm *)_249].filename;
  retval_71 = copy_strings_kernel (1, _70, _249);
  if (retval_71 < 0)
    goto <bb 61> (out);
  else
    goto <bb 34>;

  <bb 34>:
  _72 = MEM[(struct linux_binprm *)_249].p;
  MEM[(struct linux_binprm *)_249].exec = _72;
  _73 = MEM[(struct linux_binprm *)_249].envc;
  retval_74 = copy_strings.isra.27 (_73, 0, envp.170_4, _249);
  if (retval_74 < 0)
    goto <bb 61> (out);
  else
    goto <bb 35>;

  <bb 35>:
  _75 = MEM[(struct linux_binprm *)_249].argc;
  retval_76 = copy_strings.isra.27 (_75, 0, argv.171_6, _249);
  if (retval_76 < 0)
    goto <bb 61> (out);
  else
    goto <bb 36>;

  <bb 36>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___77 : "p" &current_task);
  old_pid_78 = pfo_ret___77->pid;
  __asm__ __volatile__("" :  :  : "memory");
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___79 : "p" &current_task);
  _80 = pfo_ret___79->parent;
  _81 = task_active_pid_ns (_80);
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___82 : "p" &current_task);
  _276 = __task_pid_nr_ns (pfo_ret___82, 0, _81);
  __asm__ __volatile__("" :  :  : "memory");
  _84 = MEM[(struct linux_binprm *)_249].recursion_depth;
  if (_84 > 5)
    goto <bb 70>;
  else
    goto <bb 37>;

  <bb 37>:
  retval_85 = security_bprm_check (_249);
  if (retval_85 != 0)
    goto <bb 57>;
  else
    goto <bb 38>;

  <bb 38>:

  # need_retry_102 = PHI <1(38), 0(56)>
  # retval_157 = PHI <-2(38), retval_210(56)>
retry:
  _raw_read_lock (&binfmt_lock);
  fmt_86 = formats.next;
  _241 = &fmt_86->lh;
  if (_241 != &formats)
    goto <bb 40>;
  else
    goto <bb 50>;

  <bb 40>:

  <bb 41>:
  # fmt_300 = PHI <fmt_100(49), fmt_86(40)>
  # retval_301 = PHI <retval_159(49), retval_157(40)>
  _88 = fmt_300->module;
  _89 = try_module_get (_88);
  if (_89 != 0)
    goto <bb 42>;
  else
    goto <bb 48>;

  <bb 42>:
  __raw_read_unlock.constprop.42 ();
  _90 = MEM[(struct linux_binprm *)_249].recursion_depth;
  _91 = _90 + 1;
  MEM[(struct linux_binprm *)_249].recursion_depth = _91;
  _92 = fmt_300->load_binary;
  retval_93 = _92 (_249);
  _raw_read_lock (&binfmt_lock);
  _94 = MEM[(struct linux_binfmt *)fmt_300 + 16B];
  module_put (_94);
  _95 = MEM[(struct linux_binprm *)_249].recursion_depth;
  _96 = _95 + 4294967295;
  MEM[(struct linux_binprm *)_249].recursion_depth = _96;
  if (retval_93 < 0)
    goto <bb 43>;
  else
    goto <bb 47>;

  <bb 43>:
  _97 = MEM[(struct linux_binprm *)_249].mm;
  if (_97 == 0B)
    goto <bb 44>;
  else
    goto <bb 45>;

  <bb 44>:
  __raw_read_unlock.constprop.42 ();
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___98 : "p" &current_task);
  force_sigsegv (11, pfo_ret___98);
  goto <bb 70>;

  <bb 45>:
  if (retval_93 != -8)
    goto <bb 47>;
  else
    goto <bb 46>;

  <bb 46>:
  _99 = MEM[(struct linux_binprm *)_249].file;
  if (_99 == 0B)
    goto <bb 47>;
  else
    goto <bb 48>;

  <bb 47>:
  # retval_155 = PHI <retval_93(42), retval_93(46), retval_93(45)>
  __raw_read_unlock.constprop.42 ();
  goto <bb 57>;

  <bb 48>:
  # retval_159 = PHI <retval_301(41), retval_93(46)>
  fmt_100 = fmt_300->lh.next;
  _101 = &fmt_100->lh;
  if (_101 != &formats)
    goto <bb 49>;
  else
    goto <bb 50>;

  <bb 49>:
  goto <bb 41>;

  <bb 50>:
  # retval_210 = PHI <retval_159(48), retval_157(39)>
  __raw_read_unlock.constprop.42 ();
  if (need_retry_102 != 0)
    goto <bb 51>;
  else
    goto <bb 57>;

  <bb 51>:
  _103 = MEM[(struct linux_binprm *)_249].buf[0];
  _104 = (unsigned char) _103;
  _105 = _104 + 247;
  _106 = _105 <= 1;
  _107 = _104 + 224;
  _108 = _107 <= 94;
  _109 = _108 | _106;
  if (_109 != 0)
    goto <bb 52>;
  else
    goto <bb 55>;

  <bb 52>:
  _110 = MEM[(struct linux_binprm *)_249].buf[1];
  _111 = (unsigned char) _110;
  _112 = _111 + 247;
  _113 = _112 <= 1;
  _114 = _111 + 224;
  _115 = _114 <= 94;
  _116 = _115 | _113;
  if (_116 != 0)
    goto <bb 53>;
  else
    goto <bb 55>;

  <bb 53>:
  _117 = MEM[(struct linux_binprm *)_249].buf[2];
  _118 = (unsigned char) _117;
  _119 = _118 + 247;
  _120 = _119 <= 1;
  _121 = _118 + 224;
  _122 = _121 <= 94;
  _123 = _122 | _120;
  if (_123 != 0)
    goto <bb 54>;
  else
    goto <bb 55>;

  <bb 54>:
  _124 = MEM[(struct linux_binprm *)_249].buf[3];
  _125 = (unsigned char) _124;
  _126 = _125 + 247;
  _127 = _126 <= 1;
  _128 = _125 + 224;
  _129 = _128 <= 94;
  _130 = _129 | _127;
  if (_130 != 0)
    goto <bb 57>;
  else
    goto <bb 55>;

  <bb 55>:
  _131 = MEM[(ushort *)_249 + 2B];
  _132 = (int) _131;
  _133 = __request_module (1, "binfmt-%04x", _132);
  if (_133 < 0)
    goto <bb 57>;
  else
    goto <bb 56>;

  <bb 56>:
  goto <bb 39> (retry);

  <bb 57>:
  # retval_134 = PHI <retval_210(54), retval_85(37), retval_210(55), retval_155(47), retval_210(50)>
  if (retval_134 >= 0)
    goto <bb 58>;
  else
    goto <bb 71>;

  <bb 58>:
  audit_bprm (_249);
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___135 : "p" &current_task);
  trace_sched_process_exec (pfo_ret___135, old_pid_78, _249);
  _136 = (long unsigned int) _276;
  ptrace_event.constprop.37 (_136);
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___137 : "p" &current_task);
  proc_exec_connector (pfo_ret___137);
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___138 : "p" &current_task);
  _139 = pfo_ret___138->fs;
  _139->in_exec = 0;
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___140 : "p" &current_task);
  pfo_ret___140->in_execve = 0;
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___141 : "p" &current_task);
  acct_update_integrals (pfo_ret___141);
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___142 : "p" &current_task);
  free_bprm (_249);
  kfree (pathbuf_143);
  putname (_16);
  displaced.82_144 = displaced;
  if (displaced.82_144 != 0B)
    goto <bb 60>;
  else
    goto <bb 59>;

  <bb 59>:
  pretmp_13 = (long int) retval_134;
  goto <bb 69>;

  <bb 60>:
  put_files_struct (displaced.82_144);
  pretmp_287 = (long int) retval_134;
  goto <bb 69>;

  # retval_160 = PHI <retval_63(28), retval_64(29), retval_69(32), retval_71(33), retval_74(34), retval_76(35), retval_298(71)>
out:
  _145 = MEM[(struct linux_binprm *)_249].mm;
  if (_145 != 0B)
    goto <bb 63>;
  else
    goto <bb 62>;

  <bb 62>:
  pretmp_264 = (long int) retval_160;
  goto <bb 64> (out_unmark);

  <bb 63>:
  _146 = &MEM[(struct linux_binprm *)_249 + 136B];
  acct_arg_size.isra.16 (_146, 0);
  _147 = MEM[(struct linux_binprm *)_249].mm;
  mmput (_147);
  pretmp_265 = (long int) retval_160;

  # pathbuf_161 = PHI <0B(14), pathbuf_52(22), pathbuf_143(27), pathbuf_143(62), pathbuf_143(63)>
  # prephitmp_266 = PHI <pretmp_262(14), -12(22), pretmp_263(27), pretmp_264(62), pretmp_265(63)>
out_unmark:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___148 : "p" &current_task);
  _149 = pfo_ret___148->fs;
  _149->in_exec = 0;
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___150 : "p" &current_task);
  pfo_ret___150->in_execve = 0;

  # pathbuf_151 = PHI <0B(12), pathbuf_161(64)>
  # prephitmp_158 = PHI <pretmp_172(12), prephitmp_266(64)>
out_free:
  free_bprm (_249);
  kfree (pathbuf_151);

  # prephitmp_261 = PHI <-12(10), prephitmp_158(65)>
out_files:
  displaced.82_152 = displaced;
  if (displaced.82_152 != 0B)
    goto <bb 67>;
  else
    goto <bb 68> (out_ret);

  <bb 67>:
  reset_files_struct (displaced.82_152);

  # prephitmp_299 = PHI <-11(7), pretmp_156(9), prephitmp_261(66), prephitmp_261(67)>
out_ret:
  putname (_16);

  <bb 69>:
  # prephitmp_83 = PHI <pretmp_270(5), pretmp_13(59), pretmp_287(60), prephitmp_299(68)>
  displaced ={v} {CLOBBER};
  return prephitmp_83;

  <bb 70>:
  # retval_303 = PHI <retval_93(44), -40(36)>

  <bb 71>:
  # retval_298 = PHI <retval_303(70), retval_134(57)>
  goto <bb 61> (out);

}



;; Function compat_SyS_execve (compat_SyS_execve, funcdef_no=2899, decl_uid=41321, cgraph_uid=2903)

compat_SyS_execve (long int filename, long int argv, long int envp)
{
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  pid_t old_pid;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct linux_binfmt * fmt;
  bool need_retry;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  long unsigned int ptr.4;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  long unsigned int ptr.4;
  int retval;
  struct files_struct * displaced;
  struct file * file;
  struct files_struct * displaced.82;
  const char * filename.176;
  const compat_uptr_t * argv.175;
  const compat_uptr_t * envp.174;
  struct filename * _9;
  long int _18;
  int _19;
  unsigned int _21;
  unsigned int _22;
  const struct cred * _24;
  struct user_struct * _25;
  int _26;
  long unsigned int _27;
  unsigned int _30;
  unsigned int _31;
  struct list_head * _33;
  int * _35;
  long int _38;
  const char * _44;
  char[128] * _53;
  struct file * _54;
  const char * * _57;
  long unsigned int _59;
  int _60;
  int _64;
  struct task_struct * _71;
  struct pid_namespace * _72;
  unsigned int _75;
  long int pretmp_78;
  struct module * _79;
  _Bool _80;
  unsigned int _81;
  unsigned int _82;
  int (*<T4b2d>) (struct linux_binprm *) _83;
  struct module * _85;
  unsigned int _86;
  unsigned int _87;
  struct mm_struct * _88;
  struct file * _90;
  struct list_head * _92;
  char _94;
  unsigned char _95;
  unsigned char _96;
  _Bool _97;
  unsigned char _98;
  _Bool _99;
  _Bool _100;
  char _101;
  unsigned char _102;
  unsigned char _103;
  _Bool _104;
  unsigned char _105;
  _Bool _106;
  _Bool _107;
  char _108;
  unsigned char _109;
  unsigned char _110;
  _Bool _111;
  unsigned char _112;
  _Bool _113;
  _Bool _114;
  char _115;
  unsigned char _116;
  unsigned char _117;
  _Bool _118;
  unsigned char _119;
  _Bool _120;
  _Bool _121;
  short unsigned int _122;
  int _123;
  int _124;
  long unsigned int _127;
  struct fs_struct * _130;
  struct mm_struct * _135;
  long unsigned int * _136;
  struct mm_struct * _137;
  struct fs_struct * _139;
  long int pretmp_146;
  struct signal_struct * _154;
  long long unsigned int _155;
  long int pretmp_161;
  long int prephitmp_224;
  struct kmem_cache * _235;
  void * _236;
  long int prephitmp_244;
  pid_t _246;
  long int pretmp_247;
  long int pretmp_254;
  long int prephitmp_255;

  <bb 2>:
  filename.176_6 = (const char *) filename_5(D);
  _9 = getname (filename.176_6);
  ptr.4_14 = (long unsigned int) _9;
  if (ptr.4_14 > 18446744073709547520)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _18 = (long int) _9;
  _19 = (int) _18;
  pretmp_146 = (long int) _19;
  goto <bb 53>;

  <bb 4>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___20 : "p" &current_task);
  _21 = pfo_ret___20->flags;
  _22 = _21 & 4096;
  if (_22 != 0)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___23 : "p" &current_task);
  _24 = pfo_ret___23->cred;
  _25 = _24->user;
  _26 ={v} MEM[(const int *)_25 + 4B];
  _27 = (long unsigned int) _26;
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___153 : "p" &current_task);
  _154 = MEM[(const struct task_struct *)pfo_ret___153].signal;
  _155 ={v} MEM[(volatile __u64 *)_154].rlim[6].rlim_cur;
  if (_27 > _155)
    goto <bb 52> (out_ret);
  else
    goto <bb 6>;

  <bb 6>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___29 : "p" &current_task);
  _30 = pfo_ret___29->flags;
  _31 = _30 & 4294963199;
  pfo_ret___29->flags = _31;
  retval_32 = unshare_files (&displaced);
  if (retval_32 != 0)
    goto <bb 7>;
  else
    goto <bb 8>;

  <bb 7>:
  pretmp_247 = (long int) retval_32;
  goto <bb 52> (out_ret);

  <bb 8>:
  _235 = kmalloc_caches[8];
  _236 = kmem_cache_alloc_trace (_235, 32976, 240);
  if (_236 == 0B)
    goto <bb 50> (out_files);
  else
    goto <bb 9>;

  <bb 9>:
  retval_34 = prepare_bprm_creds (_236);
  if (retval_34 != 0)
    goto <bb 49> (out_free);
  else
    goto <bb 10>;

  <bb 10>:
  _35 = &MEM[(struct linux_binprm *)_236 + 184B];
  check_unsafe_exec.isra.21 (_35);
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___36 : "p" &current_task);
  pfo_ret___36->in_execve = 1;
  file_37 = do_open_execat (-100, _9, 0);
  ptr.4_40 = (long unsigned int) file_37;
  if (ptr.4_40 > 18446744073709547520)
    goto <bb 11>;
  else
    goto <bb 12>;

  <bb 11>:
  _38 = (long int) file_37;
  retval_39 = (int) _38;
  goto <bb 48> (out_unmark);

  <bb 12>:
  sched_exec ();
  MEM[(struct linux_binprm *)_236].file = file_37;
  _44 = _9->name;
  MEM[(struct linux_binprm *)_236].filename = _44;
  MEM[(struct linux_binprm *)_236].interp = _44;
  retval_45 = bprm_mm_init (_236);
  if (retval_45 != 0)
    goto <bb 48> (out_unmark);
  else
    goto <bb 13>;

  <bb 13>:
  argv.175_4 = (const compat_uptr_t *) argv_3(D);
  retval_48 = count.isra.25.constprop.43 (1, argv.175_4);
  MEM[(struct linux_binprm *)_236].argc = retval_48;
  if (retval_48 < 0)
    goto <bb 46> (out);
  else
    goto <bb 14>;

  <bb 14>:
  envp.174_2 = (const compat_uptr_t *) envp_1(D);
  retval_51 = count.isra.25.constprop.43 (1, envp.174_2);
  MEM[(struct linux_binprm *)_236].envc = retval_51;
  if (retval_51 < 0)
    goto <bb 46> (out);
  else
    goto <bb 15>;

  <bb 15>:
  bprm_fill_uid (_236);
  retval_52 = security_bprm_set_creds (_236);
  if (retval_52 != 0)
    goto <bb 17>;
  else
    goto <bb 16>;

  <bb 16>:
  MEM[(struct linux_binprm *)_236].cred_prepared = 1;
  _53 = &MEM[(struct linux_binprm *)_236].buf;
  memset (_53, 0, 128);
  _54 = MEM[(struct linux_binprm *)_236].file;
  retval_55 = kernel_read (_54, 0, _53, 128);

  <bb 17>:
  # retval_56 = PHI <retval_52(15), retval_55(16)>
  if (retval_56 < 0)
    goto <bb 46> (out);
  else
    goto <bb 18>;

  <bb 18>:
  _57 = &MEM[(struct linux_binprm *)_236].filename;
  retval_58 = copy_strings_kernel (1, _57, _236);
  if (retval_58 < 0)
    goto <bb 46> (out);
  else
    goto <bb 19>;

  <bb 19>:
  _59 = MEM[(struct linux_binprm *)_236].p;
  MEM[(struct linux_binprm *)_236].exec = _59;
  _60 = MEM[(struct linux_binprm *)_236].envc;
  retval_63 = copy_strings.isra.27 (_60, 1, envp.174_2, _236);
  if (retval_63 < 0)
    goto <bb 46> (out);
  else
    goto <bb 20>;

  <bb 20>:
  _64 = MEM[(struct linux_binprm *)_236].argc;
  retval_67 = copy_strings.isra.27 (_64, 1, argv.175_4, _236);
  if (retval_67 < 0)
    goto <bb 46> (out);
  else
    goto <bb 21>;

  <bb 21>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___68 : "p" &current_task);
  old_pid_69 = pfo_ret___68->pid;
  __asm__ __volatile__("" :  :  : "memory");
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___70 : "p" &current_task);
  _71 = pfo_ret___70->parent;
  _72 = task_active_pid_ns (_71);
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___73 : "p" &current_task);
  _246 = __task_pid_nr_ns (pfo_ret___73, 0, _72);
  __asm__ __volatile__("" :  :  : "memory");
  _75 = MEM[(struct linux_binprm *)_236].recursion_depth;
  if (_75 > 5)
    goto <bb 54>;
  else
    goto <bb 22>;

  <bb 22>:
  retval_76 = security_bprm_check (_236);
  if (retval_76 != 0)
    goto <bb 42>;
  else
    goto <bb 23>;

  <bb 23>:

  # need_retry_93 = PHI <1(23), 0(41)>
  # retval_145 = PHI <-2(23), retval_192(41)>
retry:
  _raw_read_lock (&binfmt_lock);
  fmt_77 = formats.next;
  _33 = &fmt_77->lh;
  if (_33 != &formats)
    goto <bb 25>;
  else
    goto <bb 35>;

  <bb 25>:

  <bb 26>:
  # fmt_74 = PHI <fmt_91(34), fmt_77(25)>
  # retval_252 = PHI <retval_147(34), retval_145(25)>
  _79 = fmt_74->module;
  _80 = try_module_get (_79);
  if (_80 != 0)
    goto <bb 27>;
  else
    goto <bb 33>;

  <bb 27>:
  __raw_read_unlock.constprop.42 ();
  _81 = MEM[(struct linux_binprm *)_236].recursion_depth;
  _82 = _81 + 1;
  MEM[(struct linux_binprm *)_236].recursion_depth = _82;
  _83 = fmt_74->load_binary;
  retval_84 = _83 (_236);
  _raw_read_lock (&binfmt_lock);
  _85 = MEM[(struct linux_binfmt *)fmt_74 + 16B];
  module_put (_85);
  _86 = MEM[(struct linux_binprm *)_236].recursion_depth;
  _87 = _86 + 4294967295;
  MEM[(struct linux_binprm *)_236].recursion_depth = _87;
  if (retval_84 < 0)
    goto <bb 28>;
  else
    goto <bb 32>;

  <bb 28>:
  _88 = MEM[(struct linux_binprm *)_236].mm;
  if (_88 == 0B)
    goto <bb 29>;
  else
    goto <bb 30>;

  <bb 29>:
  __raw_read_unlock.constprop.42 ();
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___89 : "p" &current_task);
  force_sigsegv (11, pfo_ret___89);
  goto <bb 54>;

  <bb 30>:
  if (retval_84 != -8)
    goto <bb 32>;
  else
    goto <bb 31>;

  <bb 31>:
  _90 = MEM[(struct linux_binprm *)_236].file;
  if (_90 == 0B)
    goto <bb 32>;
  else
    goto <bb 33>;

  <bb 32>:
  # retval_143 = PHI <retval_84(27), retval_84(31), retval_84(30)>
  __raw_read_unlock.constprop.42 ();
  goto <bb 42>;

  <bb 33>:
  # retval_147 = PHI <retval_252(26), retval_84(31)>
  fmt_91 = fmt_74->lh.next;
  _92 = &fmt_91->lh;
  if (_92 != &formats)
    goto <bb 34>;
  else
    goto <bb 35>;

  <bb 34>:
  goto <bb 26>;

  <bb 35>:
  # retval_192 = PHI <retval_147(33), retval_145(24)>
  __raw_read_unlock.constprop.42 ();
  if (need_retry_93 != 0)
    goto <bb 36>;
  else
    goto <bb 42>;

  <bb 36>:
  _94 = MEM[(struct linux_binprm *)_236].buf[0];
  _95 = (unsigned char) _94;
  _96 = _95 + 247;
  _97 = _96 <= 1;
  _98 = _95 + 224;
  _99 = _98 <= 94;
  _100 = _99 | _97;
  if (_100 != 0)
    goto <bb 37>;
  else
    goto <bb 40>;

  <bb 37>:
  _101 = MEM[(struct linux_binprm *)_236].buf[1];
  _102 = (unsigned char) _101;
  _103 = _102 + 247;
  _104 = _103 <= 1;
  _105 = _102 + 224;
  _106 = _105 <= 94;
  _107 = _106 | _104;
  if (_107 != 0)
    goto <bb 38>;
  else
    goto <bb 40>;

  <bb 38>:
  _108 = MEM[(struct linux_binprm *)_236].buf[2];
  _109 = (unsigned char) _108;
  _110 = _109 + 247;
  _111 = _110 <= 1;
  _112 = _109 + 224;
  _113 = _112 <= 94;
  _114 = _113 | _111;
  if (_114 != 0)
    goto <bb 39>;
  else
    goto <bb 40>;

  <bb 39>:
  _115 = MEM[(struct linux_binprm *)_236].buf[3];
  _116 = (unsigned char) _115;
  _117 = _116 + 247;
  _118 = _117 <= 1;
  _119 = _116 + 224;
  _120 = _119 <= 94;
  _121 = _120 | _118;
  if (_121 != 0)
    goto <bb 42>;
  else
    goto <bb 40>;

  <bb 40>:
  _122 = MEM[(ushort *)_236 + 2B];
  _123 = (int) _122;
  _124 = __request_module (1, "binfmt-%04x", _123);
  if (_124 < 0)
    goto <bb 42>;
  else
    goto <bb 41>;

  <bb 41>:
  goto <bb 24> (retry);

  <bb 42>:
  # retval_125 = PHI <retval_192(39), retval_76(22), retval_192(40), retval_143(32), retval_192(35)>
  if (retval_125 >= 0)
    goto <bb 43>;
  else
    goto <bb 55>;

  <bb 43>:
  audit_bprm (_236);
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___126 : "p" &current_task);
  trace_sched_process_exec (pfo_ret___126, old_pid_69, _236);
  _127 = (long unsigned int) _246;
  ptrace_event.constprop.37 (_127);
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___128 : "p" &current_task);
  proc_exec_connector (pfo_ret___128);
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___129 : "p" &current_task);
  _130 = pfo_ret___129->fs;
  _130->in_exec = 0;
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___131 : "p" &current_task);
  pfo_ret___131->in_execve = 0;
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___132 : "p" &current_task);
  acct_update_integrals (pfo_ret___132);
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___133 : "p" &current_task);
  free_bprm (_236);
  kfree (0B);
  putname (_9);
  displaced.82_134 = displaced;
  if (displaced.82_134 != 0B)
    goto <bb 45>;
  else
    goto <bb 44>;

  <bb 44>:
  pretmp_78 = (long int) retval_125;
  goto <bb 53>;

  <bb 45>:
  put_files_struct (displaced.82_134);
  pretmp_254 = (long int) retval_125;
  goto <bb 53>;

  # retval_148 = PHI <retval_48(13), retval_51(14), retval_56(17), retval_58(18), retval_63(19), retval_67(20), retval_157(55)>
out:
  _135 = MEM[(struct linux_binprm *)_236].mm;
  if (_135 != 0B)
    goto <bb 47>;
  else
    goto <bb 48> (out_unmark);

  <bb 47>:
  _136 = &MEM[(struct linux_binprm *)_236 + 136B];
  acct_arg_size.isra.16 (_136, 0);
  _137 = MEM[(struct linux_binprm *)_236].mm;
  mmput (_137);

  # retval_149 = PHI <retval_39(11), retval_45(12), retval_148(46), retval_148(47)>
out_unmark:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___138 : "p" &current_task);
  _139 = pfo_ret___138->fs;
  _139->in_exec = 0;
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___140 : "p" &current_task);
  pfo_ret___140->in_execve = 0;

  # retval_150 = PHI <retval_34(9), retval_149(48)>
out_free:
  free_bprm (_236);
  kfree (0B);
  pretmp_161 = (long int) retval_150;

  # prephitmp_244 = PHI <-12(8), pretmp_161(49)>
out_files:
  displaced.82_141 = displaced;
  if (displaced.82_141 != 0B)
    goto <bb 51>;
  else
    goto <bb 52> (out_ret);

  <bb 51>:
  reset_files_struct (displaced.82_141);

  # prephitmp_224 = PHI <-11(5), pretmp_247(7), prephitmp_244(50), prephitmp_244(51)>
out_ret:
  putname (_9);

  <bb 53>:
  # prephitmp_255 = PHI <pretmp_146(3), pretmp_78(44), pretmp_254(45), prephitmp_224(52)>
  displaced ={v} {CLOBBER};
  return prephitmp_255;

  <bb 54>:
  # retval_257 = PHI <retval_84(29), -40(21)>

  <bb 55>:
  # retval_157 = PHI <retval_257(54), retval_125(42)>
  goto <bb 46> (out);

}



;; Function compat_SyS_execveat (compat_SyS_execveat, funcdef_no=2901, decl_uid=41349, cgraph_uid=2906)

compat_SyS_execveat (long int fd, long int filename, long int argv, long int envp, long int flags)
{
  const char * const * argv$8;
  const char * const * envp$8;
  int oldbit;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  pid_t old_pid;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct linux_binfmt * fmt;
  bool need_retry;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  long unsigned int ptr.4;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  struct task_struct * pfo_ret__;
  long unsigned int ptr.4;
  struct fdtable * ________p1;
  int retval;
  struct files_struct * displaced;
  struct file * file;
  char * pathbuf;
  struct files_struct * displaced.82;
  int lookup_flags;
  const char * filename.179;
  int _2;
  int _10;
  long int pretmp_13;
  int _14;
  struct filename * _16;
  long int _23;
  int _24;
  unsigned int _26;
  unsigned int _27;
  const struct cred * _29;
  struct user_struct * _30;
  int _31;
  long unsigned int _32;
  unsigned int _35;
  unsigned int _36;
  long int pretmp_38;
  int * _40;
  long int _43;
  const char * _49;
  char _50;
  struct files_struct * _56;
  long long unsigned int _57;
  long unsigned int * _59;
  unsigned int _61;
  unsigned int _62;
  long int prephitmp_65;
  long int prephitmp_68;
  long int pretmp_69;
  char[128] * _72;
  struct file * _73;
  const char * * _76;
  long unsigned int _78;
  int _79;
  int _83;
  struct task_struct * _90;
  struct pid_namespace * _91;
  unsigned int _94;
  struct module * _98;
  _Bool _99;
  unsigned int _100;
  unsigned int _101;
  int (*<T4b2d>) (struct linux_binprm *) _102;
  struct module * _104;
  unsigned int _105;
  unsigned int _106;
  struct mm_struct * _107;
  struct file * _109;
  struct list_head * _111;
  char _113;
  unsigned char _114;
  unsigned char _115;
  _Bool _116;
  unsigned char _117;
  _Bool _118;
  _Bool _119;
  char _120;
  unsigned char _121;
  unsigned char _122;
  _Bool _123;
  unsigned char _124;
  _Bool _125;
  _Bool _126;
  char _127;
  unsigned char _128;
  unsigned char _129;
  _Bool _130;
  unsigned char _131;
  _Bool _132;
  _Bool _133;
  char _134;
  unsigned char _135;
  unsigned char _136;
  _Bool _137;
  unsigned char _138;
  _Bool _139;
  _Bool _140;
  short unsigned int _141;
  int _142;
  int _143;
  long unsigned int _146;
  struct fs_struct * _149;
  struct mm_struct * _155;
  long unsigned int * _156;
  struct mm_struct * _157;
  struct fs_struct * _159;
  struct signal_struct * _176;
  long long unsigned int _177;
  long int pretmp_185;
  struct list_head * _250;
  struct kmem_cache * _257;
  void * _258;
  long int pretmp_268;
  const char * prephitmp_270;
  long int pretmp_271;
  long int pretmp_272;
  long int pretmp_273;
  long int prephitmp_274;
  long int pretmp_275;
  long int prephitmp_276;
  long int _281;
  const char * pretmp_284;
  pid_t _285;
  long int prephitmp_301;
  const char * prephitmp_307;

  <bb 2>:
  _2 = (int) flags_1(D);
  filename.179_8 = (const char *) filename_7(D);
  _14 = _2 & 4096;
  if (_14 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:

  <bb 4>:
  # lookup_flags_15 = PHI <16384(3), 0(2)>
  _16 = getname_flags (filename.179_8, lookup_flags_15, 0B);
  ptr.4_19 = (long unsigned int) _16;
  if (ptr.4_19 > 18446744073709547520)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  _23 = (long int) _16;
  _24 = (int) _23;
  pretmp_271 = (long int) _24;
  goto <bb 69>;

  <bb 6>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___25 : "p" &current_task);
  _26 = pfo_ret___25->flags;
  _27 = _26 & 4096;
  if (_27 != 0)
    goto <bb 7>;
  else
    goto <bb 8>;

  <bb 7>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___28 : "p" &current_task);
  _29 = pfo_ret___28->cred;
  _30 = _29->user;
  _31 ={v} MEM[(const int *)_30 + 4B];
  _32 = (long unsigned int) _31;
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___175 : "p" &current_task);
  _176 = MEM[(const struct task_struct *)pfo_ret___175].signal;
  _177 ={v} MEM[(volatile __u64 *)_176].rlim[6].rlim_cur;
  if (_32 > _177)
    goto <bb 68> (out_ret);
  else
    goto <bb 8>;

  <bb 8>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___34 : "p" &current_task);
  _35 = pfo_ret___34->flags;
  _36 = _35 & 4294963199;
  pfo_ret___34->flags = _36;
  retval_37 = unshare_files (&displaced);
  if (retval_37 != 0)
    goto <bb 9>;
  else
    goto <bb 10>;

  <bb 9>:
  pretmp_185 = (long int) retval_37;
  goto <bb 68> (out_ret);

  <bb 10>:
  _257 = kmalloc_caches[8];
  _258 = kmem_cache_alloc_trace (_257, 32976, 240);
  if (_258 == 0B)
    goto <bb 66> (out_files);
  else
    goto <bb 11>;

  <bb 11>:
  retval_39 = prepare_bprm_creds (_258);
  if (retval_39 != 0)
    goto <bb 12>;
  else
    goto <bb 13>;

  <bb 12>:
  pretmp_275 = (long int) retval_39;
  goto <bb 65> (out_free);

  <bb 13>:
  _10 = (int) fd_9(D);
  _40 = &MEM[(struct linux_binprm *)_258 + 184B];
  check_unsafe_exec.isra.21 (_40);
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___41 : "p" &current_task);
  pfo_ret___41->in_execve = 1;
  file_42 = do_open_execat (_10, _16, _2);
  ptr.4_45 = (long unsigned int) file_42;
  if (ptr.4_45 > 18446744073709547520)
    goto <bb 14>;
  else
    goto <bb 15>;

  <bb 14>:
  _43 = (long int) file_42;
  retval_44 = (int) _43;
  pretmp_69 = (long int) retval_44;
  goto <bb 64> (out_unmark);

  <bb 15>:
  sched_exec ();
  MEM[(struct linux_binprm *)_258].file = file_42;
  if (_10 == -100)
    goto <bb 16>;
  else
    goto <bb 17>;

  <bb 16>:
  pretmp_284 = _16->name;
  goto <bb 18>;

  <bb 17>:
  _49 = _16->name;
  _50 = *_49;
  if (_50 == 47)
    goto <bb 18>;
  else
    goto <bb 19>;

  <bb 18>:
  # prephitmp_270 = PHI <pretmp_284(16), _49(17)>
  MEM[(struct linux_binprm *)_258].filename = prephitmp_270;
  goto <bb 26>;

  <bb 19>:
  if (_50 == 0)
    goto <bb 20>;
  else
    goto <bb 21>;

  <bb 20>:
  pathbuf_52 = kasprintf (524496, "/dev/fd/%d", _10);
  goto <bb 22>;

  <bb 21>:
  pathbuf_53 = kasprintf (524496, "/dev/fd/%d/%s", _10, _49);

  <bb 22>:
  # pathbuf_54 = PHI <pathbuf_52(20), pathbuf_53(21)>
  if (pathbuf_54 == 0B)
    goto <bb 64> (out_unmark);
  else
    goto <bb 23>;

  <bb 23>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___55 : "p" &current_task);
  _56 = pfo_ret___55->files;
  _57 ={v} MEM[(volatile __u64 *)_56 + 32B];
  ________p1_58 = (struct fdtable *) _57;
  _59 = MEM[(const struct fdtable *)________p1_58 + 16B];
  _281 = (long int) _10;
  __asm__ __volatile__("bt %2,%1
	sbb %0,%0" : "=r" oldbit_282 : "m" *_59, "Ir" _281);
  if (oldbit_282 != 0)
    goto <bb 24>;
  else
    goto <bb 25>;

  <bb 24>:
  _61 = MEM[(struct linux_binprm *)_258].interp_flags;
  _62 = _61 | 4;
  MEM[(struct linux_binprm *)_258].interp_flags = _62;

  <bb 25>:
  MEM[(struct linux_binprm *)_258].filename = pathbuf_54;

  <bb 26>:
  # pathbuf_153 = PHI <0B(18), pathbuf_54(25)>
  # prephitmp_307 = PHI <prephitmp_270(18), pathbuf_54(25)>
  MEM[(struct linux_binprm *)_258].interp = prephitmp_307;
  retval_64 = bprm_mm_init (_258);
  if (retval_64 != 0)
    goto <bb 27>;
  else
    goto <bb 28>;

  <bb 27>:
  pretmp_268 = (long int) retval_64;
  goto <bb 64> (out_unmark);

  <bb 28>:
  argv$8_6 = (const char * const *) argv_5(D);
  retval_67 = count.isra.25.constprop.43 (1, argv$8_6);
  MEM[(struct linux_binprm *)_258].argc = retval_67;
  if (retval_67 < 0)
    goto <bb 61> (out);
  else
    goto <bb 29>;

  <bb 29>:
  envp$8_4 = (const char * const *) envp_3(D);
  retval_70 = count.isra.25.constprop.43 (1, envp$8_4);
  MEM[(struct linux_binprm *)_258].envc = retval_70;
  if (retval_70 < 0)
    goto <bb 61> (out);
  else
    goto <bb 30>;

  <bb 30>:
  bprm_fill_uid (_258);
  retval_71 = security_bprm_set_creds (_258);
  if (retval_71 != 0)
    goto <bb 32>;
  else
    goto <bb 31>;

  <bb 31>:
  MEM[(struct linux_binprm *)_258].cred_prepared = 1;
  _72 = &MEM[(struct linux_binprm *)_258].buf;
  memset (_72, 0, 128);
  _73 = MEM[(struct linux_binprm *)_258].file;
  retval_74 = kernel_read (_73, 0, _72, 128);

  <bb 32>:
  # retval_75 = PHI <retval_71(30), retval_74(31)>
  if (retval_75 < 0)
    goto <bb 61> (out);
  else
    goto <bb 33>;

  <bb 33>:
  _76 = &MEM[(struct linux_binprm *)_258].filename;
  retval_77 = copy_strings_kernel (1, _76, _258);
  if (retval_77 < 0)
    goto <bb 61> (out);
  else
    goto <bb 34>;

  <bb 34>:
  _78 = MEM[(struct linux_binprm *)_258].p;
  MEM[(struct linux_binprm *)_258].exec = _78;
  _79 = MEM[(struct linux_binprm *)_258].envc;
  retval_82 = copy_strings.isra.27 (_79, 1, envp$8_4, _258);
  if (retval_82 < 0)
    goto <bb 61> (out);
  else
    goto <bb 35>;

  <bb 35>:
  _83 = MEM[(struct linux_binprm *)_258].argc;
  retval_86 = copy_strings.isra.27 (_83, 1, argv$8_6, _258);
  if (retval_86 < 0)
    goto <bb 61> (out);
  else
    goto <bb 36>;

  <bb 36>:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___87 : "p" &current_task);
  old_pid_88 = pfo_ret___87->pid;
  __asm__ __volatile__("" :  :  : "memory");
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___89 : "p" &current_task);
  _90 = pfo_ret___89->parent;
  _91 = task_active_pid_ns (_90);
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___92 : "p" &current_task);
  _285 = __task_pid_nr_ns (pfo_ret___92, 0, _91);
  __asm__ __volatile__("" :  :  : "memory");
  _94 = MEM[(struct linux_binprm *)_258].recursion_depth;
  if (_94 > 5)
    goto <bb 70>;
  else
    goto <bb 37>;

  <bb 37>:
  retval_95 = security_bprm_check (_258);
  if (retval_95 != 0)
    goto <bb 57>;
  else
    goto <bb 38>;

  <bb 38>:

  # need_retry_112 = PHI <1(38), 0(56)>
  # retval_166 = PHI <-2(38), retval_165(56)>
retry:
  _raw_read_lock (&binfmt_lock);
  fmt_96 = formats.next;
  _250 = &fmt_96->lh;
  if (_250 != &formats)
    goto <bb 40>;
  else
    goto <bb 50>;

  <bb 40>:

  <bb 41>:
  # fmt_308 = PHI <fmt_110(49), fmt_96(40)>
  # retval_309 = PHI <retval_168(49), retval_166(40)>
  _98 = fmt_308->module;
  _99 = try_module_get (_98);
  if (_99 != 0)
    goto <bb 42>;
  else
    goto <bb 48>;

  <bb 42>:
  __raw_read_unlock.constprop.42 ();
  _100 = MEM[(struct linux_binprm *)_258].recursion_depth;
  _101 = _100 + 1;
  MEM[(struct linux_binprm *)_258].recursion_depth = _101;
  _102 = fmt_308->load_binary;
  retval_103 = _102 (_258);
  _raw_read_lock (&binfmt_lock);
  _104 = MEM[(struct linux_binfmt *)fmt_308 + 16B];
  module_put (_104);
  _105 = MEM[(struct linux_binprm *)_258].recursion_depth;
  _106 = _105 + 4294967295;
  MEM[(struct linux_binprm *)_258].recursion_depth = _106;
  if (retval_103 < 0)
    goto <bb 43>;
  else
    goto <bb 47>;

  <bb 43>:
  _107 = MEM[(struct linux_binprm *)_258].mm;
  if (_107 == 0B)
    goto <bb 44>;
  else
    goto <bb 45>;

  <bb 44>:
  __raw_read_unlock.constprop.42 ();
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___108 : "p" &current_task);
  force_sigsegv (11, pfo_ret___108);
  goto <bb 70>;

  <bb 45>:
  if (retval_103 != -8)
    goto <bb 47>;
  else
    goto <bb 46>;

  <bb 46>:
  _109 = MEM[(struct linux_binprm *)_258].file;
  if (_109 == 0B)
    goto <bb 47>;
  else
    goto <bb 48>;

  <bb 47>:
  # retval_286 = PHI <retval_103(42), retval_103(46), retval_103(45)>
  __raw_read_unlock.constprop.42 ();
  goto <bb 57>;

  <bb 48>:
  # retval_168 = PHI <retval_309(41), retval_103(46)>
  fmt_110 = fmt_308->lh.next;
  _111 = &fmt_110->lh;
  if (_111 != &formats)
    goto <bb 49>;
  else
    goto <bb 50>;

  <bb 49>:
  goto <bb 41>;

  <bb 50>:
  # retval_165 = PHI <retval_168(48), retval_166(39)>
  __raw_read_unlock.constprop.42 ();
  if (need_retry_112 != 0)
    goto <bb 51>;
  else
    goto <bb 57>;

  <bb 51>:
  _113 = MEM[(struct linux_binprm *)_258].buf[0];
  _114 = (unsigned char) _113;
  _115 = _114 + 247;
  _116 = _115 <= 1;
  _117 = _114 + 224;
  _118 = _117 <= 94;
  _119 = _118 | _116;
  if (_119 != 0)
    goto <bb 52>;
  else
    goto <bb 55>;

  <bb 52>:
  _120 = MEM[(struct linux_binprm *)_258].buf[1];
  _121 = (unsigned char) _120;
  _122 = _121 + 247;
  _123 = _122 <= 1;
  _124 = _121 + 224;
  _125 = _124 <= 94;
  _126 = _125 | _123;
  if (_126 != 0)
    goto <bb 53>;
  else
    goto <bb 55>;

  <bb 53>:
  _127 = MEM[(struct linux_binprm *)_258].buf[2];
  _128 = (unsigned char) _127;
  _129 = _128 + 247;
  _130 = _129 <= 1;
  _131 = _128 + 224;
  _132 = _131 <= 94;
  _133 = _132 | _130;
  if (_133 != 0)
    goto <bb 54>;
  else
    goto <bb 55>;

  <bb 54>:
  _134 = MEM[(struct linux_binprm *)_258].buf[3];
  _135 = (unsigned char) _134;
  _136 = _135 + 247;
  _137 = _136 <= 1;
  _138 = _135 + 224;
  _139 = _138 <= 94;
  _140 = _139 | _137;
  if (_140 != 0)
    goto <bb 57>;
  else
    goto <bb 55>;

  <bb 55>:
  _141 = MEM[(ushort *)_258 + 2B];
  _142 = (int) _141;
  _143 = __request_module (1, "binfmt-%04x", _142);
  if (_143 < 0)
    goto <bb 57>;
  else
    goto <bb 56>;

  <bb 56>:
  goto <bb 39> (retry);

  <bb 57>:
  # retval_144 = PHI <retval_165(54), retval_95(37), retval_165(55), retval_286(47), retval_165(50)>
  if (retval_144 >= 0)
    goto <bb 58>;
  else
    goto <bb 71>;

  <bb 58>:
  audit_bprm (_258);
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___145 : "p" &current_task);
  trace_sched_process_exec (pfo_ret___145, old_pid_88, _258);
  _146 = (long unsigned int) _285;
  ptrace_event.constprop.37 (_146);
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___147 : "p" &current_task);
  proc_exec_connector (pfo_ret___147);
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___148 : "p" &current_task);
  _149 = pfo_ret___148->fs;
  _149->in_exec = 0;
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___150 : "p" &current_task);
  pfo_ret___150->in_execve = 0;
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___151 : "p" &current_task);
  acct_update_integrals (pfo_ret___151);
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___152 : "p" &current_task);
  free_bprm (_258);
  kfree (pathbuf_153);
  putname (_16);
  displaced.82_154 = displaced;
  if (displaced.82_154 != 0B)
    goto <bb 60>;
  else
    goto <bb 59>;

  <bb 59>:
  pretmp_272 = (long int) retval_144;
  goto <bb 69>;

  <bb 60>:
  put_files_struct (displaced.82_154);
  pretmp_273 = (long int) retval_144;
  goto <bb 69>;

  # retval_169 = PHI <retval_67(28), retval_70(29), retval_75(32), retval_77(33), retval_82(34), retval_86(35), retval_306(71)>
out:
  _155 = MEM[(struct linux_binprm *)_258].mm;
  if (_155 != 0B)
    goto <bb 63>;
  else
    goto <bb 62>;

  <bb 62>:
  pretmp_13 = (long int) retval_169;
  goto <bb 64> (out_unmark);

  <bb 63>:
  _156 = &MEM[(struct linux_binprm *)_258 + 136B];
  acct_arg_size.isra.16 (_156, 0);
  _157 = MEM[(struct linux_binprm *)_258].mm;
  mmput (_157);
  pretmp_38 = (long int) retval_169;

  # pathbuf_170 = PHI <0B(14), pathbuf_54(22), pathbuf_153(27), pathbuf_153(62), pathbuf_153(63)>
  # prephitmp_301 = PHI <pretmp_69(14), -12(22), pretmp_268(27), pretmp_13(62), pretmp_38(63)>
out_unmark:
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___158 : "p" &current_task);
  _159 = pfo_ret___158->fs;
  _159->in_exec = 0;
  __asm__("movq %%gs:%P1,%0" : "=r" pfo_ret___160 : "p" &current_task);
  pfo_ret___160->in_execve = 0;

  # pathbuf_161 = PHI <0B(12), pathbuf_170(64)>
  # prephitmp_276 = PHI <pretmp_275(12), prephitmp_301(64)>
out_free:
  free_bprm (_258);
  kfree (pathbuf_161);

  # prephitmp_68 = PHI <-12(10), prephitmp_276(65)>
out_files:
  displaced.82_162 = displaced;
  if (displaced.82_162 != 0B)
    goto <bb 67>;
  else
    goto <bb 68> (out_ret);

  <bb 67>:
  reset_files_struct (displaced.82_162);

  # prephitmp_65 = PHI <-11(7), pretmp_185(9), prephitmp_68(66), prephitmp_68(67)>
out_ret:
  putname (_16);

  <bb 69>:
  # prephitmp_274 = PHI <pretmp_271(5), pretmp_272(59), pretmp_273(60), prephitmp_65(68)>
  displaced ={v} {CLOBBER};
  return prephitmp_274;

  <bb 70>:
  # retval_311 = PHI <retval_103(44), -40(36)>

  <bb 71>:
  # retval_306 = PHI <retval_311(70), retval_144(57)>
  goto <bb 61> (out);

}


